// src/hooks/useGoogleDrivePicker.js
// Reusable hook for Google Drive Picker functionality
import { useState, useEffect, useCallback, useRef } from 'react';
import PICKER_CONFIG, { PICKER_BUILDERS, PICKER_UTILS } from '../config/GoogleDrivePickerConfig';

const useGoogleDrivePicker = (options = {}) => {
  const {
    multiSelect = true,
    userEmail = null,
    onFoldersSelected = null,
    onError = null,
    autoLoadApi = true
  } = options;

  // State management
  const [isApiLoaded, setIsApiLoaded] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState(null);
  const [pickerToken, setPickerToken] = useState(null);
  const [selectedFolders, setSelectedFolders] = useState([]);

  // Refs for cleanup
  const pickerRef = useRef(null);
  const tokenTimeoutRef = useRef(null);
  const apiLoadTimeoutRef = useRef(null);

  // Clear all timeouts on unmount
  useEffect(() => {
    return () => {
      if (tokenTimeoutRef.current) {
        clearTimeout(tokenTimeoutRef.current);
      }
      if (apiLoadTimeoutRef.current) {
        clearTimeout(apiLoadTimeoutRef.current);
      }
    };
  }, []);

  // Load Google Picker API
  const loadPickerApi = useCallback(() => {
    if (isApiLoaded || !window.gapi) return;

    const loadTimeout = setTimeout(() => {
      setError(PICKER_UTILS.getErrorMessage('apiLoadFailed'));
    }, PICKER_CONFIG.performance.apiLoadTimeout);

    apiLoadTimeoutRef.current = loadTimeout;

    window.gapi.load('picker', {
      callback: () => {
        clearTimeout(loadTimeout);
        setIsApiLoaded(true);
        setError(null);
        if (PICKER_CONFIG.development.enableConsoleLogging) {
          console.log('âœ… Google Picker API loaded successfully');
        }
      },
      onerror: (error) => {
        clearTimeout(loadTimeout);
        console.error('âŒ Failed to load Google Picker API:', error);
        setError(PICKER_UTILS.getErrorMessage('apiLoadFailed'));
      }
    });
  }, [isApiLoaded]);

  // Auto-load API on mount
  useEffect(() => {
    if (autoLoadApi) {
      const checkAndLoad = () => {
        if (window.gapi) {
          loadPickerApi();
        } else {
          // Retry after delay if gapi not ready
          setTimeout(checkAndLoad, 1000);
        }
      };
      checkAndLoad();
    }
  }, [autoLoadApi, loadPickerApi]);

  // Get picker token from backend
  const getPickerToken = useCallback(async () => {
    try {
      setError(null);
      
      const response = await fetch(PICKER_CONFIG.api.tokenEndpoint, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          provider: PICKER_CONFIG.api.provider,
          user_email: userEmail
        })
      });

      if (!response.ok) {
        const errorData = await response.json();
        
        // Handle specific error types
        if (response.status === 429) {
          throw new Error(PICKER_UTILS.getErrorMessage('rateLimitExceeded'));
        } else if (response.status === 401) {
          throw new Error(PICKER_UTILS.getErrorMessage('tokenExpired'));
        } else {
          throw new Error(errorData.message || PICKER_UTILS.getErrorMessage('serverError'));
        }
      }

      const tokenData = await response.json();
      
      if (!tokenData.success) {
        throw new Error(tokenData.message || PICKER_UTILS.getErrorMessage('tokenFailed'));
      }

      setPickerToken(tokenData.picker_token);
      
      // Set token refresh timer
      if (tokenData.expires_in) {
        const refreshTime = (tokenData.expires_in - 300) * 1000; // Refresh 5 min before expiry
        tokenTimeoutRef.current = setTimeout(() => {
          setPickerToken(null);
        }, refreshTime);
      }

      if (PICKER_CONFIG.development.enableConsoleLogging) {
        console.log('âœ… Picker token obtained successfully');
      }
      
      return tokenData.picker_token;
      
    } catch (error) {
      console.error('âŒ Error getting picker token:', error);
      const errorMessage = error.message || PICKER_UTILS.getErrorMessage('tokenFailed');
      setError(errorMessage);
      
      if (onError) {
        onError(errorMessage);
      }
      
      return null;
    }
  }, [userEmail, onError]);

  // Handle picker callback
  const handlePickerCallback = useCallback((data) => {
    if (PICKER_CONFIG.development.enableConsoleLogging) {
      console.log('ðŸ”„ Picker callback received:', data);
    }
    
    if (data.action === window.google.picker.Action.PICKED) {
      try {
        const selectedDocs = data.docs || [];
        
        // Format and validate selection
        const folders = PICKER_UTILS.formatFolderData(selectedDocs);
        const validation = PICKER_UTILS.validateSelection(folders);
        
        if (!validation.valid) {
          setError(validation.error);
          return;
        }

        setSelectedFolders(folders);
        setError(null);

        if (PICKER_CONFIG.development.enableConsoleLogging) {
          console.log(`âœ… Selected ${folders.length} folder(s):`, folders);
        }

        // Notify callbacks
        if (onFoldersSelected) {
          onFoldersSelected(folders);
        }

      } catch (error) {
        console.error('âŒ Error processing picker selection:', error);
        const errorMessage = PICKER_UTILS.getErrorMessage('selectionProcessFailed', error.message);
        setError(errorMessage);
        
        if (onError) {
          onError(errorMessage);
        }
      }
    } else if (data.action === window.google.picker.Action.CANCEL) {
      if (PICKER_CONFIG.development.enableConsoleLogging) {
        console.log('ðŸš« Picker cancelled by user');
      }
      setError(null);
    }
  }, [onFoldersSelected, onError]);

  // Create picker instance
  const createPicker = useCallback((accessToken) => {
    if (!PICKER_UTILS.isApiReady()) {
      throw new Error(PICKER_UTILS.getErrorMessage('apiNotAvailable'));
    }

    try {
      const picker = PICKER_BUILDERS.createVTrackPicker(
        accessToken, 
        handlePickerCallback,
        {
          multiSelect,
          title: PICKER_CONFIG.picker.title
        }
      );

      pickerRef.current = picker;
      return picker;
      
    } catch (error) {
      console.error('âŒ Error creating picker:', error);
      throw new Error(PICKER_UTILS.getErrorMessage('pickerCreateFailed', error.message));
    }
  }, [handlePickerCallback, multiSelect]);

  // Main function to open picker
  const openPicker = useCallback(async (isAuthenticated = true) => {
    if (!isAuthenticated) {
      const errorMessage = PICKER_UTILS.getErrorMessage('notAuthenticated');
      setError(errorMessage);
      if (onError) onError(errorMessage);
      return false;
    }

    if (!isApiLoaded) {
      const errorMessage = PICKER_UTILS.getErrorMessage('apiNotLoaded');
      setError(errorMessage);
      if (onError) onError(errorMessage);
      return false;
    }

    setIsLoading(true);
    setError(null);

    try {
      // Get fresh token if needed
      let token = pickerToken;
      if (!token) {
        token = await getPickerToken();
        if (!token) {
          setIsLoading(false);
          return false;
        }
      }

      // Create and show picker
      const picker = createPicker(token);
      
      if (PICKER_CONFIG.development.enableConsoleLogging) {
        console.log('ðŸŽ¯ Opening Google Drive Picker...');
      }
      
      picker.setVisible(true);
      return true;

    } catch (error) {
      console.error('âŒ Error opening picker:', error);
      const errorMessage = error.message || PICKER_UTILS.getErrorMessage('pickerOpenFailed');
      setError(errorMessage);
      
      if (onError) {
        onError(errorMessage);
      }
      
      return false;
    } finally {
      setIsLoading(false);
    }
  }, [isApiLoaded, pickerToken, getPickerToken, createPicker, onError]);

  // Utility functions
  const clearError = useCallback(() => {
    setError(null);
  }, []);

  const clearSelection = useCallback(() => {
    setSelectedFolders([]);
    if (onFoldersSelected) {
      onFoldersSelected([]);
    }
  }, [onFoldersSelected]);

  const refreshToken = useCallback(async () => {
    setPickerToken(null);
    if (tokenTimeoutRef.current) {
      clearTimeout(tokenTimeoutRef.current);
    }
    return await getPickerToken();
  }, [getPickerToken]);

  const retryLastOperation = useCallback(async (isAuthenticated = true) => {
    setError(null);
    return await openPicker(isAuthenticated);
  }, [openPicker]);

  // Get current state summary
  const getState = useCallback(() => {
    return {
      isApiLoaded,
      isLoading,
      hasError: !!error,
      errorMessage: error,
      hasToken: !!pickerToken,
      selectedCount: selectedFolders.length,
      isReady: isApiLoaded && !isLoading && !error
    };
  }, [isApiLoaded, isLoading, error, pickerToken, selectedFolders.length]);

  // Return hook interface
  return {
    // State
    isApiLoaded,
    isLoading,
    error,
    selectedFolders,
    hasToken: !!pickerToken,

    // Actions
    openPicker,
    clearError,
    clearSelection,
    refreshToken,
    retryLastOperation,
    loadPickerApi,

    // Utilities
    getState,
    
    // Status helpers
    isReady: isApiLoaded && !isLoading && !error,
    canOpenPicker: isApiLoaded && !isLoading,
    
    // Config access
    config: PICKER_CONFIG
  };
};

export default useGoogleDrivePicker;