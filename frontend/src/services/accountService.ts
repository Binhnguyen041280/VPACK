import { UserProfile, PaymentTransaction } from '@/types/account';

const API_BASE = 'http://localhost:8080/api';

export class AccountService {
  /**
   * Get user profile information from backend API
   */
  static async getUserProfile(): Promise<UserProfile> {
    try {
      console.log('üì° Fetching user profile from:', `${API_BASE}/user/latest`);
      
      // Use the working endpoint we confirmed
      const response = await fetch(`${API_BASE}/user/latest`, {
        method: 'GET',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        }
      });
      
      if (!response.ok) {
        console.warn('‚ùå API response not ok:', response.status, response.statusText);
        throw new Error(`API responded with ${response.status}`);
      }
      
      const userData = await response.json();

      if (userData.success && userData.user) {
        const profile = {
          name: userData.user.display_name || 'User',
          email: userData.user.gmail_address || '',
          avatar: userData.user.photo_url || '/img/avatars/avatar4.png',
          google_drive_connected: userData.user.gmail_address ? true : false,
          oauth_session_active: true,
          oauth_expires_at: new Date(Date.now() + 87 * 24 * 60 * 60 * 1000).toISOString()
        };
        return profile;
      } else {
        console.warn('‚ùå Invalid user data structure:', userData);
        throw new Error('Invalid user data received');
      }
      
    } catch (error) {
      console.error('‚ùå Failed to get user profile:', error);
      
      // Return fallback profile with no email to avoid confusion
      const fallback = {
        name: 'Guest User',
        email: '', // Empty email - will be handled by UI
        avatar: '/img/avatars/avatar4.png',
        google_drive_connected: false,
        oauth_session_active: false,
        oauth_expires_at: new Date(Date.now() + 87 * 24 * 60 * 60 * 1000).toISOString()
      };
      console.log('üîÑ Returning fallback profile:', fallback);
      return fallback;
    }
  }

  /**
   * Get payment history
   */
  static async getPaymentHistory(): Promise<PaymentTransaction[]> {
    try {
      // This would be replaced with actual payment history endpoint
      // For now, return mock data
      return [
        {
          id: '1',
          package_type: 'personal_1y',
          amount: 20000,
          status: 'completed',
          created_at: '2024-12-15T10:30:00Z',
          order_code: 'VTPAY-2024-001234'
        },
        {
          id: '2', 
          package_type: 'business_1m',
          amount: 5000,
          status: 'completed',
          created_at: '2024-06-10T15:20:00Z',
          order_code: 'VTPAY-2024-000987'
        },
        {
          id: '3',
          package_type: 'trial_24h',
          amount: 2000,
          status: 'completed',
          created_at: '2024-01-05T09:15:00Z',
          order_code: 'VTPAY-2024-000234'
        }
      ];
    } catch (error) {
      console.error('Failed to get payment history:', error);
      throw error;
    }
  }

  /**
   * Get machine information
   */
  static getMachineInfo(): Record<string, any> {
    const userAgent = navigator.userAgent;
    let os = 'Unknown OS';
    let device = 'Unknown Device';

    if (userAgent.includes('Mac')) {
      os = 'macOS';
      device = 'MacBook Pro';
    } else if (userAgent.includes('Windows')) {
      os = 'Windows';
      device = 'PC';
    } else if (userAgent.includes('Linux')) {
      os = 'Linux';
      device = 'Linux PC';
    }

    return {
      os,
      device,
      fingerprint: 'ABC123...', // Would be generated by backend
      lastSeen: new Date().toISOString()
    };
  }

  /**
   * Format date for display
   */
  static formatDate(dateString: string): string {
    return new Date(dateString).toLocaleDateString('vi-VN');
  }

  /**
   * Format relative time (e.g., "2 minutes ago")
   */
  static formatRelativeTime(dateString: string): string {
    const now = new Date();
    const date = new Date(dateString);
    const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

    if (diffInSeconds < 60) {
      return `${diffInSeconds} seconds ago`;
    } else if (diffInSeconds < 3600) {
      const minutes = Math.floor(diffInSeconds / 60);
      return `${minutes} minutes ago`;
    } else if (diffInSeconds < 86400) {
      const hours = Math.floor(diffInSeconds / 3600);
      return `${hours} hours ago`;
    } else {
      const days = Math.floor(diffInSeconds / 86400);
      return `${days} days ago`;
    }
  }

  /**
   * Calculate days remaining until expiry
   */
  static getDaysRemaining(expiryDate: string): number {
    const now = new Date();
    const expiry = new Date(expiryDate);
    const diffInMs = expiry.getTime() - now.getTime();
    const diffInDays = Math.ceil(diffInMs / (1000 * 60 * 60 * 24));
    return Math.max(0, diffInDays);
  }

  /**
   * Get status color based on days remaining
   */
  static getStatusColor(daysRemaining: number): string {
    if (daysRemaining <= 7) return 'red';
    if (daysRemaining <= 30) return 'orange';
    return 'green';
  }
}