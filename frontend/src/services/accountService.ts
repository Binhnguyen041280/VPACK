import { UserProfile, PaymentTransaction } from '@/types/account';
import API_CONFIG from '@/config/api';

const API_BASE = API_CONFIG.BASE_URL;

export class AccountService {
  /**
   * Get user profile information from backend API
   */
  static async getUserProfile(): Promise<UserProfile> {
    try {
      console.log('üì° Fetching user profile from:', `${API_BASE}/user/latest`);
      
      // Use the working endpoint we confirmed
      const response = await fetch(`${API_BASE}/user/latest`, {
        method: 'GET',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        }
      });
      
      if (!response.ok) {
        // Handle authentication errors gracefully
        if (response.status === 401 || response.status === 403) {
          console.info('‚ÑπÔ∏è User not authenticated - returning guest profile');
          return {
            name: 'Guest User',
            email: '',
            avatar: '/img/avatars/avatar4.png',
            google_drive_connected: false,
            oauth_session_active: false,
            oauth_expires_at: new Date(Date.now() + 87 * 24 * 60 * 60 * 1000).toISOString()
          };
        }

        console.warn('‚ùå API response not ok:', response.status, response.statusText);
        throw new Error(`API responded with ${response.status}`);
      }

      const userData = await response.json();

      if (userData.success && userData.user) {
        const profile = {
          name: userData.user.display_name || 'User',
          email: userData.user.gmail_address || '',
          avatar: userData.user.photo_url || '/img/avatars/avatar4.png',
          google_drive_connected: userData.user.gmail_address ? true : false,
          oauth_session_active: true,
          oauth_expires_at: new Date(Date.now() + 87 * 24 * 60 * 60 * 1000).toISOString()
        };
        return profile;
      } else {
        // Handle case where user data exists but structure is invalid
        console.warn('‚ùå Invalid user data structure:', userData);

        // Return guest profile instead of throwing error
        return {
          name: 'Guest User',
          email: '',
          avatar: '/img/avatars/avatar4.png',
          google_drive_connected: false,
          oauth_session_active: false,
          oauth_expires_at: new Date(Date.now() + 87 * 24 * 60 * 60 * 1000).toISOString()
        };
      }
      
    } catch (error) {
      console.error('‚ùå Failed to get user profile:', error);
      
      // Return fallback profile with no email to avoid confusion
      const fallback = {
        name: 'Guest User',
        email: '', // Empty email - will be handled by UI
        avatar: '/img/avatars/avatar4.png',
        google_drive_connected: false,
        oauth_session_active: false,
        oauth_expires_at: new Date(Date.now() + 87 * 24 * 60 * 60 * 1000).toISOString()
      };
      console.log('üîÑ Returning fallback profile:', fallback);
      return fallback;
    }
  }

  /**
   * Get payment history
   */
  static async getPaymentHistory(): Promise<PaymentTransaction[]> {
    try {
      // This would be replaced with actual payment history endpoint
      // For now, return mock data
      return [
        {
          id: '1',
          package_type: 'personal_1y',
          amount: 20000,
          status: 'completed',
          created_at: '2024-12-15T10:30:00Z',
          order_code: 'VTPAY-2024-001234'
        },
        {
          id: '2', 
          package_type: 'business_1m',
          amount: 5000,
          status: 'completed',
          created_at: '2024-06-10T15:20:00Z',
          order_code: 'VTPAY-2024-000987'
        },
        {
          id: '3',
          package_type: 'trial_24h',
          amount: 2000,
          status: 'completed',
          created_at: '2024-01-05T09:15:00Z',
          order_code: 'VTPAY-2024-000234'
        }
      ];
    } catch (error) {
      console.error('Failed to get payment history:', error);
      throw error;
    }
  }

  /**
   * Get machine information
   */
  static getMachineInfo(): Record<string, any> {
    const userAgent = navigator.userAgent;
    let os = 'Unknown OS';
    let device = 'Unknown Device';

    if (userAgent.includes('Mac')) {
      os = 'macOS';
      device = 'MacBook Pro';
    } else if (userAgent.includes('Windows')) {
      os = 'Windows';
      device = 'PC';
    } else if (userAgent.includes('Linux')) {
      os = 'Linux';
      device = 'Linux PC';
    }

    return {
      os,
      device,
      fingerprint: 'ABC123...', // Would be generated by backend
      lastSeen: new Date().toISOString()
    };
  }

  /**
   * Format date for display
   */
  static formatDate(dateString: string): string {
    return new Date(dateString).toLocaleDateString('vi-VN');
  }

  /**
   * Format relative time (e.g., "2 minutes ago")
   */
  static formatRelativeTime(dateString: string): string {
    const now = new Date();
    const date = new Date(dateString);
    const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);

    if (diffInSeconds < 60) {
      return `${diffInSeconds} seconds ago`;
    } else if (diffInSeconds < 3600) {
      const minutes = Math.floor(diffInSeconds / 60);
      return `${minutes} minutes ago`;
    } else if (diffInSeconds < 86400) {
      const hours = Math.floor(diffInSeconds / 3600);
      return `${hours} hours ago`;
    } else {
      const days = Math.floor(diffInSeconds / 86400);
      return `${days} days ago`;
    }
  }

  /**
   * Calculate days remaining until expiry
   */
  static getDaysRemaining(expiryDate: string): number {
    const now = new Date();
    const expiry = new Date(expiryDate);
    const diffInMs = expiry.getTime() - now.getTime();
    const diffInDays = Math.ceil(diffInMs / (1000 * 60 * 60 * 24));
    return Math.max(0, diffInDays);
  }

  /**
   * Get status color based on days remaining
   */
  static getStatusColor(daysRemaining: number): string {
    if (daysRemaining <= 7) return 'red';
    if (daysRemaining <= 30) return 'orange';
    return 'green';
  }

  // ============================================
  // AI USAGE METHODS (for AI QR Recovery feature)
  // ============================================

  /**
   * Get AI configuration
   * TODO: Implement when backend /api/ai/config is ready
   */
  static async getAIConfig(): Promise<any> {
    try {
      const response = await fetch(`${API_BASE}/ai/config`, {
        method: 'GET',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        }
      });

      if (!response.ok) {
        throw new Error(`API responded with ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Failed to get AI config:', error);
      throw error;
    }
  }

  /**
   * Update AI configuration
   * TODO: Implement when backend /api/ai/config POST is ready
   */
  static async updateAIConfig(config: any): Promise<any> {
    try {
      const response = await fetch(`${API_BASE}/ai/config`, {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(config)
      });

      if (!response.ok) {
        throw new Error(`API responded with ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Failed to update AI config:', error);
      throw error;
    }
  }

  /**
   * Test AI API key
   * TODO: Implement when backend /api/ai/test is ready
   */
  static async testAIApiKey(apiKey: string, provider: string): Promise<any> {
    try {
      const response = await fetch(`${API_BASE}/ai/test`, {
        method: 'POST',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ api_key: apiKey, provider })
      });

      if (!response.ok) {
        throw new Error(`API responded with ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Failed to test AI API key:', error);
      throw error;
    }
  }

  /**
   * Get AI usage statistics
   * TODO: Implement when backend /api/ai/stats is ready
   */
  static async getAIStats(): Promise<any> {
    try {
      const response = await fetch(`${API_BASE}/ai/stats`, {
        method: 'GET',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        }
      });

      if (!response.ok) {
        throw new Error(`API responded with ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Failed to get AI stats:', error);
      throw error;
    }
  }

  /**
   * Get AI recovery logs
   * TODO: Implement when backend /api/ai/recovery-logs is ready
   */
  static async getAIRecoveryLogs(limit: number = 50): Promise<any> {
    try {
      const response = await fetch(`${API_BASE}/ai/recovery-logs?limit=${limit}`, {
        method: 'GET',
        credentials: 'include',
        headers: {
          'Content-Type': 'application/json',
        }
      });

      if (!response.ok) {
        throw new Error(`API responded with ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error('Failed to get AI recovery logs:', error);
      throw error;
    }
  }

  /**
   * Format cost in VND
   */
  static formatCostVND(usdCost: number): string {
    const vndCost = usdCost * 25000; // 1 USD ‚âà 25,000 VND
    if (vndCost < 1) {
      return `<1ƒë`;
    }
    return `${vndCost.toLocaleString('vi-VN')}ƒë`;
  }

  /**
   * Format cost in USD
   */
  static formatCostUSD(usdCost: number): string {
    if (usdCost < 0.01) {
      return `$${(usdCost * 1000).toFixed(2)}m`;
    }
    return `$${usdCost.toFixed(4)}`;
  }
}