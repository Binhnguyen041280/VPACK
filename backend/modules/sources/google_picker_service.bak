#!/usr/bin/env python3
"""
Google Picker Service for VTrack Cloud Integration
Handles Google Picker API token generation with security and rate limiting
"""

import os
import json
import time
import hashlib
import logging
from datetime import datetime
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials

# Configure logging
logger = logging.getLogger(__name__)

class PickerRateLimiter:
    """Rate limiting for Picker token requests"""
    
    def __init__(self, max_requests=10, window_minutes=1):
        self.max_requests = max_requests
        self.window_seconds = window_minutes * 60
        self.requests = {}  # {client_ip: [request_times]}
    
    def is_allowed(self, client_ip):
        """Check if request is allowed under rate limit"""
        current_time = time.time()
        
        # Clean old entries
        if client_ip in self.requests:
            self.requests[client_ip] = [
                req_time for req_time in self.requests[client_ip]
                if current_time - req_time < self.window_seconds
            ]
        else:
            self.requests[client_ip] = []
        
        # Check limit
        if len(self.requests[client_ip]) >= self.max_requests:
            return False
        
        # Add current request
        self.requests[client_ip].append(current_time)
        return True
    
    def get_remaining_requests(self, client_ip):
        """Get number of remaining requests for client"""
        current_time = time.time()
        
        if client_ip not in self.requests:
            return self.max_requests
        
        # Clean old entries
        recent_requests = [
            req_time for req_time in self.requests[client_ip]
            if current_time - req_time < self.window_seconds
        ]
        
        return max(0, self.max_requests - len(recent_requests))

class PickerTokenValidator:
    """Validates tokens and scopes for Picker API"""
    
    REQUIRED_PICKER_SCOPES = [
        'https://www.googleapis.com/auth/drive.readonly',
        'https://www.googleapis.com/auth/drive.metadata.readonly'
    ]
    
    @classmethod
    def validate_scopes(cls, token_scopes):
        """Validate that token has required scopes for Picker"""
        if not token_scopes:
            return False, "No scopes found in token"
        
        missing_scopes = [
            scope for scope in cls.REQUIRED_PICKER_SCOPES 
            if scope not in token_scopes
        ]
        
        if missing_scopes:
            return False, f"Missing required scopes: {', '.join(missing_scopes)}"
        
        return True, "All required scopes present"
    
    @classmethod
    def calculate_expires_in(cls, credentials, default_seconds=3600):
        """Calculate token expiry time in seconds"""
        if not credentials.expiry:
            return default_seconds
        
        time_until_expiry = (credentials.expiry - datetime.now()).total_seconds()
        return min(default_seconds, max(300, int(time_until_expiry)))  # Min 5 minutes

class PickerTokenService:
    """Main service for Google Picker token operations"""
    
    def __init__(self, tokens_directory=None):
        self.tokens_dir = tokens_directory or os.path.join(
            os.path.dirname(__file__), 'tokens'
        )
        self.rate_limiter = PickerRateLimiter(max_requests=10, window_minutes=1)
        self.validator = PickerTokenValidator()
    
    def generate_picker_token(self, client_ip, user_email=None):
        """
        Generate access token for Google Picker API
        
        Args:
            client_ip (str): Client IP address for rate limiting
            user_email (str, optional): Specific user email
            
        Returns:
            dict: Token response or error
        """
        try:
            # Rate limiting check
            if not self.rate_limiter.is_allowed(client_ip):
                remaining = self.rate_limiter.get_remaining_requests(client_ip)
                logger.warning(f"âš ï¸ Rate limit exceeded for IP: {client_ip}")
                return {
                    'success': False,
                    'error_type': 'rate_limit_exceeded',
                    'message': 'Rate limit exceeded. Please wait before requesting another token.',
                    'remaining_requests': remaining,
                    'retry_after_seconds': 60
                }, 429
            
            # Find and load credentials
            credential_data, user_info = self._load_credentials(user_email)
            if not credential_data:
                return {
                    'success': False,
                    'error_type': 'no_credentials',
                    'message': 'No stored credentials found. Please authenticate first.'
                }, 401
            
            # Create credentials object
            credentials = self._create_credentials_object(credential_data)
            
            # Handle token refresh if needed
            refresh_result = self._refresh_token_if_needed(credentials, credential_data)
            if not refresh_result['success']:
                return refresh_result, 401
            
            # Validate scopes for Picker
            scope_valid, scope_message = self.validator.validate_scopes(credentials.scopes)
            if not scope_valid:
                logger.error(f"âŒ Scope validation failed: {scope_message}")
                return {
                    'success': False,
                    'error_type': 'insufficient_scopes',
                    'message': scope_message
                }, 403
            
            # Generate token response
            expires_in = self.validator.calculate_expires_in(credentials)
            issued_at = datetime.now().isoformat()
            
            logger.info(f"âœ… Picker token generated for: {user_info.get('email')}")
            logger.info(f"   Token expires in: {expires_in} seconds")
            
            return {
                'success': True,
                'picker_token': credentials.token,
                'expires_in': expires_in,
                'user_email': user_info.get('email'),
                'user_info': user_info,
                'issued_at': issued_at,
                'scopes': list(credentials.scopes) if credentials.scopes else [],
                'message': 'Picker token generated successfully'
            }, 200
            
        except FileNotFoundError as e:
            logger.error(f"âŒ Credentials file not found: {e}")
            return {
                'success': False,
                'error_type': 'credentials_not_found',
                'message': 'Credentials file not found. Please authenticate first.'
            }, 404
            
        except json.JSONDecodeError as e:
            logger.error(f"âŒ Invalid credentials file format: {e}")
            return {
                'success': False,
                'error_type': 'invalid_credentials_format',
                'message': 'Invalid credentials file. Please re-authenticate.'
            }, 500
            
        except Exception as e:
            logger.error(f"âŒ Picker token generation error: {e}")
            return {
                'success': False,
                'error_type': 'server_error',
                'message': f'Failed to generate picker token: {str(e)}'
            }, 500
    
    def _load_credentials(self, user_email=None):
        """Load credentials from storage"""
        if not os.path.exists(self.tokens_dir):
            logger.error("âŒ No tokens directory found")
            return None, None
        
        # Get credential files
        token_files = [
            f for f in os.listdir(self.tokens_dir) 
            if f.startswith('google_drive_') and f.endswith('.json')
        ]
        
        if not token_files:
            logger.error("âŒ No stored credentials found")
            return None, None
        
        # Select appropriate credential file
        token_filepath = self._select_credential_file(token_files, user_email)
        if not token_filepath:
            return None, None
        
        # Load credential data
        with open(token_filepath, 'r') as f:
            credential_data = json.load(f)
        
        user_info = credential_data.get('user_info', {})
        return credential_data, user_info
    
    def _select_credential_file(self, token_files, user_email=None):
        """Select appropriate credential file"""
        if user_email:
            # Find credentials for specific user
            email_hash = hashlib.sha256(user_email.encode()).hexdigest()[:16]
            target_filename = f"google_drive_{email_hash}.json"
            target_filepath = os.path.join(self.tokens_dir, target_filename)
            
            if os.path.exists(target_filepath):
                return target_filepath
            else:
                logger.error(f"âŒ No credentials found for user: {user_email}")
                return None
        else:
            # Use first available credentials
            return os.path.join(self.tokens_dir, token_files[0])
    
    def _create_credentials_object(self, credential_data):
        """Create Google credentials object from stored data"""
        return Credentials(
            token=credential_data['token'],
            refresh_token=credential_data['refresh_token'],
            token_uri=credential_data['token_uri'],
            client_id=credential_data['client_id'],
            client_secret=credential_data['client_secret'],
            scopes=credential_data['scopes']
        )
    
    def _refresh_token_if_needed(self, credentials, credential_data):
        """Refresh token if expired"""
        if not credentials.expired:
            return {'success': True}
        
        if not credentials.refresh_token:
            logger.error("âŒ Token expired and no refresh token available")
            return {
                'success': False,
                'error_type': 'refresh_required',
                'message': 'Token expired and cannot be refreshed. Please re-authenticate.'
            }
        
        try:
            logger.info("ðŸ”„ Refreshing expired token...")
            credentials.refresh(Request())
            
            # Update stored credentials with new token
            self._update_stored_credentials(credential_data, credentials)
            
            logger.info("âœ… Token refreshed and stored successfully")
            return {'success': True}
            
        except Exception as refresh_error:
            logger.error(f"âŒ Token refresh failed: {refresh_error}")
            return {
                'success': False,
                'error_type': 'refresh_failed',
                'message': 'Failed to refresh expired token. Please re-authenticate.'
            }
    
    def _update_stored_credentials(self, credential_data, credentials):
        """Update stored credentials with refreshed token"""
        # Find the original file path
        user_info = credential_data.get('user_info', {})
        user_email = user_info.get('email', 'unknown')
        
        email_hash = hashlib.sha256(user_email.encode()).hexdigest()[:16]
        token_filename = f"google_drive_{email_hash}.json"
        token_filepath = os.path.join(self.tokens_dir, token_filename)
        
        # Update credential data
        credential_data['token'] = credentials.token
        credential_data['expires_at'] = credentials.expiry.isoformat() if credentials.expiry else None
        
        # Write back to file
        with open(token_filepath, 'w') as f:
            json.dump(credential_data, f, indent=2)
    
    def get_rate_limit_status(self, client_ip):
        """Get current rate limit status for client"""
        remaining = self.rate_limiter.get_remaining_requests(client_ip)
        return {
            'remaining_requests': remaining,
            'max_requests': self.rate_limiter.max_requests,
            'window_seconds': self.rate_limiter.window_seconds,
            'is_allowed': remaining > 0
        }

# Global service instance
_picker_service = None

def get_picker_service():
    """Get global PickerTokenService instance"""
    global _picker_service
    if _picker_service is None:
        _picker_service = PickerTokenService()
    return _picker_service

def generate_picker_token_for_request(request):
    """
    Convenience function to generate picker token from Flask request
    
    Args:
        request: Flask request object
        
    Returns:
        tuple: (response_dict, status_code)
    """
    service = get_picker_service()
    client_ip = request.remote_addr
    
    # Get user email from request data
    data = request.get_json() or {}
    user_email = data.get('user_email')
    
    return service.generate_picker_token(client_ip, user_email)