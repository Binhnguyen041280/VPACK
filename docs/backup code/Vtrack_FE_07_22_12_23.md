# üì¶ T·ªïng h·ª£p m√£ ngu·ªìn Vtrack Frontend

**T·ªïng c·ªông:** 0 file `.py`, 40 file `.js`

---

## üìÑ File: `tailwind.config.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/tailwind.config.js`

```javascript
module.exports = {
  content: ["./src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      colors: {
        'blue-custom': '#0066CC',
        'red-custom': '#E32222',
        'gray-custom': '#3F3F3F',
        'yellow-custom': '#FFD700',
      },
    },
  },
  plugins: [],
};
```
## üìÑ File: `postcss.config.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/postcss.config.js`

```javascript
module.exports = {
   plugins: {
     tailwindcss: {},
     autoprefixer: {},
   },
 };
```
## üìÑ File: `reportWebVitals.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/reportWebVitals.js`

```javascript
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

```
## üìÑ File: `Sidebar.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/Sidebar.js`

```javascript
import { Play, Search, Settings, User } from "lucide-react";
import Title from "./Title";

const Sidebar = ({ setActiveMenu, activeMenu }) => (
  <div className="w-64 bg-black text-white min-h-screen p-4 flex flex-col font-montserrat">
    <Title text="V_TRACK UI" />
    <ul>
      {[
        { name: "Ch∆∞∆°ng tr√¨nh", icon: <Play className="mr-2 text-blue-custom" /> },
        { name: "Truy v·∫•n", icon: <Search className="mr-2 text-red-custom" /> },
        { name: "C·∫•u h√¨nh", icon: <Settings className="mr-2 text-gray-custom" /> },
        { name: "T√†i kho·∫£n", icon: <User className="mr-2 text-yellow-custom" /> },
      ].map((item) => (
        <li
          key={item.name}
          className={`flex items-center p-3 hover:bg-gray-800 cursor-pointer transition duration-300 ${
            activeMenu === item.name ? "bg-gray-800" : ""
          }`}
          onClick={() => setActiveMenu(item.name)}
        >
          {item.icon} {item.name}
        </li>
      ))}
    </ul>
  </div>
);

export default Sidebar;
```
## üìÑ File: `index.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/index.js`

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import "@fontsource/montserrat";
import "react-datepicker/dist/react-datepicker.css";

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

```
## üìÑ File: `QueryComponent.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/QueryComponent.js`

```javascript
import { useState, useEffect } from "react";
import SearchModeSelector from "./components/ui/SearchModeSelector";
import FileInputSection from "./components/query/FileInputSection";
import TextInputSection from "./components/query/TextInputSection";
import TimeAndQuerySection from "./components/query/TimeAndQuerySection";
import ResultList from "./components/result/ResultList";
import VideoCutter from "./components/result/VideoCutter"; // Thay CutVideoSection b·∫±ng VideoCutter
import ColumnSelectorModal from "./components/query/ColumnSelectorModal";
import api from "./api";

const QueryComponent = () => {
  const [searchType, setSearchType] = useState("Text");
  const [path, setPath] = useState("");
  const [startDate, setStartDate] = useState(null);
  const [endDate, setEndDate] = useState(null);
  const [results, setResults] = useState([]);
  const [selectedVideos, setSelectedVideos] = useState([]);
  const [cutVideos, setCutVideos] = useState([]);
  const [searchString, setSearchString] = useState("");
  const [defaultDays, setDefaultDays] = useState(30);
  const [fileContent, setFileContent] = useState("");
  const [trackingCodes, setTrackingCodes] = useState([]);
  const [showModal, setShowModal] = useState(false);
  const [headers, setHeaders] = useState([]);
  const [selectedColumn, setSelectedColumn] = useState("tracking_codes");
  const [history, setHistory] = useState({
    Shopee: "M√£ v·∫≠n ƒë∆°n",
    Lazada: "V·∫≠n ƒë∆°n",
    Tiktok: "QR m√£ v·∫≠n ƒë∆°n",
    Custom1: "Custom 1",
    Custom2: "Custom 2",
  });
  const [selectedPlatform, setSelectedPlatform] = useState("Shopee");
  const [shopeeLabel, setShopeeLabel] = useState("Shopee");
  const [lazadaLabel, setLazadaLabel] = useState("Lazada");
  const [tiktokLabel, setTiktokLabel] = useState("Tiktok");
  const [customLabel1, setCustomLabel1] = useState("Custom 1");
  const [customLabel2, setCustomLabel2] = useState("Custom 2");
  const [queryCount, setQueryCount] = useState(0);
  const [trackingCodeCount, setTrackingCodeCount] = useState(0);
  const [foundCount, setFoundCount] = useState(0);
  const [isQuerying, setIsQuerying] = useState(false);
  const [selectedCameras, setSelectedCameras] = useState([]);
  const [availableCameras, setAvailableCameras] = useState([]);
  const [hasQueried, setHasQueried] = useState(false);

  useEffect(() => {
    const savedHistory = localStorage.getItem("trackingColumnHistory");
    if (savedHistory) {
      setHistory(JSON.parse(savedHistory));
    }
    const savedLabels = localStorage.getItem("platformLabels");
    if (savedLabels) {
      const labels = JSON.parse(savedLabels);
      setShopeeLabel(labels.Shopee || "Shopee");
      setLazadaLabel(labels.Lazada || "Lazada");
      setTiktokLabel(labels.Tiktok || "Tiktok");
      setCustomLabel1(labels.Custom1 || "Custom 1");
      setCustomLabel2(labels.Custom2 || "Custom 2");
    }

    const isConfigSet = localStorage.getItem("configSet");
    if (isConfigSet) {
      const fetchCameras = async () => {
        try {
          const response = await api.get("/get-cameras");
          setAvailableCameras(response.data.cameras || []);
          const savedCameras = localStorage.getItem("selectedCameras");
          if (savedCameras) {
            setSelectedCameras(JSON.parse(savedCameras));
          }
        } catch (error) {
          console.error("Error fetching cameras:", error);
        }
      };
      fetchCameras();
    }
  }, []);

  useEffect(() => {
    let count = 0;
    if (searchString) {
      const lines = searchString.split("\n");
      count = lines.filter(line => line.trim() !== "" && line.split('. ')[1]?.trim()).length;
    }
    setTrackingCodeCount(count);
  }, [searchString]);

  const debounce = (func, delay) => {
    let timeoutId;
    return (...args) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => func(...args), delay);
    };
  };

  const handleQuery = async () => {
    setIsQuerying(true);
    setHasQueried(true);
    try {
      const queryData = {
        search_string: searchString,
        default_days: defaultDays,
        from_time: startDate ? startDate.toISOString() : null,
        to_time: endDate ? endDate.toISOString() : null,
        selected_cameras: selectedCameras,
      };

      const response = await api.post("/query", queryData);
      const events = response.data.events || [];

      setResults(events);
      setSelectedVideos(events.map(event => event.event_id));
      setQueryCount(prev => prev + 1);
      setFoundCount(events.length);
    } catch (error) {
      console.error("Error in query:", error);
    } finally {
      setIsQuerying(false);
    }
  };

  const debouncedHandleQuery = debounce(handleQuery, 1000);

  const handleCameraSelection = (camera) => {
    const updatedCameras = selectedCameras.includes(camera)
      ? selectedCameras.filter((c) => c !== camera)
      : [...selectedCameras, camera];
    setSelectedCameras(updatedCameras);
    localStorage.setItem("selectedCameras", JSON.stringify(updatedCameras));
  };

  return (
    <div className="p-6 flex gap-6 w-screen h-screen">
      <div className="w-[26.67%] bg-gray-800 p-6 rounded-lg flex flex-col">
        <h1 className="text-3xl font-bold mb-4">Truy v·∫•n</h1>
        <SearchModeSelector searchType={searchType} setSearchType={setSearchType} />
        {searchType === "File" && (
          <FileInputSection
            path={path}
            setPath={setPath}
            fileContent={fileContent}
            setFileContent={setFileContent}
            setShowModal={setShowModal}
            setHeaders={setHeaders}
          />
        )}
        <TextInputSection
          searchString={searchString}
          setSearchString={setSearchString}
          searchType={searchType}
        />
        <div className="mb-4">
          <label className="block mb-1">Truy v·∫•n t·∫°i camera:</label>
          <div className="max-h-24 overflow-y-auto">
            {availableCameras.map((camera) => (
              <label key={camera} className="flex items-center mb-2">
                <input
                  type="checkbox"
                  checked={selectedCameras.includes(camera)}
                  onChange={() => handleCameraSelection(camera)}
                  className="mr-2"
                />
                {camera}
              </label>
            ))}
          </div>
        </div>
        <TimeAndQuerySection
          startDate={startDate}
          setStartDate={setStartDate}
          endDate={endDate}
          setEndDate={setEndDate}
          defaultDays={defaultDays}
          setDefaultDays={setDefaultDays}
          searchString={searchString}
          searchType={searchType}
          fileContent={fileContent}
          results={results}
          setResults={setResults}
          setSelectedVideos={setSelectedVideos}
          setQueryCount={setQueryCount}
          setFoundCount={setFoundCount}
          foundCount={foundCount}
          onQuery={debouncedHandleQuery}
          isQuerying={isQuerying}
        />
      </div>
      <div className="w-[53.33%] bg-gray-800 p-6 rounded-lg flex flex-col">
        <div className="flex items-center mb-4">
          <h1 className="text-3xl font-bold mr-4">K·∫øt qu·∫£</h1>
          {(trackingCodeCount > 0 || foundCount > 0) && (
            <span className="text-lg text-gray-300">
              (Truy v·∫•n {trackingCodeCount}/ T√¨m ƒë∆∞·ª£c {foundCount})
            </span>
          )}
        </div>
        <ResultList
          results={results}
          selectedVideos={selectedVideos}
          setSelectedVideos={setSelectedVideos}
          hasQueried={hasQueried}
        />
        <VideoCutter
          results={results}
          selectedVideos={selectedVideos}
          setResults={setResults}
          setSelectedVideos={setSelectedVideos}
        /> {/* Thay CutVideoSection b·∫±ng VideoCutter */}
      </div>
      <ColumnSelectorModal
        showModal={showModal}
        setShowModal={setShowModal}
        headers={headers}
        selectedColumn={selectedColumn}
        setSelectedColumn={setSelectedColumn}
        history={history}
        setHistory={setHistory}
        selectedPlatform={selectedPlatform}
        setSelectedPlatform={setSelectedPlatform}
        shopeeLabel={shopeeLabel}
        setShopeeLabel={setShopeeLabel}
        lazadaLabel={lazadaLabel}
        setLazadaLabel={setLazadaLabel}
        tiktokLabel={tiktokLabel}
        setTiktokLabel={setTiktokLabel}
        customLabel1={customLabel1}
        setCustomLabel1={setCustomLabel1}
        customLabel2={customLabel2}
        setCustomLabel2={setCustomLabel2}
        path={path}
        fileContent={fileContent}
        setSearchString={setSearchString}
        setSearchType={setSearchType}
      />
    </div>
  );
};

export default QueryComponent;
```
## üìÑ File: `Title.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/Title.js`

```javascript
const Title = ({ text }) => {
   return <h2 className="text-xl font-bold text-center mb-6 tracking-widest">{text}</h2>;
 };
 
 export default Title;
```
## üìÑ File: `Account.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/Account.js`

```javascript
const Account = () => {
   return (
     <div className="p-6">
       <h1 className="text-3xl font-bold">T√†i kho·∫£n</h1>
       <p>ƒê√¢y l√† trang T√†i kho·∫£n. N·ªôi dung s·∫Ω ƒë∆∞·ª£c th√™m sau.</p>
     </div>
   );
 };
 
 export default Account;
```
## üìÑ File: `App.test.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/App.test.js`

```javascript
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

```
## üìÑ File: `VtrackConfig.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/VtrackConfig.js`

```javascript
import React from "react";
import useVtrackConfig from "./hooks/useVtrackConfig";
import GeneralInfoForm from "./components/config/GeneralInfoForm";
import ConfigForm from "./components/config/ConfigForm";
import CameraDialog from "./components/config/CameraDialog";
import ProcessingRegionForm from "./components/config/ProcessingRegionForm";

const VtrackConfig = () => {
  const {
    fromTime,
    setFromTime,
    toTime,
    setToTime,
    country,
    setCountry,
    timezone,
    setTimezone,
    brandName,
    setBrandName,
    inputPath,
    setInputPath,
    outputPath,
    setOutputPath,
    workingDays,
    setWorkingDays,
    defaultDays,
    setDefaultDays,
    minPackingTime,
    setMinPackingTime,
    maxPackingTime,
    setMaxPackingTime,
    frameRate,
    setFrameRate,
    frameInterval,
    setFrameInterval,
    videoBuffer,
    setVideoBuffer,
    cameras,
    setCameras,
    selectedCameras,
    setSelectedCameras,
    showCameraDialog,
    setShowCameraDialog,
    error,
    setError,
    handleCountryChange,
    handleFromTimeChange,
    handleToTimeChange,
    handleWorkingDayChange,
    handleOpenExplorer,
    handleSaveGeneralInfo,
    handleSaveConfig,
    handleShowCameraDialog,
    handleCameraSelection,
    runDefaultOnStart,
    setRunDefaultOnStart,
  } = useVtrackConfig();

  const [configFormCameras, setConfigFormCameras] = React.useState([]);
  const [configFormSelectedCameras, setConfigFormSelectedCameras] = React.useState([]);
  const [activeVideoSource, setActiveVideoSource] = React.useState(null);

  const [videoPath, setVideoPath] = React.useState("");
  const [qrSize, setQrSize] = React.useState("");
  
  const handleAnalyzeRegions = () => {
    console.log("Ph√¢n t√≠ch v√πng:", videoPath, qrSize);
  };

  // ‚úÖ FIX: Helper function ƒë·ªÉ get correct input path based on source type
  const getInputPathForSource = (source) => {
    if (!source) return "";
    
    let resultPath = "";
    
    switch (source.source_type) {
      case 'nvr':
        // NVR: Use working directory for downloaded videos
        resultPath = `/Users/annhu/vtrack_app/V_Track/nvr_downloads/${source.name}`;
        console.log(`üîó NVR Path Mapping: ${source.path} ‚Üí ${resultPath}`);
        break;
      case 'local':
        // Local: Use actual file system path
        resultPath = source.path;
        console.log(`üìÅ Local Path Mapping: ${source.path} ‚Üí ${resultPath}`);
        break;
      case 'cloud':
        // Cloud: Use sync directory (future)
        resultPath = `/Users/annhu/vtrack_app/V_Track/cloud_sync/${source.name}`;
        console.log(`‚òÅÔ∏è Cloud Path Mapping: ${source.path} ‚Üí ${resultPath}`);
        break;
      default:
        resultPath = source.path;
        console.log(`‚ùì Unknown Path Mapping: ${source.path} ‚Üí ${resultPath}`);
    }
    
    return resultPath;
  };

  // ‚úÖ FIX: Auto sync inputPath - USE HELPER FUNCTION
  React.useEffect(() => {
    console.log("=== INPUT PATH SYNC DEBUG ===");
    console.log("activeVideoSource changed:", activeVideoSource);
    
    if (activeVideoSource) {
      const correctPath = getInputPathForSource(activeVideoSource);
      console.log(`${activeVideoSource.source_type.toUpperCase()} source detected - setting path:`, correctPath);
      setInputPath(correctPath);
    } else {
      console.log("activeVideoSource is null");
    }
  }, [activeVideoSource, setInputPath]);

  React.useEffect(() => {
    if (configFormCameras && configFormCameras.length > 0) {
      const cameraObjects = configFormCameras.map(name => ({
        name: name,
        path: name
      }));
      setCameras(cameraObjects);
      console.log("Synced cameras to hook state:", cameraObjects);
    }
  }, [configFormCameras, setCameras]);

  React.useEffect(() => {
    if (configFormSelectedCameras && configFormSelectedCameras.length > 0) {
      setSelectedCameras(configFormSelectedCameras);
      console.log("Synced selectedCameras to hook state:", configFormSelectedCameras);
    }
  }, [configFormSelectedCameras, setSelectedCameras]);

  const handleCamerasUpdate = React.useCallback((sourceCameras, selectedCameras, activeSource) => {
    console.log("=== CAMERAS UPDATE BACKUP DEBUG ===");
    console.log("sourceCameras:", sourceCameras);
    console.log("selectedCameras:", selectedCameras);
    console.log("activeSource:", activeSource);
    
    // Backup logic - ch·ªâ khi direct setters kh√¥ng work
    if (!activeVideoSource && activeSource) {
      console.log("Backup: Setting activeVideoSource:", activeSource);
      setActiveVideoSource(activeSource);
      setInputPath(activeSource.path);
    }
  }, [activeVideoSource, setInputPath]);

  // ‚úÖ NEW: Smart camera dialog logic - skip if cameras already selected
  const handleShowCameraDialogCustom = () => {
    console.log("=== SMART CAMERA DIALOG LOGIC ===");
    console.log("configFormSelectedCameras:", configFormSelectedCameras);
    console.log("configFormCameras:", configFormCameras);
    
    // ‚úÖ Check if cameras are already selected
    if (configFormSelectedCameras && configFormSelectedCameras.length > 0) {
      console.log("‚úÖ Cameras already selected, skipping dialog and saving directly");
      console.log("Selected cameras:", configFormSelectedCameras);
      
      // ‚úÖ Sync cameras to dialog state for save process
      const cameraObjects = configFormCameras.map(name => ({
        name: name,
        path: name
      }));
      setCameras(cameraObjects);
      setSelectedCameras(configFormSelectedCameras);
      
      // ‚úÖ Save directly without showing dialog
      handleSaveConfigCustom();
      return;
    }
    
    // ‚úÖ No cameras selected, show dialog for user to select
    console.log("‚ö†Ô∏è No cameras selected, showing dialog for user selection");
    
    if (!configFormCameras || configFormCameras.length === 0) {
      alert("Kh√¥ng t√¨m th·∫•y camera n√†o. Vui l√≤ng:\n1. Ki·ªÉm tra video source ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh\n2. ƒê·∫£m b·∫£o c√≥ camera folders trong source");
      return;
    }
    
    const cameraObjects = configFormCameras.map(name => ({
      name: name,
      path: name
    }));
    setCameras(cameraObjects);
    setSelectedCameras([]); // Start with empty selection for user to choose
    setShowCameraDialog(true);
  };

  // ‚úÖ FIX: Custom handleSaveConfig - USE HELPER FUNCTION  
  const handleSaveConfigCustom = () => {
    console.log("=== DEBUG SAVE CONFIG SIMPLIFIED ===");
    console.log("activeVideoSource:", activeVideoSource);
    console.log("configFormCameras:", configFormCameras);
    console.log("configFormSelectedCameras:", configFormSelectedCameras);
    console.log("selectedCameras from dialog:", selectedCameras);
    console.log("inputPath BEFORE:", inputPath);
    
    // ‚úÖ FIX: Use the correct camera selection (prioritize dialog selection, fallback to pre-selected)
    const camerasToUse = selectedCameras && selectedCameras.length > 0 
      ? selectedCameras 
      : configFormSelectedCameras;
      
    console.log("Final cameras to use:", camerasToUse);
    
    if (!camerasToUse || camerasToUse.length === 0) {
      alert("Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt camera.\n\nCameras found: " + configFormCameras.join(", "));
      return;
    }

    // ‚úÖ Get correct path using helper function
    let pathToUse = inputPath;
    
    if (activeVideoSource) {
      pathToUse = getInputPathForSource(activeVideoSource);
      console.log(`Setting correct path for ${activeVideoSource.source_type}:`, pathToUse);
      setInputPath(pathToUse);
    } else if (!pathToUse || pathToUse.trim() === "") {
      alert("Kh√¥ng t√¨m th·∫•y video source.\n\nVui l√≤ng:\n1. Refresh page\n2. C·∫•u h√¨nh l·∫°i video source\n3. Th·ª≠ l·∫°i");
      return;
    }

    console.log("Final pathToUse:", pathToUse);

    // ‚úÖ Validation: Ensure no URL in file system path
    if (pathToUse.includes('://') || pathToUse.includes('localhost:')) {
      alert("‚ùå Invalid input path detected!\n\nURL cannot be used as file system path.\nPath: " + pathToUse);
      return;
    }

    setShowCameraDialog(false);
    console.log("Calling handleSaveConfig...");
    handleSaveConfig();
  };

  const countries = [
    "Vi·ªát Nam", "Nh·∫≠t B·∫£n", "H√†n Qu·ªëc", "Th√°i Lan", "Singapore",
    "M·ªπ", "Anh", "Ph√°p", "ƒê·ª©c", "√öc"
  ];

  return (
    <div className="p-6 flex gap-6 w-[100%]">
      <GeneralInfoForm
        country={country}
        setCountry={setCountry}
        timezone={timezone}
        setTimezone={setTimezone}
        brandName={brandName}
        setBrandName={setBrandName}
        workingDays={workingDays}
        setWorkingDays={setWorkingDays}
        fromTime={fromTime}
        setFromTime={setFromTime}
        toTime={toTime}
        setToTime={setToTime}
        handleCountryChange={handleCountryChange}
        handleFromTimeChange={handleFromTimeChange}
        handleToTimeChange={handleToTimeChange}
        handleWorkingDayChange={handleWorkingDayChange}
        handleSaveGeneralInfo={handleSaveGeneralInfo}
        countries={countries}
      />
      <ConfigForm
        inputPath={inputPath}
        setInputPath={setInputPath}
        outputPath={outputPath}
        setOutputPath={setOutputPath}
        defaultDays={defaultDays}
        setDefaultDays={setDefaultDays}
        minPackingTime={minPackingTime}
        setMinPackingTime={setMinPackingTime}
        maxPackingTime={maxPackingTime}
        setMaxPackingTime={setMaxPackingTime}
        frameRate={frameRate}
        setFrameRate={setFrameRate}
        frameInterval={frameInterval}
        setFrameInterval={setFrameInterval}
        videoBuffer={videoBuffer}
        setVideoBuffer={setVideoBuffer}
        error={error}
        handleOpenExplorer={handleOpenExplorer}
        handleShowCameraDialog={handleShowCameraDialogCustom}
        runDefaultOnStart={runDefaultOnStart}
        setRunDefaultOnStart={setRunDefaultOnStart}
        onCamerasUpdate={handleCamerasUpdate}
        setActiveVideoSource={setActiveVideoSource}
        setConfigFormCameras={setConfigFormCameras}
        setConfigFormSelectedCameras={setConfigFormSelectedCameras}
      />
      <ProcessingRegionForm
        videoPath={videoPath}
        setVideoPath={setVideoPath}
        qrSize={qrSize}
        setQrSize={setQrSize}
        handleAnalyzeRegions={handleAnalyzeRegions}
      />
      <CameraDialog
        showCameraDialog={showCameraDialog}
        setShowCameraDialog={setShowCameraDialog}
        cameras={cameras}
        selectedCameras={selectedCameras}
        handleCameraSelection={handleCameraSelection}
        handleSaveConfig={handleSaveConfigCustom}
      />
    </div>
  );
};

export default VtrackConfig;
```
## üìÑ File: `Dashboard.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/Dashboard.js`

```javascript
import Sidebar from "./Sidebar";
import VtrackConfig from "./VtrackConfig";
import QueryComponent from "./QueryComponent";
import Account from "./Account";
import ProgramTab from "./components/program/ProgramTab";
import useProgramLogic from "./hooks/useProgramLogic";

const Dashboard = ({ setActiveMenu, activeMenu }) => {
  const {
    runningCard,
    fileList,
    customPath,
    showConfirmButton,
    firstRunCompleted,
    handleRunStop,
    handleConfirmRun,
    isRunning,
    setCustomPath,
  } = useProgramLogic();

  return (
    <div className="flex min-h-screen bg-gray-900 text-white font-montserrat">
      <Sidebar setActiveMenu={setActiveMenu} activeMenu={activeMenu} />
      <div className="flex-1 p-6 w-full">
        {activeMenu === "Ch∆∞∆°ng tr√¨nh" ? (
          <ProgramTab
            runningCard={runningCard}
            fileList={fileList}
            customPath={customPath}
            showConfirmButton={showConfirmButton}
            firstRunCompleted={firstRunCompleted}
            handleRunStop={handleRunStop}
            handleConfirmRun={handleConfirmRun}
            isRunning={isRunning}
            setCustomPath={setCustomPath}
          />
        ) : activeMenu === "C·∫•u h√¨nh" ? (
          <VtrackConfig />
        ) : activeMenu === "Truy v·∫•n" ? (
          <QueryComponent />
        ) : activeMenu === "T√†i kho·∫£n" ? (
          <Account />
        ) : (
          <div>
            <h1 className="text-3xl font-bold">ƒêang ph√°t tri·ªÉn: {activeMenu}</h1>
            <p>N·ªôi dung cho {activeMenu} s·∫Ω ƒë∆∞·ª£c th√™m sau.</p>
          </div>
        )}
      </div>
    </div>
  );
};

export default Dashboard;
```
## üìÑ File: `api.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/api.js`

```javascript
import axios from "axios";

const api = axios.create({
  baseURL: "http://localhost:8080",
});

export const getConfig = () => api.get("/config");
export const updateConfig = (configData) => api.post("/config", configData);
export const runQuery = (queryData) => api.post("/query", queryData);
export const runProgram = (programData) => api.post("/program", programData);
export const confirmRun = (confirmData) => api.post("/confirm-run", confirmData);
export const getCameras = () => api.get("/get-cameras");
export const cutVideos = (cutData) => api.post("/cut-videos", cutData);
export const analyzeRegions = (data) => api.post("/analyze-regions", data);
export const getFrames = (data) => api.post("/get-frames", data);
export const submitRois = (data) => api.post("/submit-rois", data);
export const sendHandDetection = (data) => api.post("/api/hand-detection", data);
export const getRoiFrame = () => api.get("/get-roi-frame");
export const getFinalRoiFrame = (cameraId, timestamp) => api.get(`/get-final-roi-frame?camera_id=${cameraId}&timestamp=${timestamp}`);

// Video Sources APIs
export const getSources = () => api.get("/get-sources");
export const addSources = (sourcesData) => api.post("/save-sources", sourcesData);
export const testSourceConnection = (sourceData) => api.post("/test-source", sourceData);
export const updateSource = (id, sourceData) => api.put(`/update-source/${id}`, sourceData);
export const deleteSource = (id) => api.delete(`/delete-source/${id}`);
export const toggleSource = (id, active) => api.post(`/toggle-source/${id}`, { active });

// NEW: Camera Detection APIs
export const detectCameras = (pathData) => api.post("/detect-cameras", pathData);
export const updateSourceCameras = (cameraData) => api.post("/update-source-cameras", cameraData);

export default api;
```
## üìÑ File: `setupTests.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/setupTests.js`

```javascript
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

```
## üìÑ File: `App.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/App.js`

```javascript
import "@fontsource/montserrat";
import { useState } from "react";
import Dashboard from "./Dashboard";

function App() {
  const [activeMenu, setActiveMenu] = useState("Ch∆∞∆°ng tr√¨nh");
  return (
    <div className="flex min-h-screen bg-gray-900 text-white font-montserrat">
      <Dashboard setActiveMenu={setActiveMenu} activeMenu={activeMenu} />
    </div>
  );
}

export default App;
```
## üìÑ File: `SearchModeSelector.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/ui/SearchModeSelector.js`

```javascript
const SearchModeSelector = ({ searchType, setSearchType }) => {
  return (
    <div className="mb-4">
      <label className="block mb-1">Lo·∫°i t√¨m ki·∫øm:</label>
      <div className="flex gap-4">
        <label className="flex items-center">
          <input
            type="radio"
            name="searchType"
            value="File"
            className="mr-1"
            checked={searchType === "File"}
            onChange={() => setSearchType("File")}
          />
          File
        </label>
        <label className="flex items-center">
          <input
            type="radio"
            name="searchType"
            value="Text"
            className="mr-1"
            checked={searchType === "Text"}
            onChange={() => setSearchType("Text")}
          />
          Text
        </label>
      </div>
    </div>
  );
};

export default SearchModeSelector;
```
## üìÑ File: `Button.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/ui/Button.js`

```javascript
const Button = ({ text }) => {
   return (
     <button className="bg-red-600 text-white font-bold py-2 px-4 rounded mt-4">
       {text}
     </button>
   );
 };
 
 export default Button;
```
## üìÑ File: `Card.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/ui/Card.js`

```javascript
import { useState } from "react";

const Card = ({ title, description, isRunning, onRunStop, onPathChange, isLocked }) => {
  const [path, setPath] = useState("");

  const handleOpenExplorer = () => {
    const input = document.createElement("input");
    input.type = "file";
    input.onchange = (e) => {
      const selectedPath = e.target.files[0]?.name || "";
      setPath(selectedPath);
      if (onPathChange) {
        onPathChange(selectedPath);
      }
    };
    input.click();
  };

  return (
    <div className="bg-gray-800 p-6 rounded-lg flex flex-col items-center h-full">
      <h3 className="text-lg font-bold mb-2">{title}</h3>
      <p className="mb-4 text-center flex-1">{description}</p>
      <div className="mt-auto w-full flex flex-col items-center">
        {title === "Ch·ªâ ƒë·ªãnh" && (
          <div className="mb-4 w-full">
            <div className="relative w-full">
              <input
                type="text"
                value={path}
                onChange={(e) => {
                  setPath(e.target.value);
                  if (onPathChange) {
                    onPathChange(e.target.value);
                  }
                }}
                placeholder="Nh·∫≠p ƒë∆∞·ªùng d·∫´n file..."
                className="w-full p-2 rounded bg-gray-700 text-white"
              />
              <button
                type="button"
                onClick={handleOpenExplorer}
                className="absolute right-2 top-1/2 transform -translate-y-1/2 text-white"
              >
                ...
              </button>
            </div>
          </div>
        )}
        {isLocked || (title === "L·∫ßn ƒë·∫ßu" && isRunning) ? (
          <button
            className="w-1/2 py-2 px-4 rounded font-bold text-white bg-gray-500"
            disabled
          >
            LOCKED
          </button>
        ) : (
          <button
            className={`w-1/2 py-2 px-4 rounded font-bold text-white ${
              isRunning && title !== "L·∫ßn ƒë·∫ßu" ? "bg-[#E82127]" : "bg-[#00D4FF]"
            }`}
            onClick={onRunStop}
            disabled={title === "Ch·ªâ ƒë·ªãnh" && !path && !isRunning}
          >
            {(isRunning && title !== "L·∫ßn ƒë·∫ßu") ? "STOP" : "RUN"}
          </button>
        )}
      </div>
    </div>
  );
};

export default Card;
```
## üìÑ File: `ResultList.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/result/ResultList.js`

```javascript
import React from "react";

const ResultList = ({ results, selectedVideos, setSelectedVideos, hasQueried }) => {
  const handleSelectVideo = (eventId) => {
    if (selectedVideos.includes(eventId)) {
      setSelectedVideos(selectedVideos.filter((id) => id !== eventId));
    } else {
      setSelectedVideos([...selectedVideos, eventId]);
    }
  };

  React.useEffect(() => {
    if (results.length > 0) {
      const newSelectedVideos = results.map(event => event.event_id);
      setSelectedVideos(newSelectedVideos);
    }
  }, [results]);

  return (
    <div className="flex-1 mb-4 bg-gray-700 rounded p-2 overflow-y-auto">
      {hasQueried ? (
        results.length > 0 ? (
          results.map((event, index) => (
            <label key={event.event_id} className="flex items-center mb-2">
              <input
                type="checkbox"
                className="mr-2"
                checked={selectedVideos.includes(event.event_id)}
                onChange={() => handleSelectVideo(event.event_id)}
              />
              {`${index + 1}. ${event.video_file}`}
            </label>
          ))
        ) : (
          <p>Kh√¥ng c√≥ k·∫øt qu·∫£</p>
        )
      ) : (
        <p>Vui l√≤ng th·ª±c hi·ªán truy v·∫•n</p>
      )}
    </div>
  );
};

export default ResultList;

```
## üìÑ File: `CutVideoSection.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/result/CutVideoSection.js`

```javascript
import api from "../../api"; // Th√™m import api ƒë·ªÉ g·ªçi /cut-videos

const CutVideoSection = ({ results, selectedVideos, setResults, setSelectedVideos, cutVideos, setCutVideos }) => {
  const handleCutVideos = async () => {
    if (selectedVideos.length === 0) {
      alert("Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt s·ª± ki·ªán ƒë·ªÉ c·∫Øt video.");
      return;
    }
    const videosToCut = results.filter((event) => selectedVideos.includes(event.event_id));
    try {
      const cutData = {
        selected_events: videosToCut,
      };
      const response = await api.post("/cut-videos", cutData); // G·ªçi API /cut-videos
      const cutFiles = response.data.cut_files || []; // L·∫•y danh s√°ch file t·ª´ ph·∫£n h·ªìi
      setCutVideos(prev => [...prev, ...cutFiles]); // T·ªëi ∆∞u v·ªõi prev
      setResults(results.filter((event) => !selectedVideos.includes(event.event_id)));
      setSelectedVideos([]);
    } catch (error) {
      console.error("Error cutting videos:", error);
      alert("C√≥ l·ªói x·∫£y ra khi c·∫Øt video. Vui l√≤ng th·ª≠ l·∫°i.");
    }
  };

  const handleRefresh = () => {
    setResults([]);
    setSelectedVideos([]);
    setCutVideos([]); // X√≥a danh s√°ch video ƒë√£ c·∫Øt
  };

  return (
    <>
      <div className="flex gap-4 mb-4">
        <button
          className="w-1/2 py-2 bg-red-600 text-white font-bold rounded"
          onClick={handleCutVideos}
        >
          C·∫Øt Video
        </button>
        <button
          className="w-1/2 py-2 px-4 rounded font-bold text-white bg-[#00D4FF]"
          onClick={handleRefresh}
        >
          Refresh
        </button>
      </div>
      <div className="flex-1 bg-gray-700 rounded p-2 overflow-y-auto">
        {cutVideos.map((video, index) => (
          <label key={index} className="flex items-center mb-2">
            <input type="checkbox" className="mr-2" />
            {`${index + 1}. ${video}`}
          </label>
        ))}
      </div>
    </>
  );
};

export default CutVideoSection;
```
## üìÑ File: `VideoCutter.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/result/VideoCutter.js`

```javascript
import { useState } from "react";
import api from "../../api"; // ƒêi·ªÅu ch·ªânh ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi t·ª´ th∆∞ m·ª•c result

const VideoCutter = ({ results, selectedVideos, setResults, setSelectedVideos }) => {
  const [cutVideos, setCutVideos] = useState([]);
  const [selectedCutVideo, setSelectedCutVideo] = useState(null); // Th√™m tr·∫°ng th√°i ƒë·ªÉ l∆∞u video ƒë√£ c·∫Øt ƒë∆∞·ª£c ch·ªçn

  // H√†m x·ª≠ l√Ω y√™u c·∫ßu c·∫Øt video
  const handleCutVideos = async () => {
    if (selectedVideos.length === 0) {
      alert("Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt s·ª± ki·ªán ƒë·ªÉ c·∫Øt video.");
      return;
    }
    try {
      const selectedEvents = results.filter(event => selectedVideos.includes(event.event_id));
      const cutData = {
        selected_events: selectedEvents,
        // tracking_codes_filter s·∫Ω ƒë∆∞·ª£c th√™m sau n·∫øu c·∫ßn t·ª´ QueryComponent
      };

      const response = await api.post("/cut-videos", cutData); // G·ªçi API c·∫Øt video
      const cutFiles = response.data.cut_files || [];

      setCutVideos(prev => [...prev, ...cutFiles]); // C·∫≠p nh·∫≠t danh s√°ch video ƒë√£ c·∫Øt
      setResults(prev => prev.filter(event => !selectedVideos.includes(event.event_id))); // X√≥a s·ª± ki·ªán ƒë√£ c·∫Øt
      setSelectedVideos([]); // Reset danh s√°ch ch·ªçn
    } catch (error) {
      console.error("Error cutting videos:", error);
      alert("C√≥ l·ªói x·∫£y ra khi c·∫Øt video. Vui l√≤ng th·ª≠ l·∫°i.");
    }
  };

  const handleRefresh = () => {
    setResults([]);
    setSelectedVideos([]);
    setCutVideos([]);
    setSelectedCutVideo(null); // Reset video ƒë√£ ch·ªçn khi refresh
  };

  // H√†m x·ª≠ l√Ω khi nh·∫•n n√∫t "Play Video"
  const handlePlayVideo = () => {
    if (!selectedCutVideo) {
      alert("Vui l√≤ng ch·ªçn m·ªôt video ƒë·ªÉ ph√°t");
      return;
    }
    alert(`ƒêang ph√°t video "${selectedCutVideo}" ƒë∆∞·ª£c ch·ªçn`);
  };

  return (
    <>
      <div className="flex gap-4 mb-4">
        <button
          className="w-1/3 py-2 bg-red-600 text-white font-bold rounded"
          onClick={handleCutVideos}
        >
          C·∫Øt Video
        </button>
        <button
          className="w-1/3 py-2 px-4 rounded font-bold text-white bg-[#00D4FF]"
          onClick={handleRefresh}
        >
          Refresh
        </button>
        <button
          className="w-1/3 py-2 px-4 rounded font-bold text-white bg-green-600"
          onClick={handlePlayVideo}
        >
          Play Video
        </button>
      </div>
      <div className="flex-1 bg-gray-700 rounded p-2 overflow-y-auto">
        {cutVideos.map((video, index) => (
          <label
            key={index}
            className="flex items-center mb-2 cursor-pointer hover:bg-gray-600 transition duration-300"
            onClick={() => setSelectedCutVideo(video)}
          >
            <input
              type="radio"
              name="cutVideo"
              className="mr-2"
              checked={selectedCutVideo === video}
              onChange={() => setSelectedCutVideo(video)}
            />
            <span className="flex-1 truncate">{`${index + 1}. ${video}`}</span>
          </label>
        ))}
      </div>
    </>
  );
};

export default VideoCutter;
```
## üìÑ File: `CloudConfigurationForm.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/CloudConfigurationForm.js`

```javascript
// components/config/CloudConfigurationForm.js - Google Drive Configuration Form
import React, { useState, useEffect } from 'react';
import GoogleDriveAuthButton from './GoogleDriveAuthButton';
import CloudSyncSettings from './CloudSyncSettings';

const CloudConfigurationForm = ({ config, setConfig, onAuthenticate }) => {
  // Authentication state
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [authLoading, setAuthLoading] = useState(false);
  const [authError, setAuthError] = useState(null);

  // Picker selection state
  const [pickerSelectedFolders, setPickerSelectedFolders] = useState([]);
  const [pickerLoading, setPickerLoading] = useState(false);

  // Sync settings state
  const [syncSettings, setSyncSettings] = useState({
    interval_minutes: 15,
    auto_sync_enabled: true,
    sync_only_new: true,
    skip_duplicates: true,
    organize_by_date: true,
    backup_metadata: true
  });

  // Configuration status
  const [configurationValid, setConfigurationValid] = useState(false);

  // Initialize from existing config
  useEffect(() => {
    if (config) {
      if (config.credentials && config.user_email) {
        setIsAuthenticated(true);
      }
      
      if (config.selected_folders) {
        setPickerSelectedFolders(config.selected_folders);
      }
      
      if (config.sync_settings) {
        setSyncSettings(prev => ({ ...prev, ...config.sync_settings }));
      }
    }
  }, [config]);

  // Validate configuration whenever state changes
  useEffect(() => {
    const isValid = isAuthenticated && 
                   pickerSelectedFolders.length > 0 &&
                   syncSettings.interval_minutes > 0;
    
    setConfigurationValid(isValid);
    
    // Update parent config
    if (isValid) {
      const newConfig = {
        ...config,
        provider: 'google_drive',
        selected_folders: pickerSelectedFolders,
        picker_selections: pickerSelectedFolders,
        sync_settings: syncSettings,
        configuration_valid: true
      };
      
      setConfig(newConfig);
    }
  }, [isAuthenticated, pickerSelectedFolders, syncSettings, setConfig]);

  // Handle Google Drive authentication
  const handleGoogleDriveAuth = async (authResult) => {
    setAuthLoading(true);
    setAuthError(null);
    
    try {
      if (authResult.success) {
        setIsAuthenticated(true);
        
        // Update parent config with auth data
        const authConfig = {
          ...config,
          provider: 'google_drive',
          credentials: authResult.credentials,
          user_email: authResult.user_email,
          authenticated: true
        };
        
        setConfig(authConfig);
        
        // Notify parent component
        if (onAuthenticate) {
          onAuthenticate(authResult);
        }
        
        console.log(`‚úÖ Google Drive authenticated: ${authResult.user_email}`);
      } else {
        setAuthError(authResult.message || 'Authentication failed');
        setIsAuthenticated(false);
      }
    } catch (error) {
      console.error('Authentication error:', error);
      setAuthError('Authentication process failed');
      setIsAuthenticated(false);
    } finally {
      setAuthLoading(false);
    }
  };

  // Handle picker folder selection
  const handlePickerFoldersSelected = (folders) => {
    setPickerSelectedFolders(folders);
    console.log(`üé• Selected ${folders.length} folders via picker:`, folders);
    
    // Update parent config immediately
    const updatedConfig = {
      ...config,
      selected_folders: folders,
      picker_selections: folders,
      folder_structure: 'picker_selected'
    };
    
    setConfig(updatedConfig);
  };

  // Handle sync settings change
  const handleSyncSettingsChange = (newSyncSettings) => {
    setSyncSettings(prev => ({ ...prev, ...newSyncSettings }));
    console.log('‚öôÔ∏è Sync settings updated:', newSyncSettings);
  };

  // Reset configuration
  const handleReset = () => {
    setIsAuthenticated(false);
    setPickerSelectedFolders([]);
    setSyncSettings({
      interval_minutes: 15,
      auto_sync_enabled: true,
      sync_only_new: true,
      skip_duplicates: true,
      organize_by_date: true,
      backup_metadata: true
    });
    setAuthError(null);
    setConfigurationValid(false);
    
    // Reset parent config
    setConfig({
      provider: 'google_drive',
      configuration_valid: false
    });
  };

  return (
    <div className="space-y-6">
      
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h3 className="text-lg font-semibold text-white">‚òÅÔ∏è Google Drive Integration</h3>
          <p className="text-sm text-gray-400">Configure automatic video sync from Google Drive</p>
        </div>
        
        {/* Configuration Status Indicator */}
        <div className={`px-3 py-1 rounded-full text-xs font-medium ${
          configurationValid 
            ? 'bg-green-600 text-green-100' 
            : 'bg-gray-600 text-gray-300'
        }`}>
          {configurationValid ? '‚úÖ Ready' : '‚öôÔ∏è Configuring...'}
        </div>
      </div>

      {/* Error Display */}
      {authError && (
        <div className="bg-red-800 border border-red-600 rounded-lg p-4">
          <div className="flex items-center">
            <span className="text-red-300 text-sm">‚ùå {authError}</span>
            <button
              onClick={() => setAuthError(null)}
              className="ml-auto text-red-400 hover:text-red-300"
            >
              √ó
            </button>
          </div>
        </div>
      )}

      {/* Step 1: Authentication */}
      <div className="bg-gray-700 rounded-lg p-4">
        <div className="flex items-center justify-between mb-3">
          <h4 className="font-medium text-white">Step 1: Authenticate with Google Drive</h4>
          {isAuthenticated && (
            <button
              onClick={handleReset}
              className="text-xs text-gray-400 hover:text-gray-300"
            >
              Reset
            </button>
          )}
        </div>
        
        <GoogleDriveAuthButton
          onAuth={handleGoogleDriveAuth}
          isAuthenticated={isAuthenticated}
          isLoading={authLoading}
          userEmail={config?.user_email}
        />
      </div>

      {/* Step 2: Folder Selection with Google Picker */}
      {isAuthenticated && (
        <div className="bg-gray-700 rounded-lg p-4">
          <h4 className="font-medium text-white mb-3">Step 2: Select Camera Folders</h4>
          
          <div className="bg-blue-800 border border-blue-600 rounded-lg p-3 mb-4">
            <div className="text-sm text-blue-200">
              <div className="font-medium mb-1">üéØ Native Google Drive Experience</div>
              <div>‚Ä¢ Use the familiar Google Drive interface to browse and select folders</div>
              <div>‚Ä¢ Hold Ctrl/Cmd to select multiple folders containing camera videos</div>
              <div>‚Ä¢ Your selections will be automatically configured for VTrack processing</div>
            </div>
          </div>
                    
          {/* Selection Summary */}
          {pickerSelectedFolders.length > 0 && (
            <div className="mt-4 p-3 bg-gray-600 rounded">
              <div className="text-sm text-gray-300">
                <strong>üìÅ Selected via Google Picker:</strong> {pickerSelectedFolders.length} folders
              </div>
              <div className="text-xs text-gray-400 mt-2">
                <div className="space-y-1">
                  {pickerSelectedFolders.slice(0, 5).map((folder, index) => (
                    <div key={folder.id || index} className="flex items-center gap-2">
                      <span>üìπ</span>
                      <span>{folder.name}</span>
                      <span className="text-gray-500">({folder.id})</span>
                    </div>
                  ))}
                  {pickerSelectedFolders.length > 5 && (
                    <div className="text-gray-500">
                      +{pickerSelectedFolders.length - 5} more folders...
                    </div>
                  )}
                </div>
              </div>
            </div>
          )}
        </div>
      )}

      {/* Step 3: Sync Settings */}
      {isAuthenticated && pickerSelectedFolders.length > 0 && (
        <div className="bg-gray-700 rounded-lg p-4">
          <h4 className="font-medium text-white mb-3">Step 3: Configure Sync Settings</h4>
          
          <CloudSyncSettings
            config={syncSettings}
            onChange={handleSyncSettingsChange}
          />
        </div>
      )}

      {/* Configuration Summary */}
      {configurationValid && (
        <div className="bg-green-800 border border-green-600 rounded-lg p-4">
          <h4 className="font-medium text-green-100 mb-2">üéâ Configuration Complete</h4>
          <div className="text-sm text-green-200 space-y-1">
            <div>üìß Account: {config?.user_email}</div>
            <div>üìÅ Source: Google Drive Picker Selection</div>
            <div>üé• Camera Folders: {pickerSelectedFolders.length} selected</div>
            <div>‚è±Ô∏è Sync Interval: {syncSettings.interval_minutes} minutes</div>
            <div>üîÑ Auto-sync: {syncSettings.auto_sync_enabled ? 'Enabled' : 'Disabled'}</div>
            <div>üéØ Method: Native Google Picker Interface</div>
          </div>
        </div>
      )}

      {/* Progress Indicator */}
      <div className="bg-gray-800 rounded-lg p-3">
        <div className="flex items-center justify-between text-xs text-gray-400 mb-2">
          <span>Configuration Progress</span>
          <span>{configurationValid ? '100%' : isAuthenticated ? (pickerSelectedFolders.length > 0 ? '75%' : '33%') : '0%'}</span>
        </div>
        <div className="w-full bg-gray-600 rounded-full h-2">
          <div 
            className={`h-2 rounded-full transition-all duration-300 ${
              configurationValid ? 'bg-green-500' : 'bg-blue-500'
            }`}
            style={{ 
              width: configurationValid ? '100%' : 
                     isAuthenticated ? (pickerSelectedFolders.length > 0 ? '75%' : '33%') : '0%' 
            }}
          ></div>
        </div>
      </div>

      {/* Debug Info (Development Only) */}
      {process.env.NODE_ENV === 'development' && (
        <details className="bg-gray-800 rounded p-3">
          <summary className="text-xs text-gray-400 cursor-pointer">üîß Debug Info</summary>
          <pre className="text-xs text-gray-400 mt-2 overflow-auto">
            {JSON.stringify({
              isAuthenticated,
              pickerFolders: pickerSelectedFolders.length,
              syncSettings,
              configurationValid,
              hasCredentials: !!config?.credentials
            }, null, 2)}
          </pre>
        </details>
      )}
    </div>
  );
};

export default CloudConfigurationForm;
```
## üìÑ File: `ConfigForm.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/ConfigForm.js`

```javascript
import React, { useState, useEffect, useCallback } from 'react';
import AddSourceModal from './AddSourceModal';

const ConfigForm = ({
  inputPath,
  setInputPath,
  outputPath,
  setOutputPath,
  defaultDays,
  setDefaultDays,
  minPackingTime,
  setMinPackingTime,
  maxPackingTime,
  setMaxPackingTime,
  frameRate,
  setFrameRate,
  frameInterval,
  setFrameInterval,
  videoBuffer,
  setVideoBuffer,
  error,
  handleOpenExplorer,
  handleShowCameraDialog,
  // ‚úÖ FIX: Direct state setters thay v√¨ callback
  onCamerasUpdate,
  setActiveVideoSource,
  setConfigFormCameras,
  setConfigFormSelectedCameras,
}) => {
  // State for single active source
  const [activeSource, setActiveSource] = useState(null);
  const [sourceCameras, setSourceCameras] = useState([]);
  const [selectedCameras, setSelectedCameras] = useState([]);
  const [isLoadingSource, setIsLoadingSource] = useState(false);
  const [showAddSourceModal, setShowAddSourceModal] = useState(false);
  const [showUpdateSourceModal, setShowUpdateSourceModal] = useState(false);

  // API functions
  const getSources = async () => {
    const response = await fetch('/get-sources');
    return response.json();
  };

  const addSources = async (sourcesData) => {
    const response = await fetch('/save-sources', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(sourcesData)
    });
    return response.json();
  };

  const deleteSource = async (sourceId) => {
    const response = await fetch(`/delete-source/${sourceId}`, {
      method: 'DELETE'
    });
    return response.json();
  };

  const testSourceConnection = async (sourceData) => {
    const response = await fetch('/test-source', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(sourceData)
    });
    return response.json();
  };
  const detectCameras = async () => {
  try {
    const response = await fetch('/get-camera-folders');
    if (response.ok) {
      const result = await response.json();
      return {
        cameras: result.folders?.map(f => f.name) || [],
        selected_cameras: []
      };
    }
    return { cameras: [], selected_cameras: [] };
  } catch (error) {
    console.error('Camera detection error:', error);
    return { cameras: [], selected_cameras: [] };
  }
};

  const updateSourceCameras = async (sourceId, selectedCameras) => {
    const response = await fetch('/update-source-cameras', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ source_id: sourceId, selected_cameras: selectedCameras })
    });
    return response.json();
  };

  // ‚úÖ NEW: Get processing config cameras
  const getProcessingCameras = async () => {
    const response = await fetch('/get-processing-cameras');
    return response.json();
  };

  // Load active source
  const loadActiveSource = useCallback(async () => {
    setIsLoadingSource(true);
    try {
      const response = await getSources();
      const sources = response.sources || [];
      const active = sources.find(s => s.active);
      setActiveSource(active || null);
      
      let cameras = [];
      let selected = [];
      
      // Load camera info based on source type
      if (active) {
        if (active.source_type === 'local') {
          // Local source: detect camera folders
          try {
            const cameraResponse = await detectCameras();
            cameras = cameraResponse.cameras || [];
            selected = cameraResponse.selected_cameras || [];
          } catch (cameraError) {
            console.warn('Failed to load camera info:', cameraError);
            cameras = [];
            selected = [];
          }
        } else if (active.source_type === 'nvr') {
          // ‚úÖ FIX: NVR source - proper camera loading
          try {
            const nvrConfig = active.config || {};
            const detectedCameras = nvrConfig.detected_cameras || [];
            
            // Convert detected cameras to names
            const detectedCameraNames = detectedCameras.map(cam => 
              cam.name || cam.id || `Camera ${detectedCameras.indexOf(cam) + 1}`
            );
            
            // ‚úÖ NEW: Get selected cameras from processing_config
            const processingResponse = await getProcessingCameras();
            const selectedFromProcessingConfig = processingResponse.selected_cameras || [];
            
            // ‚úÖ Fallback hierarchy: processing_config ‚Üí source.config ‚Üí empty
            let finalSelectedCameras = [];
            if (selectedFromProcessingConfig && selectedFromProcessingConfig.length > 0) {
              finalSelectedCameras = selectedFromProcessingConfig;
              console.log("‚úÖ Using cameras from processing_config:", finalSelectedCameras);
            } else if (nvrConfig.selected_cameras && nvrConfig.selected_cameras.length > 0) {
              finalSelectedCameras = nvrConfig.selected_cameras;
              console.log("‚úÖ Fallback: Using cameras from source config:", finalSelectedCameras);
            } else {
              finalSelectedCameras = [];
              console.log("‚ö†Ô∏è No cameras found in processing_config or source config");
            }
            
            cameras = detectedCameraNames;
            selected = finalSelectedCameras;
            
            console.log('‚úÖ Loaded NVR cameras:', { 
              detected: detectedCameraNames.length, 
              selected: finalSelectedCameras.length,
              detectedNames: detectedCameraNames,
              selectedNames: finalSelectedCameras
            });
            
          } catch (nvrError) {
            console.warn('Failed to load NVR camera info:', nvrError);
            cameras = [];
            selected = [];
          }
        }
      }
      
      setSourceCameras(cameras);
      setSelectedCameras(selected);
      
    } catch (error) {
      console.error('Error loading active source:', error);
      alert('Failed to load video source');
      setSourceCameras([]);
      setSelectedCameras([]);
    } finally {
      setIsLoadingSource(false);
    }
  }, []);

  useEffect(() => {
    loadActiveSource();
  }, []); // ‚úÖ FIX: Ch·ªâ run m·ªôt l·∫ßn khi component mount

  // ‚úÖ FIX: Separate effect ƒë·ªÉ sync v·ªõi parent state - DIRECT UPDATE
  useEffect(() => {
    console.log("=== CONFIG FORM DIRECT UPDATE DEBUG ===");
    console.log("activeSource:", activeSource);
    console.log("sourceCameras:", sourceCameras);
    console.log("selectedCameras:", selectedCameras);
    
    // ‚úÖ Direct update parent state
    if (setActiveVideoSource) {
      console.log("Setting activeVideoSource directly:", activeSource);
      setActiveVideoSource(activeSource);
    }
    
    if (setConfigFormCameras) {
      console.log("Setting configFormCameras directly:", sourceCameras);
      setConfigFormCameras(sourceCameras);
    }
    
    if (setConfigFormSelectedCameras) {
      console.log("Setting configFormSelectedCameras directly:", selectedCameras);
      setConfigFormSelectedCameras(selectedCameras);
    }
    
    // ‚úÖ Also try callback as backup
    if (onCamerasUpdate) {
      console.log("Also calling onCamerasUpdate callback as backup");
      onCamerasUpdate(sourceCameras, selectedCameras, activeSource);
    }
    
  }, [sourceCameras, selectedCameras, activeSource, setActiveVideoSource, setConfigFormCameras, setConfigFormSelectedCameras, onCamerasUpdate]);

  // Enhanced Add Source Handler (supports NVR)
  const handleAddSource = async (sourceData) => {
    try {
      console.log('Adding source:', sourceData);
      
      // Add source
      await addSources({ sources: [sourceData] });
      
      // Post-processing based on source type
      if (sourceData.source_type === 'local') {
        // Local source: trigger camera detection
        try {
          const cameraResponse = await detectCameras();
          if (cameraResponse.cameras && cameraResponse.cameras.length > 0) {
            // Auto-select all detected cameras by default
            await updateSourceCameras(cameraResponse.source_id, cameraResponse.cameras);
          }
        } catch (cameraError) {
          console.warn('Camera detection failed:', cameraError);
          // Continue anyway - camera detection is optional
        }
      } else if (sourceData.source_type === 'nvr') {
        // NVR source: cameras already discovered and selected in modal
        const selectedCameras = sourceData.config?.selected_cameras || [];
        if (selectedCameras.length > 0) {
          try {
            // Update processing_config with selected NVR cameras
            await updateSourceCameras('nvr_source', selectedCameras);
            console.log('NVR cameras saved:', selectedCameras);
          } catch (nvrError) {
            console.warn('Failed to save NVR camera selection:', nvrError);
          }
        }
      }
      
      alert(`${sourceData.source_type.toUpperCase()} source added successfully!`);
      loadActiveSource();
    } catch (error) {
      console.error('Error adding source:', error);
      alert('Failed to add source: ' + (error.response?.data?.error || error.message));
    }
  };

  // Update Source Handler
  const handleUpdateSource = () => {
    if (!activeSource) return;
    setShowUpdateSourceModal(true);
  };

  // Change Source Type Handler (reset workflow)
  const handleChangeSourceType = async () => {
    if (!activeSource) return;
    
    const confirmMessage = `This will remove the current source "${activeSource.name}" and reset to add a new source.\n\nAre you sure you want to continue?`;
    
    if (!window.confirm(confirmMessage)) return;
    
    try {
      // Delete current source
      await deleteSource(activeSource.id);
      
      // Reload to show "No source configured" state
      await loadActiveSource();
      
    } catch (error) {
      console.error('Error removing source:', error);
      alert('Failed to remove source');
    }
  };

  const handleUpdateComplete = () => {
    loadActiveSource(); // Reload source and camera info
    setShowUpdateSourceModal(false);
  };

  const formatDate = (dateString) => {
    if (!dateString) return 'Unknown';
    try {
      return new Date(dateString).toLocaleString('vi-VN', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        timeZone: 'Asia/Ho_Chi_Minh'
      });
    } catch {
      return dateString;
    }
  };

  // Get source type display info
  const getSourceTypeInfo = (sourceType) => {
    const sourceTypes = {
      local: {
        icon: 'üìÅ',
        name: 'LOCAL STORAGE',
        color: 'bg-blue-600'
      },
      nvr: {
        icon: 'üîó',
        name: 'NVR/DVR SYSTEM',
        color: 'bg-purple-600'
      },
      cloud: {
        icon: '‚òÅÔ∏è',
        name: 'CLOUD STORAGE',
        color: 'bg-cyan-600'
      }
    };
    return sourceTypes[sourceType] || { icon: '‚ùì', name: 'UNKNOWN', color: 'bg-gray-600' };
  };

  // ‚úÖ Helper to get working path for different source types
  const getWorkingPathForSource = (source) => {
    if (!source) return "";
    
    switch (source.source_type) {
      case 'nvr':
        return `/Users/annhu/vtrack_app/V_Track/nvr_downloads/${source.name}`;
      case 'local':
        return source.path;
      case 'cloud':
        return `/Users/annhu/vtrack_app/V_Track/cloud_sync/${source.name}`;
      default:
        return source.path;
    }
  };

  return (
    <div className="w-[25%] bg-gray-800 p-6 rounded-lg flex flex-col">
      <h1 className="text-3xl font-bold mb-4">C·∫•u h√¨nh</h1>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      
      {/* Single Active Video Source Section */}
      <div className="mb-6 p-4 bg-gray-700 rounded-lg">
        <div className="flex justify-between items-center mb-3">
          <h3 className="text-lg font-bold text-white">Current Video Input Source</h3>
        </div>

        {isLoadingSource ? (
          <div className="text-center py-4">
            <div className="text-gray-400 text-sm">Loading source...</div>
          </div>
        ) : activeSource ? (
          <div className="bg-gray-600 p-4 rounded-lg">
            <div className="flex items-center gap-2 mb-3">
              <span className="font-medium text-white text-lg">{activeSource.name}</span>
              <span className="px-2 py-1 rounded text-xs bg-green-600 text-white">
                Active
              </span>
            </div>
            
            {/* Enhanced Source Type Display */}
            <div className="flex items-center gap-2 mb-2">
              <span className="text-sm text-gray-300"><strong>Type:</strong></span>
              <div className="flex items-center gap-1">
                <span className="text-sm">{getSourceTypeInfo(activeSource.source_type).icon}</span>
                <span className={`px-2 py-1 rounded text-xs text-white font-medium ${getSourceTypeInfo(activeSource.source_type).color}`}>
                  {getSourceTypeInfo(activeSource.source_type).name}
                </span>
              </div>
            </div>
            
            <div className="text-gray-300 text-sm mb-2 break-all">
              <strong>Path:</strong> {activeSource.path}
            </div>
            
            {/* NVR-specific information */}
            {activeSource.source_type === 'nvr' && activeSource.config && (
              <div className="text-gray-300 text-sm mb-2">
                <strong>Protocol:</strong> {activeSource.config.protocol?.toUpperCase() || 'ONVIF'}
                {activeSource.config.auto_sync && (
                  <span className="ml-2 px-1 py-0.5 bg-green-700 text-green-200 rounded text-xs">
                    Auto-Sync
                  </span>
                )}
              </div>
            )}
            
            <div className="text-gray-300 text-sm mb-2">
              <strong>Added:</strong> {formatDate(activeSource.created_at)}
            </div>
            
            {/* Camera Information */}
            {(activeSource.source_type === 'local' || activeSource.source_type === 'nvr') && (
              <div className="text-gray-300 text-sm mb-3">
                <strong>Cameras:</strong>{' '}
                {sourceCameras.length > 0 ? (
                  <span>
                    {selectedCameras.length} selected of {sourceCameras.length} detected
                    <div className="mt-1 text-xs">
                      {selectedCameras.length > 0 ? (
                        <span className="text-green-300">
                          Active: {selectedCameras.slice(0, 3).join(', ')}
                          {selectedCameras.length > 3 && ` +${selectedCameras.length - 3} more`}
                        </span>
                      ) : (
                        <span className="text-yellow-300">No cameras selected</span>
                      )}
                    </div>
                    {sourceCameras.length > selectedCameras.length && (
                      <div className="text-xs text-gray-400">
                        Available: {sourceCameras.filter(cam => !selectedCameras.includes(cam)).slice(0, 2).join(', ')}
                        {sourceCameras.filter(cam => !selectedCameras.includes(cam)).length > 2 && '...'}
                      </div>
                    )}
                  </span>
                ) : (
                  <span className="text-gray-400">
                    {activeSource.source_type === 'nvr' ? 'No cameras discovered' : 'No camera folders detected'}
                  </span>
                )}
              </div>
            )}
            
            {/* Action Buttons */}
            <div className="flex justify-end gap-2">
              <button
                onClick={handleUpdateSource}
                className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm font-medium"
              >
                Update
              </button>
              <button
                onClick={handleChangeSourceType}
                className="px-4 py-2 bg-orange-600 hover:bg-orange-700 text-white rounded text-sm font-medium"
              >
                Change
              </button>
            </div>
          </div>
        ) : (
          <div className="text-center py-6">
            <div className="text-gray-400 text-sm mb-3">
              No video source configured yet.
            </div>
            <button
              onClick={() => setShowAddSourceModal(true)}
              className="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded font-medium"
            >
              Add Video Source
            </button>
          </div>
        )}
      </div>

      {/* ‚úÖ FIX: Input Path Section - DISTINGUISH NVR vs LOCAL */}
      <div className="mb-6 p-4 bg-gray-700 rounded-lg">
        <h3 className="text-lg font-bold text-white mb-3">Input Video Path</h3>
        
        {activeSource ? (
          <div className="bg-gray-600 p-3 rounded">
            <div className="text-sm text-gray-300 mb-1">
              <strong>Source:</strong> {activeSource.name}
            </div>
            
            {activeSource.source_type === 'nvr' ? (
              <>
                <div className="text-sm text-gray-300 mb-1">
                  <strong>NVR Connection:</strong> {activeSource.path}
                </div>
                <div className="text-sm text-gray-300 mb-1">
                  <strong>Working Directory:</strong> {getWorkingPathForSource(activeSource)}
                </div>
                <div className="mt-2 text-xs text-blue-300">
                  üîó NVR videos will be downloaded to working directory for processing
                </div>
              </>
            ) : activeSource.source_type === 'local' ? (
              <>
                <div className="text-sm text-gray-300 mb-1">
                  <strong>File System Path:</strong> {activeSource.path}
                </div>
                <div className="text-sm text-gray-300 mb-1">
                  <strong>Processing Path:</strong> {getWorkingPathForSource(activeSource)}
                </div>
                <div className="mt-2 text-xs text-green-300">
                  üìÅ Videos will be processed directly from this location
                </div>
              </>
            ) : (
              <>
                <div className="text-sm text-gray-300 mb-1">
                  <strong>Source Path:</strong> {activeSource.path}
                </div>
                <div className="text-sm text-gray-300 mb-1">
                  <strong>Working Path:</strong> {getWorkingPathForSource(activeSource)}
                </div>
                <div className="mt-2 text-xs text-yellow-300">
                  ‚ö†Ô∏è Source type: {activeSource.source_type}
                </div>
              </>
            )}
            
            <div className="text-sm text-gray-300">
              <strong>Type:</strong> {getSourceTypeInfo(activeSource.source_type).name}
            </div>
            <div className="mt-2 text-xs text-green-300">
              ‚úÖ Input path automatically configured from video source
            </div>
          </div>
        ) : (
          <div className="text-center py-4 bg-gray-600 rounded">
            <div className="text-gray-400 text-sm mb-3">
              No video source configured. Input path will be empty.
            </div>
            <button
              onClick={() => setShowAddSourceModal(true)}
              className="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded text-sm font-medium"
            >
              Add Video Source First
            </button>
          </div>
        )}
      </div>

      {/* Legacy Input Path Field - Hidden khi c√≥ video source */}
      {!activeSource && (
        <div className="mb-4">
          <label className="block mb-1">Legacy Input Path (Deprecated):</label>
          <div className="relative w-full">
            <input
              type="text"
              value={inputPath}
              onChange={(e) => setInputPath(e.target.value)}
              placeholder="Please add a video source instead"
              className="w-full p-2 rounded bg-gray-700 text-white"
              disabled
            />
            <div className="text-xs text-yellow-400 mt-1">
              ‚ö†Ô∏è Please use "Add Video Source" button above instead
            </div>
          </div>
        </div>
      )}

      <div className="mb-4">
        <label className="block mb-1">V·ªã tr√≠ Output Video:</label>
        <div className="relative w-full">
          <input
            type="text"
            value={outputPath}
            onChange={(e) => setOutputPath(e.target.value)}
            placeholder="V·ªã tr√≠ Output Video (e.g., /Users/annhu/vtrack_app/V_Track/output_clips)"
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
          <button
            type="button"
            onClick={() => handleOpenExplorer("output")}
            className="absolute right-2 top-1/2 transform -translate-y-1/2 text-white"
          >
            ...
          </button>
        </div>
      </div>
      <div className="flex flex-col gap-4 mb-4">
        <div>
          <label className="block mb-1">Th·ªùi gian l∆∞u tr·ªØ (ng√†y):</label>
          <input
            type="number"
            value={defaultDays}
            onChange={(e) => setDefaultDays(Number(e.target.value))}
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
        <div>
          <label className="block mb-1">Th·ªùi gian ƒë√≥ng h√†ng nhanh nh·∫•t (gi√¢y):</label>
          <input
            type="number"
            value={minPackingTime}
            onChange={(e) => setMinPackingTime(Number(e.target.value))}
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
        <div>
          <label className="block mb-1">Th·ªùi gian ƒë√≥ng h√†ng ch·∫≠m nh·∫•t (gi√¢y):</label>
          <input
            type="number"
            value={maxPackingTime}
            onChange={(e) => setMaxPackingTime(Number(e.target.value))}
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
        <div>
          <label className="block mb-1">T·ªëc ƒë·ªô frame:</label>
          <input
            type="number"
            value={frameRate}
            onChange={(e) => setFrameRate(Number(e.target.value))}
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
        <div>
          <label className="block mb-1">Kho·∫£ng c√°ch Frame:</label>
          <input
            type="number"
            value={frameInterval}
            onChange={(e) => setFrameInterval(Number(e.target.value))}
            min="2"
            max="30"
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
        <div>
          <label className="block mb-1">Buffer Video (gi√¢y):</label>
          <input
            type="number"
            value={videoBuffer}
            onChange={(e) => setVideoBuffer(Number(e.target.value))}
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
      </div>
      <div className="mt-auto flex justify-center">
        <button
          onClick={handleShowCameraDialog}
          className="w-1/2 py-2 bg-blue-600 text-white font-bold rounded"
        >
          G·ª≠i
        </button>
      </div>

      {/* Enhanced AddSourceModal with NVR support */}
      {showAddSourceModal && (
        <AddSourceModal
          show={showAddSourceModal}
          onClose={() => setShowAddSourceModal(false)}
          onAdd={handleAddSource}
          testSourceConnection={testSourceConnection}
        />
      )}

      {/* Simple Update Source Modal */}
      {showUpdateSourceModal && activeSource && (
        <SimpleUpdateSourceModal
          show={showUpdateSourceModal}
          source={activeSource}
          sourceCameras={sourceCameras}
          selectedCameras={selectedCameras}
          onClose={() => setShowUpdateSourceModal(false)}
          onUpdate={handleUpdateComplete}
          testSourceConnection={testSourceConnection}
          detectCameras={detectCameras}
          updateSourceCameras={updateSourceCameras}
        />
      )}
    </div>
  );
};

// Enhanced Update Source Modal Component (supports NVR)
const SimpleUpdateSourceModal = ({ 
  show, 
  source, 
  sourceCameras,
  selectedCameras: initialSelectedCameras,
  onClose, 
  onUpdate, 
  testSourceConnection, 
  detectCameras, 
  updateSourceCameras
}) => {
  const [path] = useState(source.path);
  const [detectedCameras, setDetectedCameras] = useState(sourceCameras);
  const [selectedCameras, setSelectedCameras] = useState(initialSelectedCameras);
  
  // Loading states
  const [isDetecting, setIsDetecting] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [testResult, setTestResult] = useState(null);

  useEffect(() => {
    setDetectedCameras(sourceCameras);
    setSelectedCameras(initialSelectedCameras);
  }, [sourceCameras, initialSelectedCameras]);

  const detectCamerasInPath = async () => {
    if (!path) return;
    
    setIsDetecting(true);
    try {
      if (source.source_type === 'local') {
        // Local source: scan for camera folders
        const response = await detectCameras();
        if (response.cameras) {
          setDetectedCameras(response.cameras);
          // Keep existing selected cameras that are still available
          const validSelectedCameras = selectedCameras.filter(cam => 
            response.cameras.includes(cam)
          );
          setSelectedCameras(validSelectedCameras);
        }
      } else if (source.source_type === 'nvr') {
        // NVR source: re-test connection to discover cameras
        const testData = {
          source_type: 'nvr',
          path: source.path,
          config: source.config || {}
        };
        
        const response = await testSourceConnection(testData);
        if (response.accessible && response.cameras) {
          const cameraNames = response.cameras.map(cam => 
            cam.name || cam.id || `Camera ${response.cameras.indexOf(cam) + 1}`
          );
          setDetectedCameras(cameraNames);
          
          // Keep existing selected cameras that are still available
          const validSelectedCameras = selectedCameras.filter(cam => 
            cameraNames.includes(cam)
          );
          setSelectedCameras(validSelectedCameras);
        }
      }
    } catch (error) {
      console.error('Camera detection failed:', error);
      setDetectedCameras([]);
      setSelectedCameras([]);
    } finally {
      setIsDetecting(false);
    }
  };

  const handleTestConnection = async () => {
    if (!path) {
      alert('No path to test');
      return;
    }

    setIsLoading(true);
    try {
      const testData = {
        source_type: source.source_type,
        path: path,
        config: source.config || {}
      };
      
      const response = await testSourceConnection(testData);
      setTestResult({
        success: response.accessible,
        message: response.message
      });
      
      // Auto-discover cameras on successful test for NVR
      if (response.accessible && source.source_type === 'nvr' && response.cameras) {
        const cameraNames = response.cameras.map(cam => 
          cam.name || cam.id || `Camera ${response.cameras.indexOf(cam) + 1}`
        );
        setDetectedCameras(cameraNames);
        setTestResult(prev => ({
          ...prev,
          message: `${prev.message} - Found ${response.cameras.length} camera(s)`
        }));
      }
      
    } catch (error) {
      setTestResult({
        success: false,
        message: error.message || 'Connection test failed'
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleCameraToggle = (cameraName) => {
    setSelectedCameras(prev => 
      prev.includes(cameraName) 
        ? prev.filter(c => c !== cameraName)
        : [...prev, cameraName]
    );
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    try {
      // Update camera selection
      await updateSourceCameras(source.id, selectedCameras);
      
      alert('Source updated successfully!');
      onUpdate();
    } catch (error) {
      console.error('Error updating source:', error);
      alert('Failed to update source: ' + (error.response?.data?.error || error.message));
    }
  };

  if (!show) return null;

  const getSourceTypeInfo = (sourceType) => {
    const sourceTypes = {
      local: { icon: 'üìÅ', name: 'LOCAL STORAGE' },
      nvr: { icon: 'üîó', name: 'NVR/DVR SYSTEM' },
      cloud: { icon: '‚òÅÔ∏è', name: 'CLOUD STORAGE' }
    };
    return sourceTypes[sourceType] || { icon: '‚ùì', name: 'UNKNOWN' };
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-gray-800 rounded-lg p-6 w-full max-w-2xl mx-4 max-h-[90vh] overflow-y-auto">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-xl font-bold text-white">üîß Update Video Source</h3>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-white text-2xl"
          >
            √ó
          </button>
        </div>

        <form onSubmit={handleSubmit}>
          {/* Source Type Info */}
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-300 mb-2">
              Source Type
            </label>
            <div className="w-full p-3 border border-gray-600 rounded bg-gray-700 text-white flex items-center">
              <span className="mr-2">{getSourceTypeInfo(source.source_type).icon}</span>
              <span className="font-medium">{getSourceTypeInfo(source.source_type).name}</span>
              <span className="ml-2 text-gray-400 text-sm">(ReadOnly)</span>
            </div>
          </div>

          {/* Path Info */}
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-300 mb-2">
              {source.source_type === 'nvr' ? 'NVR Address' : 'Path'}
            </label>
            <div className="w-full p-3 border border-gray-600 rounded bg-gray-700 text-white break-all">
              {path}
            </div>
          </div>

          {/* NVR Configuration Display */}
          {source.source_type === 'nvr' && source.config && (
            <div className="mb-4">
              <label className="block text-sm font-medium text-gray-300 mb-2">
                NVR Configuration
              </label>
              <div className="p-3 bg-gray-700 rounded space-y-2">
                <div className="text-sm text-gray-300">
                  <strong>Protocol:</strong> {source.config.protocol?.toUpperCase() || 'ONVIF'}
                </div>
                <div className="text-sm text-gray-300">
                  <strong>Username:</strong> {source.config.username || 'Not set'}
                </div>
                <div className="text-sm text-gray-300">
                  <strong>Auto-sync:</strong> {source.config.auto_sync ? 'Enabled' : 'Disabled'}
                </div>
              </div>
            </div>
          )}

          {/* Camera Selection */}
          <div className="mb-4">
            <div className="flex justify-between items-center mb-3">
              <label className="block text-sm font-medium text-gray-300">
                {source.source_type === 'nvr' ? 'Discovered Cameras' : 'Camera Folders'}
              </label>
              <button
                type="button"
                onClick={detectCamerasInPath}
                disabled={isDetecting}
                className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 text-white px-3 py-1 rounded text-xs"
              >
                {isDetecting ? 'Scanning...' : source.source_type === 'nvr' ? 'Rediscover' : 'Rescan'}
              </button>
            </div>
            
            {isDetecting ? (
              <div className="text-center py-4">
                <div className="text-gray-400 text-sm">
                  {source.source_type === 'nvr' ? 'Discovering cameras...' : 'Detecting cameras...'}
                </div>
              </div>
            ) : detectedCameras.length > 0 ? (
              <div className="grid grid-cols-2 gap-2 p-3 bg-gray-700 rounded">
                {detectedCameras.map(camera => (
                  <label key={camera} className="flex items-center space-x-2 cursor-pointer">
                    <input
                      type="checkbox"
                      checked={selectedCameras.includes(camera)}
                      onChange={() => handleCameraToggle(camera)}
                      className="rounded"
                    />
                    <span className="text-white text-sm">{camera}</span>
                    {camera.status && (
                      <span className={`px-2 py-1 text-xs rounded ${camera.status === 'Connected' ? 'bg-green-600' : 'bg-red-600'}`}>
                        {camera.status}
                      </span>
                    )}
                  </label>
                ))}
              </div>
            ) : (
              <div className="text-center py-4 bg-gray-700 rounded">
                <div className="text-gray-400 text-sm">
                  {source.source_type === 'nvr' ? 'No cameras discovered' : 'No camera folders detected'}
                </div>
              </div>
            )}
            
            {selectedCameras.length > 0 && (
              <div className="mt-2 text-xs text-gray-400">
                Selected: {selectedCameras.length} camera(s)
              </div>
            )}
          </div>

          {/* Test Connection */}
          <div className="mb-4">
            <button
              type="button"
              onClick={handleTestConnection}
              disabled={isLoading}
              className="bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 text-white px-4 py-2 rounded font-medium"
            >
              {isLoading ? 'Testing...' : 'Test Connection'}
            </button>
            
            {testResult && (
              <div className={`mt-2 p-3 rounded text-sm ${
                testResult.success ? 'bg-green-800 text-green-200' : 'bg-red-800 text-red-200'
              }`}>
                {testResult.message}
              </div>
            )}
          </div>

          {/* Action Buttons */}
          <div className="flex gap-3">
            <button
              type="submit"
              className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded font-medium"
            >
              Save Changes
            </button>
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded font-medium"
            >
              Cancel
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default ConfigForm;
```
## üìÑ File: `GoogleDriveFolderSelector.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/GoogleDriveFolderSelector.js`

```javascript
// ‚ö†Ô∏è DEPRECATED: This component has been replaced by GoogleDrivePickerIntegration
// This file is kept for rollback purposes only and will be removed in future versions
// Use GoogleDrivePickerIntegration.js instead

console.warn('‚ö†Ô∏è GoogleDriveFolderSelector is deprecated. Use GoogleDrivePickerIntegration instead.');

// components/config/GoogleDriveFolderSelector.js - 2-Step Folder Selection
import React, { useState, useEffect } from 'react';

const GoogleDriveFolderSelector = ({
  rootFolders = [],
  subFolders = [],
  selectedRootFolder = null,
  selectedCameraFolders = [],
  isLoadingFolders = false,
  onSelectRoot,
  onSelectCameras
}) => {
  // ‚ö†Ô∏è DEPRECATION WARNING: Show to developers
  useEffect(() => {
    console.warn('‚ö†Ô∏è GoogleDriveFolderSelector is DEPRECATED');
    console.warn('   ‚Üí Replace with GoogleDrivePickerIntegration.js');
    console.warn('   ‚Üí This component will be removed in future versions');
    console.warn('   ‚Üí Phase 3 migration completed - update your imports');
  }, []);

  // Local state
  const [expandedFolders, setExpandedFolders] = useState(new Set());
  const [searchTerm, setSearchTerm] = useState('');
  const [viewMode, setViewMode] = useState('tree'); // 'tree' or 'list'
  const [folderStructure, setFolderStructure] = useState('unknown');

  // Filter folders based on search term
  const filteredRootFolders = rootFolders.filter(folder =>
    folder.name.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const filteredSubFolders = subFolders.filter(folder =>
    folder.name.toLowerCase().includes(searchTerm.toLowerCase())
  );

  // Detect folder structure when subfolders load
  useEffect(() => {
    if (subFolders.length > 0) {
      // Check if subfolders look like camera folders
      const cameraKeywords = ['cam', 'camera', 'channel', 'ch', 'zone', 'area'];
      const cameraFolderCount = subFolders.filter(folder =>
        cameraKeywords.some(keyword => 
          folder.name.toLowerCase().includes(keyword)
        )
      ).length;

      if (cameraFolderCount > 0) {
        setFolderStructure('nested_cameras');
      } else {
        setFolderStructure('nested_general');
      }
    } else {
      setFolderStructure('unknown');
    }
  }, [subFolders]);

  // Handle root folder click/selection
  const handleRootFolderClick = (folder) => {
    if (selectedRootFolder?.id === folder.id) {
      // Already selected - toggle expansion
      const newExpanded = new Set(expandedFolders);
      if (newExpanded.has(folder.id)) {
        newExpanded.delete(folder.id);
      } else {
        newExpanded.add(folder.id);
      }
      setExpandedFolders(newExpanded);
    } else {
      // New selection
      if (onSelectRoot) {
        onSelectRoot(folder);
      }
      
      // Auto-expand the selected folder
      const newExpanded = new Set(expandedFolders);
      newExpanded.add(folder.id);
      setExpandedFolders(newExpanded);
    }
  };

  // Handle camera folder toggle
  const handleCameraFolderToggle = (cameraFolder) => {
    const currentSelected = [...selectedCameraFolders];
    const folderName = cameraFolder.name;
    
    if (currentSelected.includes(folderName)) {
      // Remove from selection
      const newSelected = currentSelected.filter(name => name !== folderName);
      if (onSelectCameras) {
        onSelectCameras(newSelected);
      }
    } else {
      // Add to selection
      const newSelected = [...currentSelected, folderName];
      if (onSelectCameras) {
        onSelectCameras(newSelected);
      }
    }
  };

  // Select all camera folders
  const handleSelectAllCameras = () => {
    const allCameraNames = subFolders.map(folder => folder.name);
    if (onSelectCameras) {
      onSelectCameras(allCameraNames);
    }
  };

  // Deselect all camera folders
  const handleDeselectAllCameras = () => {
    if (onSelectCameras) {
      onSelectCameras([]);
    }
  };

  // Get folder icon based on folder type
  const getFolderIcon = (folder) => {
    const name = folder.name.toLowerCase();
    
    if (name.includes('camera') || name.includes('cam')) return 'üìπ';
    if (name.includes('security') || name.includes('surveillance')) return 'üîí';
    if (name.includes('recording') || name.includes('video')) return 'üé¨';
    if (name.includes('storage') || name.includes('archive')) return 'üíæ';
    if (name.includes('backup')) return 'üîÑ';
    
    return 'üìÅ';
  };

  // Get selection status for bulk operations
  const getSelectionStatus = () => {
    if (subFolders.length === 0) return 'none';
    if (selectedCameraFolders.length === 0) return 'none';
    if (selectedCameraFolders.length === subFolders.length) return 'all';
    return 'partial';
  };

  return (
    <div className="space-y-4">
      
      {/* ‚ö†Ô∏è DEPRECATION WARNING BANNER */}
      <div className="bg-orange-800 border border-orange-600 rounded-lg p-4">
        <div className="flex items-center gap-2">
          <span className="text-orange-200 text-xl">‚ö†Ô∏è</span>
          <div className="text-orange-200">
            <div className="font-medium">DEPRECATED COMPONENT</div>
            <div className="text-sm">This component has been replaced by GoogleDrivePickerIntegration. Please update your code.</div>
          </div>
        </div>
      </div>
      
      {/* Header with Search and View Controls */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <h4 className="font-medium text-white">üìÅ Folder Selection</h4>
          
          {/* View Mode Toggle */}
          <div className="flex bg-gray-600 rounded overflow-hidden">
            <button
              onClick={() => setViewMode('tree')}
              className={`px-3 py-1 text-xs font-medium ${
                viewMode === 'tree' 
                  ? 'bg-blue-600 text-white' 
                  : 'text-gray-300 hover:text-white'
              }`}
            >
              Tree
            </button>
            <button
              onClick={() => setViewMode('list')}
              className={`px-3 py-1 text-xs font-medium ${
                viewMode === 'list' 
                  ? 'bg-blue-600 text-white' 
                  : 'text-gray-300 hover:text-white'
              }`}
            >
              List
            </button>
          </div>
        </div>

        {/* Search */}
        <div className="relative">
          <input
            type="text"
            placeholder="Search folders..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-48 px-3 py-1 bg-gray-600 text-white text-sm rounded border border-gray-500 focus:border-blue-500"
          />
          {searchTerm && (
            <button
              onClick={() => setSearchTerm('')}
              className="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-white"
            >
              √ó
            </button>
          )}
        </div>
      </div>

      {/* Step 1: Root Folder Selection */}
      <div className="bg-gray-600 rounded-lg p-4">
        <div className="flex items-center justify-between mb-3">
          <h5 className="font-medium text-white">Step 1: Select Root Folder</h5>
          <span className="text-xs text-gray-300">
            {filteredRootFolders.length} folder(s) available
          </span>
        </div>

        {filteredRootFolders.length === 0 ? (
          <div className="text-center py-6 text-gray-400">
            <div className="text-2xl mb-2">üìÇ</div>
            <div className="text-sm">
              {searchTerm ? 'No folders match your search' : 'No folders available'}
            </div>
          </div>
        ) : (
          <div className="space-y-2 max-h-32 overflow-y-auto">
            {filteredRootFolders.map((folder) => (
              <div
                key={folder.id}
                onClick={() => handleRootFolderClick(folder)}
                className={`flex items-center gap-3 p-3 rounded cursor-pointer transition-colors ${
                  selectedRootFolder?.id === folder.id
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-700 hover:bg-gray-650 text-gray-300'
                }`}
              >
                <span className="text-lg">{getFolderIcon(folder)}</span>
                <div className="flex-1 min-w-0">
                  <div className="font-medium truncate">{folder.name}</div>
                  {folder.description && (
                    <div className="text-xs opacity-75 truncate">{folder.description}</div>
                  )}
                </div>
                {selectedRootFolder?.id === folder.id && (
                  <span className="text-green-300 text-sm">‚úì Selected</span>
                )}
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Step 2: Camera Folder Selection */}
      {selectedRootFolder && (
        <div className="bg-gray-600 rounded-lg p-4">
          <div className="flex items-center justify-between mb-3">
            <h5 className="font-medium text-white">
              Step 2: Select Camera Folders
              <span className="text-sm text-gray-300 ml-2">
                from "{selectedRootFolder.name}"
              </span>
            </h5>
            
            {/* Bulk Selection Controls */}
            {subFolders.length > 0 && (
              <div className="flex gap-2">
                <button
                  onClick={handleSelectAllCameras}
                  disabled={getSelectionStatus() === 'all'}
                  className="px-3 py-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-500 text-white rounded text-xs font-medium"
                >
                  Select All
                </button>
                <button
                  onClick={handleDeselectAllCameras}
                  disabled={getSelectionStatus() === 'none'}
                  className="px-3 py-1 bg-gray-500 hover:bg-gray-600 disabled:bg-gray-400 text-white rounded text-xs font-medium"
                >
                  Clear All
                </button>
              </div>
            )}
          </div>

          {/* Loading State */}
          {isLoadingFolders && (
            <div className="text-center py-6">
              <div className="animate-spin w-6 h-6 border-2 border-blue-500 border-t-transparent rounded-full mx-auto mb-2"></div>
              <div className="text-sm text-gray-400">Loading camera folders...</div>
            </div>
          )}

          {/* No Subfolders */}
          {!isLoadingFolders && subFolders.length === 0 && (
            <div className="text-center py-6 text-gray-400">
              <div className="text-2xl mb-2">üìπ</div>
              <div className="text-sm">
                No camera folders found in "{selectedRootFolder.name}"
              </div>
              <div className="text-xs mt-1">
                Try selecting a different root folder
              </div>
            </div>
          )}

          {/* Camera Folders List */}
          {!isLoadingFolders && filteredSubFolders.length > 0 && (
            <div>
              {/* Folder Structure Info */}
              {folderStructure === 'nested_cameras' && (
                <div className="bg-green-800 border border-green-600 rounded p-2 mb-3">
                  <div className="text-xs text-green-200">
                    üéØ Camera folder structure detected! These appear to be camera recording folders.
                  </div>
                </div>
              )}

              {viewMode === 'tree' ? (
                /* Tree View */
                <div className="space-y-1 max-h-48 overflow-y-auto">
                  {filteredSubFolders.map((folder) => (
                    <label
                      key={folder.id}
                      className="flex items-center gap-3 p-2 rounded cursor-pointer hover:bg-gray-700 transition-colors"
                    >
                      <input
                        type="checkbox"
                        checked={selectedCameraFolders.includes(folder.name)}
                        onChange={() => handleCameraFolderToggle(folder)}
                        className="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500"
                      />
                      <span className="text-lg">{getFolderIcon(folder)}</span>
                      <div className="flex-1 min-w-0">
                        <div className="font-medium text-white truncate">{folder.name}</div>
                        {folder.file_count && (
                          <div className="text-xs text-gray-400">
                            {folder.file_count} files
                          </div>
                        )}
                      </div>
                      {folder.size && (
                        <div className="text-xs text-gray-400">
                          {(folder.size / 1024 / 1024).toFixed(1)} MB
                        </div>
                      )}
                    </label>
                  ))}
                </div>
              ) : (
                /* List View */
                <div className="grid grid-cols-2 gap-2 max-h-48 overflow-y-auto">
                  {filteredSubFolders.map((folder) => (
                    <label
                      key={folder.id}
                      className={`flex items-center gap-2 p-2 rounded cursor-pointer transition-colors ${
                        selectedCameraFolders.includes(folder.name)
                          ? 'bg-blue-600 text-white'
                          : 'bg-gray-700 hover:bg-gray-650 text-gray-300'
                      }`}
                    >
                      <input
                        type="checkbox"
                        checked={selectedCameraFolders.includes(folder.name)}
                        onChange={() => handleCameraFolderToggle(folder)}
                        className="w-4 h-4"
                      />
                      <span>{getFolderIcon(folder)}</span>
                      <span className="font-medium text-sm truncate">{folder.name}</span>
                    </label>
                  ))}
                </div>
              )}

              {/* Selection Summary */}
              <div className="mt-3 p-2 bg-gray-700 rounded">
                <div className="text-sm text-gray-300">
                  <strong>Selected:</strong> {selectedCameraFolders.length} of {subFolders.length} camera folders
                </div>
                {selectedCameraFolders.length > 0 && (
                  <div className="text-xs text-gray-400 mt-1">
                    {selectedCameraFolders.slice(0, 3).join(', ')}
                    {selectedCameraFolders.length > 3 && ` +${selectedCameraFolders.length - 3} more`}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      )}

      {/* Configuration Summary */}
      {selectedRootFolder && selectedCameraFolders.length > 0 && (
        <div className="bg-green-800 border border-green-600 rounded-lg p-3">
          <h5 className="font-medium text-green-100 mb-2">üìã Selection Summary</h5>
          <div className="text-sm text-green-200 space-y-1">
            <div><strong>Root Folder:</strong> {selectedRootFolder.name}</div>
            <div><strong>Camera Folders:</strong> {selectedCameraFolders.length} selected</div>
            <div><strong>Structure:</strong> {folderStructure === 'nested_cameras' ? 'Nested Camera Folders' : 'Nested General Folders'}</div>
            <div className="text-xs text-green-300 mt-2">
              Videos will be synced from: {selectedRootFolder.name}/{selectedCameraFolders.join(', ')}
            </div>
          </div>
        </div>
      )}

      {/* Debug Info (Development) */}
      {process.env.NODE_ENV === 'development' && (
        <details className="bg-gray-800 rounded p-2">
          <summary className="text-xs text-gray-400 cursor-pointer">üîß Debug - Folder Selection</summary>
          <pre className="text-xs text-gray-400 mt-2 overflow-auto">
            {JSON.stringify({
              rootFolders: rootFolders.length,
              subFolders: subFolders.length,
              selectedRoot: selectedRootFolder?.name,
              selectedCameras: selectedCameraFolders,
              folderStructure,
              searchTerm,
              viewMode,
              DEPRECATED: true,
              replacement: 'GoogleDrivePickerIntegration.js'
            }, null, 2)}
          </pre>
        </details>
      )}
    </div>
  );
};

export default GoogleDriveFolderSelector;
```
## üìÑ File: `GeneralInfoForm.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/GeneralInfoForm.js`

```javascript
import DatePicker from "react-datepicker";

const GeneralInfoForm = ({
  country,
  setCountry,
  timezone,
  setTimezone,
  brandName,
  setBrandName,
  workingDays,
  setWorkingDays,
  fromTime,
  setFromTime,
  toTime,
  setToTime,
  handleCountryChange,
  handleFromTimeChange,
  handleToTimeChange,
  handleWorkingDayChange,
  handleSaveGeneralInfo,
  countries,
}) => {
  return (
    <div className="w-[25%] bg-gray-800 p-6 rounded-lg flex flex-col">
      <h1 className="text-3xl font-bold mb-4">Th√¥ng tin chung</h1>
      <div className="mb-4">
        <label className="block mb-1">Qu·ªëc gia:</label>
        <select
          value={country}
          onChange={handleCountryChange}
          className="w-full p-2 rounded bg-gray-700 text-white"
        >
          {countries.map((country) => (
            <option key={country} value={country}>
              {country}
            </option>
          ))}
        </select>
      </div>
      <div className="mb-4">
        <label className="block mb-1">M√∫i gi·ªù:</label>
        <input
          type="text"
          value={timezone}
          readOnly
          className="w-full p-2 rounded bg-gray-700 text-white"
        />
      </div>
      <div className="mb-4">
        <label className="block mb-1">T√™n th∆∞∆°ng hi·ªáu:</label>
        <input
          type="text"
          value={brandName}
          onChange={(e) => setBrandName(e.target.value)}
          placeholder="Nh·∫≠p t√™n th∆∞∆°ng hi·ªáu"
          className="w-full p-2 rounded bg-gray-700 text-white"
        />
      </div>
      <div className="mb-4">
        <h3 className="text-lg font-bold mb-2">Ng√†y l√†m vi·ªác</h3>
        {["Th·ª© Hai", "Th·ª© Ba", "Th·ª© T∆∞", "Th·ª© NƒÉm", "Th·ª© S√°u", "Th·ª© B·∫£y", "Ch·ªß Nh·∫≠t"].map((day) => (
          <label key={day} className="flex items-center mb-2">
            <input
              type="checkbox"
              className="mr-2"
              onChange={() => handleWorkingDayChange(day)}
              checked={workingDays.includes(day)}
            />
            {day}
          </label>
        ))}
      </div>
      <div className="mb-4">
        <h3 className="text-lg font-bold mb-2">Th·ªùi gian l√†m vi·ªác</h3>
        <div className="flex gap-4">
          <div className="flex-1">
            <label className="block mb-1">T·ª´:</label>
            <DatePicker
              selected={fromTime}
              onChange={handleFromTimeChange}
              showTimeSelect
              showTimeSelectOnly
              timeIntervals={30}
              timeCaption="Gi·ªù"
              dateFormat="HH:mm"
              className="w-full p-2 rounded bg-gray-700 text-white"
            />
          </div>
          <div className="flex-1">
            <label className="block mb-1">ƒê·∫øn:</label>
            <DatePicker
              selected={toTime}
              onChange={handleToTimeChange}
              showTimeSelect
              showTimeSelectOnly
              timeIntervals={30}
              timeCaption="Gi·ªù"
              dateFormat="HH:mm"
              className="w-full p-2 rounded bg-gray-700 text-white"
            />
          </div>
        </div>
      </div>
      <div className="mt-auto flex justify-center">
        <button
          onClick={handleSaveGeneralInfo}
          className="w-1/2 py-2 bg-blue-600 text-white font-bold rounded"
        >
          G·ª≠i
        </button>
      </div>
    </div>
  );
};

export default GeneralInfoForm;
```
## üìÑ File: `GoogleDriveAuthButton.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/GoogleDriveAuthButton.js`

```javascript
// components/config/GoogleDriveAuthButton.js - FIXED for COOP & OAuth State Issues
import React, { useState, useEffect } from 'react';

const GoogleDriveAuthButton = ({ 
  onAuth, 
  isAuthenticated = false, 
  isLoading = false, 
  userEmail = null,
  className = '' 
}) => {
  const [authState, setAuthState] = useState({
    loading: isLoading,
    authenticated: isAuthenticated,
    userEmail: userEmail,
    error: null
  });

  // üÜï NEW: Handle postMessage from OAuth popup
  useEffect(() => {
    const handleOAuthMessage = (event) => {
  console.log('üì¨ Received OAuth message:', event.data);

  // Security: Only accept messages from our backend
  if (event.origin !== 'http://localhost:8080') {
    console.warn('üö´ Ignoring message from unauthorized origin:', event.origin);
    return;
  }

  if (event.data.type === 'OAUTH_SUCCESS') {
    console.log('‚úÖ OAuth success via postMessage:', event.data);
    
    // üîß FIX: Handle different data formats from backend
    const userData = event.data.user_info || event.data.user || {};
    const userEmail = event.data.user_email || userData.email || 'unknown';
    const folders = event.data.folders || [];
    const credentials = event.data.credentials || {};
    
    console.log('üìß User email:', userEmail);
    console.log('üìÅ Folders count:', folders.length);
    
    setAuthState(prev => ({
      ...prev,
      loading: false,
      authenticated: true,
      userEmail: userEmail,
      error: null
    }));

    // Notify parent component with normalized data
    if (onAuth) {
      onAuth({
        success: true,
        user_email: userEmail,
        user_info: userData,
        credentials: credentials,
        folders: folders,
        message: `Authenticated as ${userEmail}`,
        backend_port: event.data.backend_port || 8080
      });
    }

  } else if (event.data.type === 'OAUTH_ERROR') {
    console.error('‚ùå OAuth error via postMessage:', event.data.error);
    
    setAuthState(prev => ({
      ...prev,
      loading: false,
      authenticated: false,
      error: event.data.error
    }));

    if (onAuth) {
      onAuth({
        success: false,
        message: event.data.error || 'Authentication failed',
        error: event.data.details || ''
      });
    }
  }
};

    // Listen for OAuth messages
    window.addEventListener('message', handleOAuthMessage);

    return () => {
      window.removeEventListener('message', handleOAuthMessage);
    };
  }, [onAuth]);

  const handleAuthenticate = async () => {
    if (authState.loading) return;

    try {
      setAuthState(prev => ({ ...prev, loading: true, error: null }));
      console.log('üîê Starting Google Drive authentication...');

      // Step 1: Initiate OAuth flow
      const response = await fetch('http://localhost:8080/api/cloud/authenticate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include', // üîß FIX: Include session cookies
        body: JSON.stringify({
          provider: 'google_drive',
          action: 'initiate_auth',
          redirect_uri: 'http://localhost:8080/api/cloud/oauth/callback' // üîß Explicit redirect
        })
      });

      if (!response.ok) {
        throw new Error(`Authentication request failed: ${response.status}`);
      }

      const authData = await response.json();

      if (!authData.success || !authData.auth_url) {
        throw new Error(authData.message || 'Failed to get authorization URL');
      }

      console.log('üåê Opening OAuth popup...', authData.auth_url);

      // Step 2: Open OAuth popup - IMPROVED with better error handling
      await handleOAuthPopup(authData.auth_url);

    } catch (error) {
      console.error('‚ùå Authentication error:', error);
      setAuthState(prev => ({
        ...prev,
        loading: false,
        error: error.message
      }));

      if (onAuth) {
        onAuth({
          success: false,
          message: error.message || 'Authentication failed'
        });
      }
    }
  };

  // üîß IMPROVED: Better popup handling with COOP workaround
  const handleOAuthPopup = async (authUrl) => {
    return new Promise((resolve, reject) => {
      const popup = window.open(
        authUrl,
        'google_drive_auth',
        'width=600,height=700,scrollbars=yes,resizable=yes,popup=yes'
      );

      if (!popup) {
        reject(new Error('Popup blocked. Please allow popups for this site.'));
        return;
      }

      let checkCompleted = false;

      // üÜï NEW: Use postMessage instead of polling popup.closed (COOP workaround)
      const handlePopupMessage = (event) => {
        if (event.origin !== 'http://localhost:8080') return;
        
        if (event.data.type === 'OAUTH_SUCCESS' || event.data.type === 'OAUTH_ERROR') {
          if (!checkCompleted) {
            checkCompleted = true;
            popup.close();
            window.removeEventListener('message', handlePopupMessage);
            resolve();
          }
        }
      };

      window.addEventListener('message', handlePopupMessage);

      // üîß FALLBACK: Still try to detect popup close, but with error handling
      const checkPopupClosed = () => {
        try {
          if (popup.closed) {
            if (!checkCompleted) {
              checkCompleted = true;
              window.removeEventListener('message', handlePopupMessage);
              
              // Wait a bit for any pending messages
              setTimeout(async () => {
                try {
                  await checkAuthResult();
                  resolve();
                } catch (error) {
                  reject(error);
                }
              }, 1000);
            }
            return;
          }
        } catch (error) {
          // COOP prevents access to popup.closed - this is expected
          console.log('üîí COOP prevents popup.closed check (this is normal)');
        }

        // Continue checking
        if (!checkCompleted) {
          setTimeout(checkPopupClosed, 1000);
        }
      };

      // Start checking after initial delay
      setTimeout(checkPopupClosed, 2000);

      // üîß TIMEOUT: Auto-timeout after 5 minutes
      setTimeout(() => {
        if (!checkCompleted) {
          checkCompleted = true;
          window.removeEventListener('message', handlePopupMessage);
          
          try {
            popup.close();
          } catch (e) {
            // Ignore close errors
          }
          
          reject(new Error('Authentication timeout (5 minutes)'));
        }
      }, 300000);
    });
  };

  // üîß IMPROVED: Better auth result checking with retry logic
  const checkAuthResult = async (maxRetries = 3) => {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`üîç Checking auth result (attempt ${attempt}/${maxRetries})...`);
        
        const response = await fetch('http://localhost:8080/api/cloud/auth-status', {
          credentials: 'include', // üîß FIX: Include session cookies
          cache: 'no-cache'       // üîß FIX: Force fresh request
        });

        if (!response.ok) {
          throw new Error(`Auth status check failed: ${response.status}`);
        }

        const result = await response.json();
        
        if (result.success && result.authenticated) {
          console.log('‚úÖ Authentication confirmed:', result.user_email);
          
          setAuthState(prev => ({
            ...prev,
            loading: false,
            authenticated: true,
            userEmail: result.user_email,
            error: null
          }));

          if (onAuth) {
            onAuth({
              success: true,
              user_email: result.user_email,
              user_info: result.user_info,
              credentials: result.credentials,
              folders: result.folders || [],
              message: `Authenticated as ${result.user_email}`,
              existing_auth: result.existing_auth || false
            });
          }
          
          return;
        } else if (attempt === maxRetries) {
          throw new Error(result.message || 'No authentication found');
        } else {
          // Wait before retrying
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        }
        
      } catch (error) {
        console.error(`‚ùå Auth status check failed (attempt ${attempt}):`, error);
        
        if (attempt === maxRetries) {
          throw error;
        } else {
          // Wait before retrying
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        }
      }
    }
  };

  // üÜï NEW: Disconnect handler
  const handleDisconnect = async () => {
    try {
      setAuthState(prev => ({ ...prev, loading: true }));
      
      const response = await fetch('http://localhost:8080/api/cloud/disconnect', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          provider: 'google_drive',
          user_email: authState.userEmail
        })
      });

      const result = await response.json();
      
      if (result.success) {
        setAuthState({
          loading: false,
          authenticated: false,
          userEmail: null,
          error: null
        });

        if (onAuth) {
          onAuth({
            success: false,
            message: 'Disconnected from Google Drive',
            disconnected: true
          });
        }
      } else {
        throw new Error(result.message || 'Disconnect failed');
      }
      
    } catch (error) {
      console.error('‚ùå Disconnect error:', error);
      setAuthState(prev => ({ ...prev, loading: false, error: error.message }));
    }
  };

  // üîß Handle auth failure
  const handleAuthFailure = (message) => {
    console.error('‚ùå Google Drive authentication failed:', message);
    setAuthState(prev => ({
      ...prev,
      loading: false,
      authenticated: false,
      error: message
    }));
  };

  // Update state when props change
  useEffect(() => {
    setAuthState(prev => ({
      ...prev,
      loading: isLoading,
      authenticated: isAuthenticated,
      userEmail: userEmail
    }));
  }, [isLoading, isAuthenticated, userEmail]);

  // Component render
  return (
    <div className={`google-drive-auth-button ${className}`}>
      {!authState.authenticated ? (
        <div className="auth-section">
          <button
            onClick={handleAuthenticate}
            disabled={authState.loading}
            className={`px-6 py-3 rounded-lg font-medium transition-all duration-200 ${
              authState.loading
                ? 'bg-gray-400 text-gray-600 cursor-not-allowed'
                : 'bg-blue-600 hover:bg-blue-700 text-white shadow-lg hover:shadow-xl transform hover:scale-105'
            }`}
          >
            {authState.loading ? (
              <span className="flex items-center">
                <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Authenticating...
              </span>
            ) : (
              <span className="flex items-center">
                üîê Connect to Google Drive
                <span className="ml-2 text-xs opacity-75">(Required)</span>
              </span>
            )}
          </button>
          
          <div className="mt-2 text-xs text-gray-400">
            Click to authenticate and access your Google Drive folders
          </div>
        </div>
      ) : (
        <div className="authenticated-section">
          <div className="flex items-center justify-between p-4 bg-green-100 border border-green-400 rounded-lg">
            <div className="flex items-center">
              <span className="text-2xl mr-3">‚úÖ</span>
              <div>
                <div className="font-medium text-green-800">
                  Connected to Google Drive
                </div>
                <div className="text-sm text-green-600">
                  {authState.userEmail}
                </div>
              </div>
            </div>
            
            <button
              onClick={handleDisconnect}
              disabled={authState.loading}
              className="px-3 py-1 bg-red-600 hover:bg-red-700 disabled:bg-gray-400 text-white rounded text-sm transition-colors"
            >
              {authState.loading ? 'Disconnecting...' : 'Disconnect'}
            </button>
          </div>
        </div>
      )}

      {/* Error Display */}
      {authState.error && (
        <div className="error-display mt-3 p-3 bg-red-100 border border-red-400 rounded-lg">
          <div className="flex items-center justify-between">
            <div className="text-red-700">
              <div className="font-medium">Authentication Error</div>
              <div className="text-sm mt-1">{authState.error}</div>
            </div>
            <button
              onClick={() => setAuthState(prev => ({ ...prev, error: null }))}
              className="text-red-500 hover:text-red-700 text-lg leading-none"
            >
              √ó
            </button>
          </div>

          {/* Error Actions */}
          <div className="mt-3 flex gap-2">
            <button
              onClick={handleAuthenticate}
              className="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700"
            >
              Try Again
            </button>
            <button
              onClick={() => window.location.reload()}
              className="px-3 py-1 bg-gray-600 text-white rounded text-sm hover:bg-gray-700"
            >
              Refresh Page
            </button>
          </div>
        </div>
      )}

      {/* Help Text */}
      {!authState.authenticated && !authState.error && (
        <div className="help-text mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg">
          <div className="text-sm text-blue-700">
            <div className="font-medium mb-1">üîí Secure Authentication</div>
            <ul className="text-xs space-y-1 ml-4">
              <li>‚Ä¢ Opens Google's official OAuth login</li>
              <li>‚Ä¢ VTrack never sees your Google password</li>
              <li>‚Ä¢ Only folder access permission requested</li>
              <li>‚Ä¢ Can be revoked anytime from Google Account settings</li>
            </ul>
          </div>
        </div>
      )}

      {/* Development Debug Info */}
      {process.env.NODE_ENV === 'development' && (
        <details className="debug-info mt-3 p-2 bg-gray-100 rounded text-xs">
          <summary className="cursor-pointer text-gray-600">üîß Debug Info</summary>
          <pre className="mt-2 text-gray-500 overflow-auto">
            {JSON.stringify({
              authenticated: authState.authenticated,
              loading: authState.loading,
              userEmail: authState.userEmail,
              hasError: !!authState.error,
              errorMessage: authState.error,
              backendPort: 8080
            }, null, 2)}
          </pre>
        </details>
      )}
    </div>
  );
};

export default GoogleDriveAuthButton;
```
## üìÑ File: `CloudSyncSettings.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/CloudSyncSettings.js`

```javascript
// components/config/CloudSyncSettings.js - Focused Sync Configuration
import React, { useState, useEffect } from 'react';

const CloudSyncSettings = ({ config, onChange }) => {
  // Default settings
  const defaultSettings = {
    interval_minutes: 15,
    auto_sync_enabled: true,
    // Hidden/Fixed settings (not shown in UI) - BEST defaults for amature users
    organize_by_date: true,       // Always organize by date - optimal structure
    backup_metadata: true,        // Always preserve metadata - safe approach
    sync_only_new: true,          // Always incremental sync - efficient
    skip_duplicates: true,        // Always skip duplicates - smart behavior
    duplicate_handling: 'compare_size', // Compare by size - best balance
    max_file_size_mb: 1000,       // 30-min video ~1GB at standard quality
    bandwidth_limit_mbps: 10,     // 10 Mbps reasonable for background sync
    file_types: ['.mp4', '.avi', '.mov', '.mkv', '.m4v']
  };

  // Local state
  const [settings, setSettings] = useState({ ...defaultSettings, ...config });
  const [localStorageWarning, setLocalStorageWarning] = useState(false);

  // Sync interval options - focused on practical camera recording frequencies
  const syncIntervals = [
    { value: 5, label: "5 minutes", description: "High-frequency cameras (security)" },
    { value: 15, label: "15 minutes", description: "Standard recording (recommended)" },
    { value: 30, label: "30 minutes", description: "Low-frequency cameras" },
    { value: 60, label: "1 hour", description: "Periodic recording" },
    { value: 180, label: "3 hours", description: "Daily batch cameras" },
    { value: 360, label: "6 hours", description: "Archive/backup mode" }
  ];

  // Check local storage periodically
  useEffect(() => {
    const checkLocalStorage = () => {
      try {
        // Check available disk space (simplified estimation)
        if (navigator.storage && navigator.storage.estimate) {
          navigator.storage.estimate().then(estimate => {
            const usedGB = (estimate.usage || 0) / (1024 ** 3);
            const quotaGB = (estimate.quota || 0) / (1024 ** 3);
            const freeSpaceGB = quotaGB - usedGB;
            
            // Warn if less than 5GB free space
            if (freeSpaceGB < 5) {
              setLocalStorageWarning(true);
            } else {
              setLocalStorageWarning(false);
            }
          });
        }
      } catch (error) {
        console.warn('Could not check storage:', error);
      }
    };

    checkLocalStorage();
    // Check every 5 minutes
    const interval = setInterval(checkLocalStorage, 5 * 60 * 1000);
    
    return () => clearInterval(interval);
  }, []);

  // Update settings and notify parent
  const updateSetting = (key, value) => {
    const newSettings = { ...settings, [key]: value };
    setSettings(newSettings);
    
    if (onChange) {
      onChange(newSettings);
    }
  };

  // Get interval description
  const getIntervalDescription = (minutes) => {
    const interval = syncIntervals.find(i => i.value === minutes);
    return interval ? interval.description : '';
  };

  return (
    <div className="space-y-4">
      
      {/* Local Storage Warning */}
      {localStorageWarning && (
        <div className="bg-yellow-800 border border-yellow-600 rounded-lg p-3">
          <div className="flex items-center gap-2">
            <span className="text-yellow-200">‚ö†Ô∏è</span>
            <div className="text-yellow-200 text-sm">
              <div className="font-medium">Low disk space detected</div>
              <div className="text-xs">Consider freeing up space to continue video sync</div>
            </div>
          </div>
        </div>
      )}

      {/* Sync Frequency */}
      <div className="bg-gray-700 rounded-lg p-4">
        <h4 className="font-medium text-white mb-3">‚è±Ô∏è Sync Frequency</h4>
        
        <div className="space-y-3">
          <div>
            <label className="block text-sm font-medium text-gray-300 mb-2">
              How often should VTrack check for new videos?
            </label>
            <select
              value={settings.interval_minutes}
              onChange={(e) => updateSetting('interval_minutes', parseInt(e.target.value))}
              className="w-full p-3 bg-gray-800 text-white rounded-lg border border-gray-600 focus:border-blue-500"
            >
              {syncIntervals.map(interval => (
                <option key={interval.value} value={interval.value}>
                  {interval.label} - {interval.description}
                </option>
              ))}
            </select>
          </div>
          
          <div className="text-xs text-gray-400 bg-gray-600 p-3 rounded">
            <div className="font-medium mb-1">üí° Sync Frequency Guide:</div>
            <div>‚Ä¢ <strong>5-15 minutes:</strong> Security cameras with frequent recording</div>
            <div>‚Ä¢ <strong>30-60 minutes:</strong> Dashcams, action cameras with periodic recording</div>
            <div>‚Ä¢ <strong>3-6 hours:</strong> Archive cameras or manual uploads</div>
          </div>
        </div>
      </div>

      {/* File Size Limits (Info Only) */}
      <div className="bg-gray-700 rounded-lg p-4">
        <h4 className="font-medium text-white mb-3">üìè File Size Limits</h4>
        
        <div className="space-y-2">
          <div className="flex justify-between text-sm">
            <span className="text-gray-300">Maximum file size:</span>
            <span className="text-white font-medium">{settings.max_file_size_mb} MB</span>
          </div>
          <div className="flex justify-between text-sm">
            <span className="text-gray-300">Supported formats:</span>
            <span className="text-white font-medium">MP4, AVI, MOV, MKV, M4V</span>
          </div>
          <div className="flex justify-between text-sm">
            <span className="text-gray-300">Background bandwidth:</span>
            <span className="text-white font-medium">{settings.bandwidth_limit_mbps} Mbps max</span>
          </div>
        </div>
        
        <div className="text-xs text-gray-400 bg-gray-600 p-3 rounded mt-3">
          <div className="font-medium mb-1">‚ÑπÔ∏è Automatic optimizations:</div>
          <div>‚Ä¢ Videos organized by date folders for easy browsing</div>
          <div>‚Ä¢ Original timestamps and camera info preserved</div>
          <div>‚Ä¢ Duplicate files automatically skipped (smart detection)</div>
          <div>‚Ä¢ Only new files downloaded (incremental sync)</div>
          <div>‚Ä¢ Bandwidth limited to {settings.bandwidth_limit_mbps} Mbps (background mode)</div>
        </div>
      </div>



      {/* Advanced Settings Summary */}
      <div className="bg-gray-800 border border-gray-600 rounded-lg p-4">
        <h4 className="font-medium text-gray-200 mb-3">‚öôÔ∏è Advanced Settings (Auto-Configured)</h4>
        
        <div className="grid grid-cols-2 gap-4 text-xs text-gray-400">
          <div>
            <div className="font-medium text-gray-300 mb-1">File Handling:</div>
            <div>‚Ä¢ Organize by date: {settings.organize_by_date ? 'Yes' : 'No'}</div>
            <div>‚Ä¢ Backup metadata: {settings.backup_metadata ? 'Yes' : 'No'}</div>
            <div>‚Ä¢ Sync only new: {settings.sync_only_new ? 'Yes' : 'No'}</div>
          </div>
          <div>
            <div className="font-medium text-gray-300 mb-1">Performance:</div>
            <div>‚Ä¢ Skip duplicates: {settings.skip_duplicates ? 'Yes' : 'No'}</div>
            <div>‚Ä¢ Duplicate method: {settings.duplicate_handling}</div>
            <div>‚Ä¢ Max file size: {settings.max_file_size_mb}MB</div>
          </div>
        </div>
        
        <div className="mt-3 text-xs text-gray-500">
          üí° These advanced settings are automatically optimized for Google Drive Picker workflow
        </div>
      </div>

      {/* Debug Info (Development) */}
      {process.env.NODE_ENV === 'development' && (
        <details className="bg-gray-800 rounded p-3">
          <summary className="text-xs text-gray-400 cursor-pointer">üîß Debug - Sync Settings</summary>
          <pre className="text-xs text-gray-400 mt-2 overflow-auto">
            {JSON.stringify(settings, null, 2)}
          </pre>
        </details>
      )}
    </div>
  );
};

export default CloudSyncSettings;
```
## üìÑ File: `ProcessingRegionForm.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/ProcessingRegionForm.js`

```javascript
import { useState, useEffect } from "react";
import api from "../../api";
import InstructionsPanel from "./InstructionsPanel";

const ProcessingRegionForm = ({ handleAnalyzeRegions }) => {
  const [videoPath, setVideoPath] = useState("");
  const [selectedVideoPath, setSelectedVideoPath] = useState("");
  const [error, setError] = useState("");
  const [analysisResult, setAnalysisResult] = useState(null);
  const [roiFramePath, setRoiFramePath] = useState("");
  const [showResultModal, setShowResultModal] = useState(false);
  const [cameraList, setCameraList] = useState([]);
  const [selectedCamera, setSelectedCamera] = useState("");
  const [processedCameras, setProcessedCameras] = useState([]);

  useEffect(() => {
    handleGetCameras();
  }, []);

  const handleFileSelect = (e) => {
    const file = e.target.files[0];
    if (file) {
      const path = file.path || file.name;
      setVideoPath(path);
      setSelectedVideoPath(path);
      setError("");
    } else {
      setVideoPath("");
      setSelectedVideoPath("");
    }
  };

  const handleGetCameras = async () => {
    try {
      const response = await api.get("/get-cameras");
      setCameraList(response.data.cameras || []);
      setError("");
    } catch (err) {
      setError("Kh√¥ng th·ªÉ l·∫•y danh s√°ch camera.");
    }
  };

  const handleSelectCamera = (camera) => {
    setSelectedCamera(camera);
    setVideoPath("");
    setSelectedVideoPath("");
    setError("");
  };

  const handleContinue = async () => {
    if (!videoPath && !selectedVideoPath) {
      setError("Vui l√≤ng ch·ªçn video baseline.");
      return;
    }
    if (!selectedCamera) {
      setError("Vui l√≤ng ch·ªçn m·ªôt camera.");
      return;
    }
    try {
      const response = await fetch('http://127.0.0.1:8080/run-select-roi', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ videoPath: selectedVideoPath || videoPath, cameraId: selectedCamera })
      });
      const result = await response.json();
      console.log("Result from run-select-roi:", result);
      if (result.success) {
        const newAnalysisResult = {
          success: true,
          message: result.message || "Hand detection completed successfully",
          roi: result.roi,
          hand_detected: result.hand_detected,
          roi_frame: result.roi_frame
        };
        console.log("Setting analysisResult in handleContinue:", newAnalysisResult);
        setAnalysisResult(newAnalysisResult);
        setRoiFramePath(result.roi_frame); // L∆∞u roiFramePath
        setShowResultModal(true);
      } else {
        setError(result.error || "Kh√¥ng th·ªÉ ch·∫°y hand detection.");
      }
    } catch (err) {
      setError("L·ªói khi ch·∫°y hand detection: " + err.message);
    }
  };

  const handleRetry = async () => {
    if (!selectedVideoPath && !videoPath) {
      setError("Vui l√≤ng ch·ªçn video baseline.");
      return;
    }
    try {
      const response = await fetch('http://127.0.0.1:8080/run-select-roi', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ videoPath: selectedVideoPath || videoPath, cameraId: selectedCamera })
      });
      const result = await response.json();
      console.log("Result from run-select-roi (retry):", result);
      if (result.success) {
        const newAnalysisResult = {
          success: true,
          message: result.message || "Hand detection completed successfully",
          roi: result.roi,
          hand_detected: result.hand_detected,
          roi_frame: result.roi_frame
        };
        console.log("Setting analysisResult in handleRetry:", newAnalysisResult);
        setAnalysisResult(newAnalysisResult);
        setRoiFramePath(result.roi_frame); // C·∫≠p nh·∫≠t roiFramePath v·ªõi file m·ªõi nh·∫•t
        setShowResultModal(true);
      } else {
        setError(result.error || "Kh√¥ng th·ªÉ ch·∫°y hand detection.");
      }
    } catch (err) {
      setError("L·ªói khi ch·∫°y hand detection: " + err.message);
    }
  };

  const handleRoisSubmit = (rois) => {
    setProcessedCameras((prev) => [...new Set([...prev, selectedCamera])]);
    setSelectedCamera("");
  };

  const handleContinueWithAnotherCamera = () => {
    setAnalysisResult(null);
    setRoiFramePath("");
    setShowResultModal(false);
    setSelectedCamera("");
    setVideoPath("");
    setSelectedVideoPath("");
    setError("");
  };

  const handleExit = () => {
    setShowResultModal(false);
    handleAnalyzeRegions({
      success: true,
      message: "ƒê√£ ho√†n t·∫•t x·ª≠ l√Ω c√°c camera.",
      processedCameras,
    });
  };

  return (
    <div className="w-[25%] bg-gray-800 p-6 rounded-lg flex flex-col">
      <h1 className="text-3xl font-bold mb-4">V√πng x·ª≠ l√Ω</h1>
      <p className="text-gray-300 mb-4">
        T·∫£i l√™n video baseline (5s-5 ph√∫t) ƒë·ªÉ x√°c ƒë·ªãnh c√°c v√πng x·ª≠ l√Ω QR v√† ƒë√≥ng g√≥i.
      </p>
      <div className="mb-4">
        <button
          onClick={handleGetCameras}
          className="w-full py-2 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded"
        >
          L·∫•y danh s√°ch camera
        </button>
      </div>
      {cameraList && cameraList.length > 0 && (
        <div className="mb-4">
          <h3 className="text-lg font-bold mb-2">Ch·ªçn camera:</h3>
          <div className="max-h-24 overflow-y-auto">
            {cameraList.map((camera) => (
              <label key={camera} className="flex items-center mb-2">
                <input
                  type="radio"
                  name="camera"
                  className="mr-2"
                  checked={selectedCamera === camera}
                  onChange={() => handleSelectCamera(camera)}
                  disabled={processedCameras.includes(camera)}
                />
                {camera}
                {processedCameras.includes(camera) && (
                  <span className="ml-2 text-green-500">‚úî ƒê√£ x·ª≠ l√Ω</span>
                )}
              </label>
            ))}
          </div>
        </div>
      )}
      <div className="mb-4">
        <label className="block mb-1">Video baseline:</label>
        <div className="relative w-full">
          <input
            type="text"
            value={videoPath}
            onChange={(e) => {
              setVideoPath(e.target.value);
              setSelectedVideoPath(e.target.value);
            }}
            placeholder="Ch·ªçn video (e.g., /Users/annhu/vtrack_app/V_Track/baseline.mp4)"
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
          <button
            type="button"
            onClick={() => {
              const input = document.createElement("input");
              input.type = "file";
              input.accept = "video/*";
              input.onchange = handleFileSelect;
              input.click();
            }}
            className="absolute right-2 top-1/2 transform -translate-y-1/2 text-white"
          >
            ...
          </button>
        </div>
      </div>
      {videoPath && selectedCamera && (
        <div className="mb-4 flex justify-center">
          <button
            onClick={handleContinue}
            className="py-2 px-4 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded"
          >
            Ti·∫øp t·ª•c
          </button>
        </div>
      )}
      {showResultModal && analysisResult && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-gray-800 p-6 rounded-lg w-3/4 h-3/4 flex">
            <InstructionsPanel
              customInstruction={
                analysisResult.qr_detected
                  ? "Ti·∫øp t·ª•c x√°c ƒë·ªãnh v√πng trigger."
                  : "V·∫Ω l·∫°i v√πng m√£ v·∫≠n ƒë∆°n ho·∫∑c nh·∫•n Ti·∫øp t·ª•c ƒë·ªÉ ƒë·ªìng √Ω v·ªõi v√πng hi·ªán t·∫°i."
              }
              analysisResult={analysisResult}
              handDetected={analysisResult.hand_detected}
              qrDetected={analysisResult.qr_detected}
              onClose={handleExit}
              onSave={handleContinueWithAnotherCamera}
              onRetry={handleRetry}
              errorMessage={error}
              videoPath={selectedVideoPath || videoPath}
              cameraId={selectedCamera}
              onSubmit={handleRoisSubmit}
              setAnalysisResult={setAnalysisResult}
              roiFramePath={roiFramePath}
            />
          </div>
        </div>
      )}
      {error && (
        <div className="mb-4 text-red-500 text-sm">{error}</div>
      )}
    </div>
  );
};

export default ProcessingRegionForm;

```
## üìÑ File: `AddSourceModal.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/AddSourceModal.js`

```javascript
// components/config/AddSourceModal.js - Drive API Simple Approach
import React, { useState } from 'react';
import CloudConfigurationForm from './CloudConfigurationForm';
import GoogleDriveAuthButton from './GoogleDriveAuthButton';
import CloudSyncSettings from './CloudSyncSettings';
import GoogleDriveFolderTree from './GoogleDriveFolderTree';

const AddSourceModal = ({ show, onClose, onAdd, testSourceConnection }) => {
 const [sourceType, setSourceType] = useState('local');
 const [path, setPath] = useState('');
 const [config, setConfig] = useState({});
 const [isLoading, setIsLoading] = useState(false);
 const [testResult, setTestResult] = useState(null);
 
 // üÜï NVR-specific states
 const [nvrCameras, setNvrCameras] = useState([]);
 const [selectedNvrCameras, setSelectedNvrCameras] = useState([]);
 const [isDiscoveringCameras, setIsDiscoveringCameras] = useState(false);

 // üÜï Cloud-specific states
 const [cloudAuthenticated, setCloudAuthenticated] = useState(false);
 const [authLoading, setAuthLoading] = useState(false);
 const [availableFolders, setAvailableFolders] = useState([]); // Keep for compatibility
 const [selectedFolders, setSelectedFolders] = useState([]); // Now handled by tree component
 const [treeFoldersSelected, setTreeFoldersSelected] = useState([]); // New: Tree selection

 const generateSourceName = (path, sourceType) => {
   if (!path) return '';
   
   if (sourceType === 'nvr') {
     // Extract hostname or IP from URL
     try {
       const url = new URL(path.startsWith('http') ? path : `http://${path}`);
       const hostname = url.hostname || path;
       return `nvr_${hostname.replace(/\./g, '_')}`;
     } catch {
       const cleanPath = path.replace(/[^\w\d]/g, '_');
       return `nvr_${cleanPath}`;
     }
   } else if (sourceType === 'cloud') {
     // Cloud source name based on selected folders
     const provider = config.provider || 'google_drive';
     const folderName = selectedFolders.length > 0 ? 'multiple_folders' : 'cloud_storage';
     return `${provider}_${folderName.replace(/[^\w\d]/g, '_')}`;
   } else {
     const folderName = path.split('/').pop() || path.split('\\').pop() || 'source';
     return `${sourceType}_${folderName}`;
   }
 };

 const resetForm = () => {
   setSourceType('local');
   setPath('');
   setConfig({});
   setTestResult(null);
   setNvrCameras([]);
   setSelectedNvrCameras([]);
   // Reset cloud states
   setCloudAuthenticated(false);
   setAvailableFolders([]);
   setSelectedFolders([]);
   setTreeFoldersSelected([]);
 };

 // üîß Enhanced validation for NVR (ZM credentials optional)
 const validateNvrConfig = () => {
   if (!config.url) {
     return { valid: false, message: 'Please enter NVR address first' };
   }
   
   // For ZoneMinder, credentials are optional
   if (config.protocol === 'zoneminder') {
     return { valid: true, message: 'Ready to test (ZM auth optional)' };
   }
   
   // For other protocols, credentials required
   if (!config.username || !config.password) {
     return { valid: false, message: 'Please fill in username and password for this protocol' };
   }
   
   return { valid: true, message: 'Ready to test' };
 };

 // üÜï Google Drive Authentication Handler
 const handleGoogleDriveAuth = async (authResult) => {
   if (authResult.success) {
     setCloudAuthenticated(true);
     
     setConfig(prev => ({
       ...prev,
       provider: 'google_drive',
       credentials: authResult.credentials,
       user_email: authResult.user_email
     }));

     // Store root folders for tree initialization (lazy loading enabled)
      if (authResult.lazy_loading_enabled) {
        console.log('‚úÖ Lazy loading tree enabled');
        // Root folders will be handled by GoogleDriveFolderTree component
      } else if (authResult.folders && authResult.folders.length > 0) {
        setAvailableFolders(authResult.folders);
      }
     
   }
 };

 // üÜï Folder Selection Handler
 const handleFolderToggle = (folder) => {
   setSelectedFolders(prev => {
     const isSelected = prev.some(f => f.id === folder.id);
     if (isSelected) {
       return prev.filter(f => f.id !== folder.id);
     } else {
       return [...prev, folder];
     }
   });
 };

 // üÜï Select All/None Handlers
 const handleSelectAllFolders = () => {
   setSelectedFolders([...availableFolders]);
 };

 const handleDeselectAllFolders = () => {
   setSelectedFolders([]);
 };

 const handleTreeFolderSelection = (selectedTreeFolders) => {
  setTreeFoldersSelected(selectedTreeFolders);
  console.log(`üìÅ Tree selection updated: ${selectedTreeFolders.length} folders`);
 };

 // üÜï Cloud Sync Settings Handler
 const handleCloudSyncSettings = (syncConfig) => {
   setConfig(prev => ({
     ...prev,
     sync_settings: syncConfig
   }));
 };

 const handleTestConnection = async () => {
   if (sourceType === 'local' && !path) {
     alert('Please enter a path first');
     return;
   }

   if (sourceType === 'nvr') {
     const validation = validateNvrConfig();
     if (!validation.valid) {
       alert(validation.message);
       return;
     }
   }

   setIsLoading(true);
   setIsDiscoveringCameras(true);
   setTestResult(null);
   setNvrCameras([]);
   
   try {
     const testData = {
       source_type: sourceType,
       path: sourceType === 'local' ? path : config.url,
       config: sourceType === 'nvr' ? {
         ...config,
         protocol: config.protocol || 'zoneminder',
         username: config.username || '',
         password: config.password || ''
       } : config
     };

     const response = await testSourceConnection(testData);
     
     setTestResult({
       success: response.accessible,
       message: response.message
     });

     // Handle NVR camera discovery
     if (response.accessible && sourceType === 'nvr' && response.cameras) {
       setNvrCameras(response.cameras);
       setSelectedNvrCameras(response.cameras.map(cam => cam.name || cam.id || `Camera ${response.cameras.indexOf(cam) + 1}`));
       
       setTestResult(prev => ({
         ...prev,
         message: `${prev.message} - Found ${response.cameras.length} camera(s)`
       }));
     }
     
   } catch (error) {
     setTestResult({
       success: false,
       message: error.message || 'Connection test failed'
     });
   } finally {
     setIsLoading(false);
     setIsDiscoveringCameras(false);
   }
 };

 // NVR Camera Selection Handler
 const handleNvrCameraToggle = (cameraName) => {
   setSelectedNvrCameras(prev => 
     prev.includes(cameraName) 
       ? prev.filter(name => name !== cameraName)
       : [...prev, cameraName]
   );
 };

 const handleSubmit = (e) => {
   e.preventDefault();
   
   if (sourceType === 'local' && !path) {
     alert('Please enter a path');
     return;
   }
   
   if (sourceType === 'nvr') {
     const validation = validateNvrConfig();
     if (!validation.valid) {
       alert(validation.message);
       return;
     }
   }

   // üÜï Cloud submission validation - SIMPLIFIED
   if (sourceType === 'cloud') {
     if (!cloudAuthenticated) {
       alert('Please authenticate with Google Drive first');
       return;
     }
     if (treeFoldersSelected.length === 0) {
       alert('Please select at least one folder to monitor');
       return;
     }
   }

   const autoName = generateSourceName(
     sourceType === 'local' ? path : 
     sourceType === 'cloud' ? `google_drive://selected_folders` :
     config.url || 'nvr', 
     sourceType
   );

   const newSource = {
     source_type: sourceType,
     name: autoName,
     path: sourceType === 'local' ? path : 
           sourceType === 'cloud' ? `google_drive://selected_folders` :
           config.url,
     config: sourceType === 'nvr' ? {
       ...config,
       protocol: config.protocol || 'zoneminder',
       username: config.username || '',
       password: config.password || '',
       detected_cameras: nvrCameras,
       selected_cameras: selectedNvrCameras
     } : sourceType === 'cloud' ? {
       ...config,
       provider: 'google_drive',
       selected_folders: [...selectedFolders, ...treeFoldersSelected], // Combine both selections
       selected_tree_folders: treeFoldersSelected, // Store tree selections separately
       legacy_folders: selectedFolders, // Keep legacy for compatibility
       sync_settings: config.sync_settings || {
         interval_minutes: 15,
         auto_sync_enabled: true,
         sync_only_new: true,
         skip_duplicates: true
       }
     } : {}
   };

   onAdd(newSource);
   resetForm();
   onClose();
 };

 if (!show) return null;

 return (
   <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
     <div className="bg-gray-800 rounded-lg p-6 w-full max-w-4xl mx-4 max-h-[90vh] overflow-y-auto">
       <div className="flex justify-between items-center mb-6">
         <h3 className="text-xl font-bold text-white">Add New Video Source</h3>
         <button
           onClick={onClose}
           className="text-gray-400 hover:text-white text-2xl"
         >
           √ó
         </button>
       </div>

       <form onSubmit={handleSubmit}>
         {/* Source Type Cards */}
         <div className="grid grid-cols-1 lg:grid-cols-3 gap-4 mb-6">
           
           {/* Local Storage Card */}
           <div 
             className={`border-2 rounded-lg p-4 cursor-pointer transition-all ${
               sourceType === 'local' 
                 ? 'border-blue-500 bg-blue-900' 
                 : 'border-gray-600 bg-gray-700 hover:border-gray-500'
             }`}
             onClick={() => setSourceType('local')}
           >
             <div className="flex items-center mb-3">
               <span className="text-3xl mr-3">üìÅ</span>
               <div>
                 <h4 className="font-semibold text-white text-lg">Browse Files Directly</h4>
                 <p className="text-sm text-gray-300">Access folders containing videos</p>
               </div>
             </div>
             <div className="text-xs text-gray-400 leading-relaxed">
               ‚Ä¢ Local server folders<br/>
               ‚Ä¢ Mounted network drives (NAS, SMB, NFS)<br/>
               ‚Ä¢ Mounted NVR file shares<br/>
               ‚Ä¢ Any accessible folder path<br/>
               <span className="text-yellow-300 font-medium">üìç Mount network sources first</span>
             </div>
           </div>

           {/* NVR/DVR Card */}
           <div 
             className={`border-2 rounded-lg p-4 cursor-pointer transition-all ${
               sourceType === 'nvr' 
                 ? 'border-blue-500 bg-blue-900' 
                 : 'border-gray-600 bg-gray-700 hover:border-gray-500'
             }`}
             onClick={() => setSourceType('nvr')}
           >
             <div className="flex items-center mb-3">
               <span className="text-3xl mr-3">üîó</span>
               <div>
                 <h4 className="font-semibold text-white text-lg">Connect & Auto-Download</h4>
                 <p className="text-sm text-gray-300">Direct NVR/DVR camera discovery</p>
               </div>
             </div>
             <div className="text-xs text-gray-400 leading-relaxed">
               ‚Ä¢ NVR/DVR systems (ONVIF)<br/>
               ‚Ä¢ IP Camera networks (RTSP)<br/>
               ‚Ä¢ Security management platforms<br/>
               ‚Ä¢ Auto-discover cameras<br/>
               <span className="text-green-300 font-medium">üîÑ Real-time camera detection</span>
             </div>
           </div>

           {/* üÜï Cloud Storage Card - SIMPLIFIED */}
           <div 
             className={`border-2 rounded-lg p-4 cursor-pointer transition-all ${
               sourceType === 'cloud' 
                 ? 'border-blue-500 bg-blue-900' 
                 : 'border-gray-600 bg-gray-700 hover:border-gray-500'
             }`}
             onClick={() => setSourceType('cloud')}
           >
             <div className="flex items-center mb-3">
               <span className="text-3xl mr-3">‚òÅÔ∏è</span>
               <div>
                 <h4 className="font-semibold text-white text-lg">Google Drive Integration</h4>
                 <p className="text-sm text-gray-300">Sync videos from cloud storage</p>
               </div>
             </div>
             <div className="text-xs text-gray-400 leading-relaxed">
               ‚Ä¢ Google Drive camera folders<br/>
               ‚Ä¢ Auto-sync new recordings<br/>
               ‚Ä¢ Simple folder selection<br/>
               ‚Ä¢ Background download to server<br/>
               <span className="text-green-300 font-medium">‚úÖ Simplified & Reliable!</span>
             </div>
           </div>
         </div>

         {/* Local Files Form */}
         {sourceType === 'local' && (
           <div className="bg-gray-700 rounded-lg p-6 mb-6">
             <h4 className="font-semibold text-white mb-4 text-lg">üìÅ Browse Files Directly Configuration</h4>
             
             <div className="bg-yellow-800 border border-yellow-600 rounded-lg p-4 mb-6">
               <div className="text-yellow-200">
                 <div className="font-semibold mb-2">üìç Network Storage Setup Guide:</div>
                 <div className="text-sm mb-2">For network sources (NAS, NVR file shares), mount them first:</div>
                 <div className="font-mono text-xs bg-black bg-opacity-30 p-2 rounded">
                   # SMB Example (NAS/NVR):<br/>
                   mount -t smbfs //server/share /mnt/folder<br/><br/>
                   # NFS Example:<br/>
                   mount -t nfs server:/export /mnt/folder
                 </div>
               </div>
             </div>

             <div className="mb-4">
               <label className="block text-sm font-medium text-gray-300 mb-2">
                 Folder Path *
               </label>
               <input
                 type="text"
                 value={path}
                 onChange={(e) => setPath(e.target.value)}
                 placeholder="/Users/videos or /mnt/nas-storage or /mnt/nvr-files"
                 className="w-full p-3 border border-gray-600 rounded-lg bg-gray-800 text-white text-sm"
                 required
               />
               <div className="text-xs text-gray-400 mt-2">
                 Local path or mounted network folder containing camera subfolders
               </div>
             </div>

             {path && (
               <div className="bg-gray-600 p-4 rounded-lg">
                 <div className="text-xs text-gray-400 mb-1">Auto-generated source name:</div>
                 <div className="text-lg text-white font-medium">{generateSourceName(path, sourceType)}</div>
               </div>
             )}
           </div>
         )}

         {/* NVR/DVR Form */}
         {sourceType === 'nvr' && (
           <div className="bg-gray-700 rounded-lg p-6 mb-6">
             <h4 className="font-semibold text-white mb-4 text-lg">üîó NVR/DVR Connection Configuration</h4>

             {/* Protocol & URL Row */}
             <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
               <div>
                 <label className="block text-sm font-medium text-gray-300 mb-2">
                   Protocol *
                 </label>
                 <select
                   value={config.protocol || 'zoneminder'}
                   onChange={(e) => setConfig(prev => ({...prev, protocol: e.target.value}))}
                   className="w-full p-3 border border-gray-600 rounded-lg bg-gray-800 text-white"
                   required
                 >
                   <option value="zoneminder">ZoneMinder API (Open Source NVR)</option>
                   <option value="onvif">ONVIF (Universal Standard)</option>
                   <option value="rtsp">RTSP Direct Stream</option>
                   <option value="hikvision">Hikvision API</option>
                   <option value="dahua">Dahua API</option>
                   <option value="generic">Generic HTTP API</option>
                 </select>
               </div>

               <div>
                 <label className="block text-sm font-medium text-gray-300 mb-2">
                   NVR/DVR Address *
                 </label>
                 <input
                   type="text"
                   value={config.url || ''}
                   onChange={(e) => setConfig(prev => ({...prev, url: e.target.value}))}
                   placeholder="localhost:5050 or 192.168.1.100:8080"
                   className="w-full p-3 border border-gray-600 rounded-lg bg-gray-800 text-white"
                   required
                 />
               </div>
             </div>

             {/* Credentials Section */}
             <div className="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
               <div>
                 <label className="block text-sm font-medium text-gray-300 mb-2">
                   Username {config.protocol === 'zoneminder' ? '(Optional)' : '*'}
                 </label>
                 <input
                   type="text"
                   value={config.username || ''}
                   onChange={(e) => setConfig(prev => ({...prev, username: e.target.value}))}
                   placeholder={config.protocol === 'zoneminder' ? 'admin (leave blank if no auth)' : 'admin'}
                   className="w-full p-3 border border-gray-600 rounded-lg bg-gray-800 text-white"
                   required={config.protocol !== 'zoneminder'}
                 />
               </div>

               <div>
                 <label className="block text-sm font-medium text-gray-300 mb-2">
                   Password {config.protocol === 'zoneminder' ? '(Optional)' : '*'}
                 </label>
                 <input
                   type="password"
                   value={config.password || ''}
                   onChange={(e) => setConfig(prev => ({...prev, password: e.target.value}))}
                   placeholder={config.protocol === 'zoneminder' ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢  (leave blank if no auth)' : '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢'}
                   className="w-full p-3 border border-gray-600 rounded-lg bg-gray-800 text-white"
                   required={config.protocol !== 'zoneminder'}
                 />
               </div>
             </div>

             {/* Discovered Cameras Section */}
             {testResult?.success && nvrCameras.length > 0 && (
               <div className="mb-6">
                 <div className="flex items-center justify-between mb-3">
                   <h5 className="font-medium text-white">üìπ Discovered Cameras ({nvrCameras.length})</h5>
                 </div>
                 <div className="flex gap-2 mb-2">
                   <button
                     type="button"
                     onClick={() => setSelectedNvrCameras(nvrCameras.map(cam => cam.name || cam.id || `Camera ${nvrCameras.indexOf(cam) + 1}`))}
                     className="px-3 py-1 bg-blue-600 text-white rounded text-xs"
                   >
                     Select All
                   </button>
                   <button
                     type="button"
                     onClick={() => setSelectedNvrCameras([])}
                     className="px-3 py-1 bg-gray-600 text-white rounded text-xs"
                   >
                     Deselect All
                   </button>
                 </div>
                 
                 <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3 p-4 bg-gray-600 rounded-lg max-h-48 overflow-y-auto">
                   {nvrCameras.map((camera, index) => {
                     const cameraName = camera.name || camera.id || `Camera ${index + 1}`;
                     
                     return (
                       <label 
                         key={cameraName}
                         className="flex items-start space-x-3 p-2 bg-gray-700 rounded cursor-pointer hover:bg-gray-650"
                       >
                         <input
                           type="checkbox"
                           checked={selectedNvrCameras.includes(cameraName)}
                           onChange={() => handleNvrCameraToggle(cameraName)}
                           className="mt-1"
                         />
                         <div className="flex-1 min-w-0">
                           <div className="text-white text-sm font-medium truncate">
                             {cameraName}
                           </div>
                           {camera.stream_url && (
                             <div className="text-xs text-gray-400 truncate">
                               Stream: {camera.stream_url}
                             </div>
                           )}
                         </div>
                       </label>
                     );
                   })}
                 </div>
               </div>
             )}

             {/* Source Name Preview */}
             {config.url && (
               <div className="bg-gray-600 p-4 rounded-lg">
                 <div className="text-xs text-gray-400 mb-1">Auto-generated source name:</div>
                 <div className="text-lg text-white font-medium">{generateSourceName(config.url, sourceType)}</div>
               </div>
             )}
           </div>
         )}

         {/* üÜï Cloud Storage Form - SIMPLIFIED */}
         {sourceType === 'cloud' && (
           <div className="bg-gray-700 rounded-lg p-6 mb-6">
             <h4 className="font-semibold text-white mb-4 text-lg">‚òÅÔ∏è Google Drive Integration Configuration</h4>
             
             {/* Step 1: Authentication */}
             <div className="mb-6">
               <h5 className="font-medium text-white mb-3">Step 1: Authenticate with Google Drive</h5>
               <GoogleDriveAuthButton 
                 onAuth={handleGoogleDriveAuth}
                 isAuthenticated={cloudAuthenticated}
                 isLoading={authLoading}
                 userEmail={config?.user_email}
               />
             </div>

              {/* Step 2: Folder Selection */}
              {cloudAuthenticated && (
                <div className="mb-6">
                  <h5 className="font-medium text-white mb-3">Step 2: Navigate & Select Camera Folders</h5>
                  
                  <GoogleDriveFolderTree
                    credentials={config?.credentials}
                    onFoldersSelected={handleTreeFolderSelection}
                    maxDepth={4}
                    selectableDepth={4}
                    className="border border-gray-600 rounded-lg"
                  />
                </div>
              )}

             {/* Step 3: Sync Settings */}
             {cloudAuthenticated && treeFoldersSelected.length > 0 && (
               <div className="mb-6">
                 <h5 className="font-medium text-white mb-3">Step 3: Configure Sync Settings</h5>
                 <CloudSyncSettings
                   config={config.sync_settings || {
                     interval_minutes: 15,
                     auto_sync_enabled: true,
                     sync_only_new: true,
                     skip_duplicates: true
                   }}
                   onChange={handleCloudSyncSettings}
                 />
               </div>
             )}

             {/* Source Name Preview */}
             {treeFoldersSelected.length > 0 && (
               <div className="bg-gray-600 p-4 rounded-lg">
                 <div className="text-xs text-gray-400 mb-1">Auto-generated source name:</div>
                 <div className="text-lg text-white font-medium">{generateSourceName(`google_drive://selected_folders`, sourceType)}</div>
                 <div className="text-xs text-gray-400 mt-2">
                    {treeFoldersSelected.length} folders selected for monitoring
                  </div>
               </div>
             )}
           </div>
         )}

         {/* Test Connection - CH·ªà CHO LOCAL/NVR */}
         {(sourceType === 'local' || sourceType === 'nvr') && (
           <div className="mb-6">
             <button
               type="button"
               onClick={handleTestConnection}
               disabled={isLoading || 
                 (sourceType === 'local' && !path) || 
                 (sourceType === 'nvr' && !validateNvrConfig().valid)
               }
               className="bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 text-white px-6 py-3 rounded-lg font-medium mr-4"
             >
               {isLoading ? (
                 <span className="flex items-center">
                   <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" fill="none" viewBox="0 0 24 24">
                     <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                     <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                   </svg>
                   {sourceType === 'nvr' ? 'Discovering Cameras...' : 'Testing...'}
                 </span>
               ) : (
                 'Test Connection'
               )}
             </button>
             
             {testResult && (
               <div className={`inline-block p-4 rounded-lg text-sm ${
                 testResult.success 
                   ? 'bg-green-800 text-green-200 border border-green-600' 
                   : 'bg-red-800 text-red-200 border border-red-600'
               }`}>
                 <div className="font-medium mb-1">
                   {testResult.success ? '‚úÖ Connection Successful' : '‚ùå Connection Failed'}
                 </div>
                 <div>{testResult.message}</div>
               </div>
             )}
           </div>
         )}

         {/* Action Buttons - UPDATED CONDITIONS */}
         <div className="flex gap-4 pt-4 border-t border-gray-600">
           <button
             type="submit"
             disabled={
               (sourceType === 'local' && !path) ||
               (sourceType === 'nvr' && !testResult?.success) ||
               (sourceType === 'cloud' && (!cloudAuthenticated || treeFoldersSelected.length === 0))
             }
             className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white px-8 py-3 rounded-lg font-medium flex-1"
           >
             Add Source
           </button>
           <button
             type="button"
             onClick={() => {
               resetForm();
               onClose();
             }}
             className="bg-gray-600 hover:bg-gray-700 text-white px-8 py-3 rounded-lg font-medium flex-1"
           >
             Cancel
           </button>
         </div>
       </form>
     </div>
   </div>
 );
};

export default AddSourceModal;
```
## üìÑ File: `GoogleDriveFolderTree.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/GoogleDriveFolderTree.js`

```javascript
// components/config/GoogleDriveFolderTree.js - Fixed Selection UI
import React, { useState, useEffect, useCallback } from 'react';

const GoogleDriveFolderTree = ({ 
  credentials, 
  onFoldersSelected, 
  maxDepth = 4, 
  selectableDepth = 4,
  className = ''
}) => {
  // Tree state management
  const [treeData, setTreeData] = useState({});
  const [expandedFolders, setExpandedFolders] = useState(new Set(['root']));
  const [selectedFolders, setSelectedFolders] = useState([]);
  const [loadingFolders, setLoadingFolders] = useState(new Set());
  const [error, setError] = useState(null);
  const [breadcrumb, setBreadcrumb] = useState([]);

  // Initialize with root folders
  useEffect(() => {
    if (credentials) {
      loadRootFolders();
    }
  }, [credentials]);

  // Notify parent when selection changes
  useEffect(() => {
    if (onFoldersSelected) {
      onFoldersSelected(selectedFolders);
    }
  }, [selectedFolders, onFoldersSelected]);

  const loadRootFolders = async () => {
    try {
      setLoadingFolders(prev => new Set([...prev, 'root']));
      setError(null);

      const response = await fetch('http://localhost:8080/api/cloud/folders/list_subfolders', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          parent_id: 'root',
          max_results: 50
        })
      });

      if (!response.ok) {
        throw new Error(`Failed to load root folders: ${response.status}`);
      }

      const data = await response.json();

      if (!data.success) {
        throw new Error(data.message || 'Failed to load root folders');
      }

      // Initialize tree with root data
      setTreeData({
        'root': {
          id: 'root',
          name: 'My Drive',
          depth: 0,
          selectable: false,
          has_subfolders: true,
          children: data.folders,
          loaded: true
        }
      });

      console.log(`‚úÖ Loaded ${data.folders.length} root folders`);

    } catch (error) {
      console.error('‚ùå Error loading root folders:', error);
      setError(error.message);
    } finally {
      setLoadingFolders(prev => {
        const next = new Set(prev);
        next.delete('root');
        return next;
      });
    }
  };

  const loadSubfolders = async (parentId) => {
    try {
      setLoadingFolders(prev => new Set([...prev, parentId]));
      setError(null);

      const response = await fetch('http://localhost:8080/api/cloud/folders/list_subfolders', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          parent_id: parentId,
          max_results: 50
        })
      });

      if (!response.ok) {
        throw new Error(`Failed to load subfolders: ${response.status}`);
      }

      const data = await response.json();

      if (!data.success) {
        throw new Error(data.message || 'Failed to load subfolders');
      }

      // Update tree data
      setTreeData(prev => ({
        ...prev,
        [parentId]: {
          ...prev[parentId],
          children: data.folders,
          loaded: true
        }
      }));

      console.log(`‚úÖ Loaded ${data.folders.length} subfolders for ${parentId}`);

    } catch (error) {
      console.error(`‚ùå Error loading subfolders for ${parentId}:`, error);
      setError(error.message);
    } finally {
      setLoadingFolders(prev => {
        const next = new Set(prev);
        next.delete(parentId);
        return next;
      });
    }
  };

  const handleFolderExpand = useCallback(async (event, folder) => {
    // üîß FIX: Stop event propagation to prevent triggering selection
    event.stopPropagation();
    event.preventDefault();
    
    const folderId = folder.id;
    
    console.log(`üîΩ Expand/collapse action for: ${folder.name}`);
    
    if (expandedFolders.has(folderId)) {
      // Collapse folder
      setExpandedFolders(prev => {
        const next = new Set(prev);
        next.delete(folderId);
        return next;
      });
      console.log(`üìÅ Collapsed: ${folder.name}`);
    } else {
      // Expand folder
      setExpandedFolders(prev => new Set([...prev, folderId]));
      console.log(`üìÇ Expanded: ${folder.name}`);
      
      // Load subfolders if not already loaded
      if (folder.has_subfolders && (!treeData[folderId] || !treeData[folderId].loaded)) {
        await loadSubfolders(folderId);
      }
    }
  }, [expandedFolders, treeData]);

  const handleFolderSelect = useCallback((event, folder) => {
    // üîß FIX: Stop event propagation for checkbox clicks
    event.stopPropagation();
    
    console.log(`üîç Folder selection attempt:`, folder.name, `Depth: ${folder.depth}`, `Selectable: ${folder.selectable}`);
    
    const folderId = folder.id;
    
    setSelectedFolders(prev => {
      const isSelected = prev.some(f => f.id === folderId);
      if (isSelected) {
        console.log(`‚ùå Deselecting folder: ${folder.name}`);
        return prev.filter(f => f.id !== folderId);
      } else {
        console.log(`‚úÖ Selecting folder: ${folder.name}`);
        return [...prev, folder];
      }
    });
  }, []);

  const handleDeselectAll = useCallback(() => {
    console.log('üóëÔ∏è Clearing all selections');
    setSelectedFolders([]);
  }, []);

  const renderFolderIcon = (folder, isExpanded, isLoading) => {
    if (isLoading) {
      return (
        <svg className="animate-spin h-4 w-4 text-blue-400" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
      );
    }

    if (folder.has_subfolders) {
      return isExpanded ? '‚ñº' : '‚ñ∂';
    }
    return 'üìÅ';
  };

  const renderFolderNode = (folder, depth = 0) => {
    const isExpanded = expandedFolders.has(folder.id);
    const isLoading = loadingFolders.has(folder.id);
    const isSelected = selectedFolders.some(f => f.id === folder.id);
    const hasSubfolders = folder.has_subfolders;
    
    // üîß FIX: Show checkbox for ALL folders, not just selectable ones (for testing)
    // Later we can restrict to depth === selectableDepth
    const showCheckbox = true; // folder.depth === selectableDepth || folder.selectable;

    return (
      <div key={folder.id} className="folder-node">
        {/* Folder Row */}
        <div 
          className={`flex items-center py-2 px-3 hover:bg-gray-600 rounded transition-colors ${
            isSelected ? 'bg-blue-600' : ''
          }`}
          style={{ paddingLeft: `${depth * 20 + 12}px` }}
        >
          {/* Expand/Collapse Button */}
          <button
            type="button"
            onClick={(e) => handleFolderExpand(e, folder)}
            disabled={isLoading || !hasSubfolders}
            className={`mr-2 w-6 h-6 flex items-center justify-center text-sm ${
              hasSubfolders ? 'text-gray-300 hover:text-white cursor-pointer' : 'text-gray-500 cursor-default'
            }`}
          >
            {renderFolderIcon(folder, isExpanded, isLoading)}
          </button>

          {/* Selection Checkbox - üîß FIX: Always show for testing */}
          {showCheckbox && (
            <input
              type="checkbox"
              checked={isSelected}
              onChange={(e) => handleFolderSelect(e, folder)}
              className="mr-3 h-4 w-4 text-blue-600 rounded border-gray-600 bg-gray-700"
            />
          )}

          {/* Folder Info */}
          <div className="flex-1 min-w-0">
            <div className={`text-sm truncate ${
              folder.depth === selectableDepth 
                ? 'text-white font-medium' 
                : 'text-gray-300'
            }`}>
              {folder.name}
            </div>
            <div className="text-xs text-gray-400">
              {folder.path && `${folder.path}`}
            </div>
          </div>


        </div>

        {/* Child Folders */}
        {isExpanded && treeData[folder.id] && treeData[folder.id].children && (
          <div className="children">
            {treeData[folder.id].children.map(childFolder => 
              renderFolderNode(childFolder, depth + 1)
            )}
          </div>
        )}
      </div>
    );
  };

  if (!credentials) {
    return (
      <div className="text-center py-8 text-gray-400">
        <div className="text-lg mb-2">üîê</div>
        <div>Please authenticate with Google Drive first</div>
      </div>
    );
  }

  return (
    <div className={`google-drive-folder-tree ${className}`}>
      {/* Header */}
      <div className="flex items-center justify-between mb-4">
        <h4 className="font-medium text-white">üìÅ Navigate & Select Camera Folders</h4>
        <div className="flex gap-2">
          <button
            type="button"
            onClick={(e) => {
              e.stopPropagation();
              e.preventDefault();
              handleDeselectAll();
            }}
            className="px-3 py-1 bg-gray-600 text-white rounded text-xs hover:bg-gray-700"
          >
            Clear All
          </button>
        </div>
      </div>

      {/* Selection Summary */}
      {selectedFolders.length > 0 && (
        <div className="mb-4 p-3 bg-green-800 border border-green-600 rounded-lg">
          <div className="text-green-200 text-sm">
            ‚úÖ Selected {selectedFolders.length} folder(s):
          </div>
          <div className="text-green-100 text-xs mt-1 max-h-20 overflow-y-auto">
            {selectedFolders.map((f, idx) => (
              <div key={f.id}>
                {idx + 1}. {f.name}
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Error Display */}
      {error && (
        <div className="mb-4 p-3 bg-red-800 border border-red-600 rounded-lg">
          <div className="text-red-200 text-sm">
            ‚ùå Error: {error}
          </div>
          <button
            onClick={loadRootFolders}
            type="button"
            className="mt-2 px-3 py-1 bg-red-600 text-white rounded text-xs hover:bg-red-700"
          >
            Retry
          </button>
        </div>
      )}

      {/* Tree Container */}
      <div className="tree-container bg-gray-700 rounded-lg p-4 max-h-96 overflow-y-auto border border-gray-600">
        {treeData['root'] ? (
          <div>
            {/* Root Node */}
            <div className="flex items-center py-2 px-3 bg-gray-600 rounded mb-2">
              <span className="mr-2 text-lg">üíæ</span>
              <div className="flex-1">
                <div className="text-white font-medium">My Drive</div>
                <div className="text-xs text-gray-300">Root directory - expand to navigate</div>
              </div>
              <div className="text-xs px-2 py-1 bg-gray-500 text-gray-200 rounded">Root</div>
            </div>

            {/* Root Children */}
            {treeData['root'].children && treeData['root'].children.map(folder => 
              renderFolderNode(folder, 0)
            )}
          </div>
        ) : (
          <div className="text-center py-8 text-gray-400">
            <div className="text-lg mb-2">üîÑ</div>
            <div>Loading folders...</div>
          </div>
        )}
      </div>

      {/* Instructions */}
      <div className="mt-4 p-3 bg-blue-800 border border-blue-600 rounded-lg">
        <div className="text-blue-200 text-sm">
          <div className="font-medium mb-1">üìç Navigation Guide:</div>
          <div className="text-xs space-y-1">
            <div>‚Ä¢ Click ‚ñ∂ to expand folders and navigate deeper</div>
            <div>‚Ä¢ ‚òëÔ∏è Check boxes to select camera folders</div>
            <div>‚Ä¢ Selected folders will be monitored for new videos</div>
            <div>‚Ä¢ VTrack will sync videos automatically</div>
          </div>
        </div>
      </div>

      {/* Debug Info (Development) */}
      {process.env.NODE_ENV === 'development' && (
        <details className="mt-4 p-3 bg-gray-800 rounded">
          <summary className="text-xs text-gray-400 cursor-pointer">üîß Debug - Tree State</summary>
          <pre className="text-xs text-gray-400 mt-2 overflow-auto max-h-32">
            {JSON.stringify({
              selectedCount: selectedFolders.length,
              selectedFolders: selectedFolders.map(f => ({ name: f.name, depth: f.depth })),
              expandedCount: expandedFolders.size,
              loadingCount: loadingFolders.size,
              treeNodesLoaded: Object.keys(treeData).length,
              hasError: !!error
            }, null, 2)}
          </pre>
        </details>
      )}
    </div>
  );
};

export default GoogleDriveFolderTree;
```
## üìÑ File: `InstructionsPanel.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/InstructionsPanel.js`

```javascript
import React, { useState, useEffect } from 'react';
import { getFinalRoiFrame } from "../../api";

const InstructionsPanel = ({
  step,
  customInstruction,
  analysisResult,
  errorMessage,
  onSave,
  onClose,
  onRetry,
  handDetected,
  videoPath,
  cameraId,
  onSubmit,
  setAnalysisResult,
  roiFramePath,
}) => {
  const [roiFrameSrc, setRoiFrameSrc] = useState(null);
  const [finalRoiFrameSrc, setFinalRoiFrameSrc] = useState(null);
  const [rois, setRois] = useState([]);
  const [internalError, setInternalError] = useState("");
  const [currentStep, setCurrentStep] = useState("packing");
  const [roiImageState, setRoiImageState] = useState({
    step: "packing",
    file: "roi_packing.jpg",
    ready: false,
  });
  const [imageAspectRatio, setImageAspectRatio] = useState(null);

  const loadRoiImage = async (fileSuffix, retryCount = 0, maxRetries = 3) => {
    try {
      if (!cameraId) {
        console.error("Missing cameraId", { cameraId });
        setInternalError("Thi·∫øu cameraId.");
        return;
      }

      console.log(`Loading ROI image with camera_id: ${cameraId}, file: ${fileSuffix}`);
      const timestamp = new Date().getTime();
      const url = `http://localhost:8080/get-roi-frame?camera_id=${cameraId}&file=${fileSuffix}&t=${timestamp}`;
      const response = await fetch(url, {
        headers: { 'Cache-Control': 'no-cache' },
      });
      if (!response.ok && response.status !== 304) {
        const errorText = await response.text();
        throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
      }
      console.log("Response from /get-roi-frame:", response);
      setRoiFrameSrc(url);
      setRoiImageState({ step: currentStep, file: fileSuffix, ready: true });
      console.log("roiFrameSrc updated to:", url);
    } catch (error) {
      console.error("Error loading ROI image:", error);
      if (retryCount < maxRetries) {
        console.log(`Retrying loadRoiImage (${retryCount + 1}/${maxRetries})...`);
        setTimeout(() => loadRoiImage(fileSuffix, retryCount + 1, maxRetries), 500);
      } else {
        setInternalError(`Kh√¥ng th·ªÉ t·∫£i ·∫£nh t·∫°m: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.`);
      }
    }
  };

  useEffect(() => {
    console.log("useEffect triggered with analysisResult:", analysisResult, "currentStep:", currentStep, "roiImageState:", roiImageState);
    if (analysisResult && analysisResult.roi_frame && roiImageState.ready) {
      loadRoiImage(roiImageState.file);
    } else if (currentStep === "packing" && analysisResult?.roi_frame) {
      loadRoiImage("roi_packing.jpg");
    }
  }, [analysisResult, currentStep, roiImageState.ready]);

  const fetchFinalRoiFrame = async () => {
    try {
      console.log(`Calling /get-final-roi-frame with camera_id: ${cameraId}`);
      const timestamp = new Date().getTime();
      const url = `http://localhost:8080/get-final-roi-frame?camera_id=${cameraId}&t=${timestamp}`;
      const response = await fetch(url, {
        headers: { 'Cache-Control': 'no-cache' },
      });
      if (!response.ok && response.status !== 304) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      console.log("Response from /get-final-roi-frame:", response);
      setFinalRoiFrameSrc(url);
    } catch (error) {
      console.error("Error fetching final ROI frame:", error);
      setInternalError("Kh√¥ng th·ªÉ t·∫£i ·∫£nh t·ªïng h·ª£p. Vui l√≤ng th·ª≠ l·∫°i.");
    }
  };

  const handleConfirmRoi = async () => {
    if (currentStep === "packing" && analysisResult?.roi) {
      if (!analysisResult || typeof analysisResult.hand_detected === "undefined") {
        setInternalError("Kh√¥ng t√¨m th·∫•y th√¥ng tin ph√°t hi·ªán tay t·ª´ backend. Vui l√≤ng th·ª≠ l·∫°i.");
        return;
      }
      if (!analysisResult.hand_detected) {
        setInternalError("Kh√¥ng ph√°t hi·ªán tay. Vui l√≤ng v·∫Ω l·∫°i v√πng packing ho·∫∑c tho√°t.");
        return;
      }
      if (!analysisResult.roi_frame) {
        setInternalError("Thi·∫øu ƒë∆∞·ªùng d·∫´n ·∫£nh t·∫°m packing. Vui l√≤ng th·ª≠ l·∫°i.");
        return;
      }

      const newRoi = { type: currentStep, ...analysisResult.roi };
      const updatedRois = [...rois, newRoi];
      setRois(updatedRois);
      setCurrentStep("mvd");
      setRoiImageState({ step: "mvd", file: "roi_packing.jpg", ready: true });
      try {
        console.log("Calling /run-qr-detector for mvd step with videoPath:", videoPath, "cameraId:", cameraId, "roiFramePath:", analysisResult.roi_frame);
        const response = await fetch('http://localhost:8080/run-qr-detector', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ videoPath, cameraId, roiFramePath: analysisResult.roi_frame }),
        });
        const result = await response.json();
        console.log("Result from /run-qr-detector (mvd):", result);
        if (result.success) {
          const tempResult = {
            success: true,
            message: result.message || "QR detection completed successfully",
            rois: result.rois,
            qr_detected: result.qr_detected,
            qr_detected_roi1: result.qr_detected_roi1,
            qr_detected_roi2: result.qr_detected_roi2,
            roi_frame: result.roi_frame,
            qr_content: result.qr_content,
            trigger_detected: result.trigger_detected,
            table_type: result.table_type,
          };
        
          if (result.roi_frame) {
            setRoiImageState({ step: "mvd", file: "roi_MVD.jpg", ready: true });
            await loadRoiImage("roi_MVD.jpg");
            setAnalysisResult(tempResult); // Ch·ªâ set sau khi ·∫£nh t·∫£i xong
          } else {
            console.log("No roi_frame in result, keeping roi_packing.jpg");
            setAnalysisResult(tempResult);
          }
        } else {
          setInternalError(result.error || "Kh√¥ng th·ªÉ v·∫Ω v√πng m√£ v·∫≠n ƒë∆°n.");
        }
      } catch (error) {
        setInternalError("L·ªói khi v·∫Ω v√πng m√£ v·∫≠n ƒë∆°n: " + error.message);
      }
    } else if (currentStep === "mvd" && analysisResult?.rois) {
      if (!analysisResult || typeof analysisResult.qr_detected === "undefined") {
        setInternalError("Kh√¥ng t√¨m th·∫•y th√¥ng tin ph√°t hi·ªán QR t·ª´ backend. Vui l√≤ng th·ª≠ l·∫°i.");
        return;
      }
      if (!analysisResult.qr_detected) {
        setInternalError("Kh√¥ng ph√°t hi·ªán m√£ QR. Vui l√≤ng v·∫Ω l·∫°i v√πng MVD ho·∫∑c tho√°t.");
        return;
      }
      if (!analysisResult.roi_frame) {
        setInternalError("Thi·∫øu ƒë∆∞·ªùng d·∫´n ·∫£nh t·∫°m MVD. Vui l√≤ng th·ª≠ l·∫°i.");
        return;
      }

      const newRois = analysisResult.rois.map((roi) => ({ type: currentStep, ...roi }));
      const updatedRois = [...rois, ...newRois];
      setRois(updatedRois);
      setCurrentStep("done");
      try {
        const response = await fetch('http://localhost:8080/finalize-roi', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ videoPath, cameraId, rois: updatedRois }),
        });
        const result = await response.json();
        if (result.success) {
          await fetchFinalRoiFrame();
          onSubmit(updatedRois);
          onSave();
        } else {
          setInternalError(result.error || "Kh√¥ng th·ªÉ t·∫°o ·∫£nh t·ªïng h·ª£p.");
        }
      } catch (error) {
        setInternalError("L·ªói khi t·∫°o ·∫£nh t·ªïng h·ª£p: " + error.message);
      }
    }
    if (currentStep === "done") {
      onSave();
    }
  };

  const handleRetryStep = async () => {
    if (!videoPath || !cameraId) {
      setInternalError("Thi·∫øu videoPath ho·∫∑c cameraId.");
      return;
    }

    try {
      if (currentStep === "packing") {
        console.log("Calling /run-select-roi for retry with videoPath:", videoPath, "cameraId:", cameraId);
        const response = await fetch('http://localhost:8080/run-select-roi', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ videoPath, cameraId }),
        });
        const result = await response.json();
        console.log("Result from /run-select-roi (retry):", result);
        if (result.success) {
          const newAnalysisResult = {
            success: true,
            message: result.message || "Hand detection completed successfully",
            roi: result.roi,
            hand_detected: result.hand_detected,
            roi_frame: result.roi_frame,
          };
          setAnalysisResult(newAnalysisResult);
          if (result.roi_frame) {
            setRoiImageState({ step: "packing", file: "roi_packing.jpg", ready: true });
            await loadRoiImage("roi_packing.jpg");
          }
        } else {
          setInternalError(result.error || `Kh√¥ng th·ªÉ ch·∫°y l·∫°i hand detection.`);
        }
      } else if (currentStep === "mvd") {
        console.log("Calling /run-qr-detector for retry with videoPath:", videoPath, "cameraId:", cameraId, "roiFramePath:", analysisResult.roi_frame);
        const response = await fetch('http://localhost:8080/run-qr-detector', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ videoPath, cameraId, roiFramePath: analysisResult.roi_frame }),
        });
        const result = await response.json();
        console.log("Result from /run-qr-detector (retry):", result);
        if (result.success) {
          const newAnalysisResult = {
            success: true,
            message: result.message || "QR detection completed successfully",
            rois: result.rois,
            qr_detected: result.qr_detected,
            qr_detected_roi1: result.qr_detected_roi1,
            qr_detected_roi2: result.qr_detected_roi2,
            qr_content: result.qr_content,
            roi_frame: result.roi_frame,
            trigger_detected: result.trigger_detected,
            table_type: result.table_type,
          };
          setAnalysisResult(newAnalysisResult);
          if (result.roi_frame && result.qr_detected) {
            setRoiImageState({ step: "mvd", file: "roi_MVD.jpg", ready: true });
            await loadRoiImage("roi_MVD.jpg");
          } else {
            setInternalError("Kh√¥ng th·ªÉ t·∫£i ·∫£nh ho·∫∑c kh√¥ng ph√°t hi·ªán QR.");
          }
        } else {
          setInternalError(result.error || `Kh√¥ng th·ªÉ ch·∫°y l·∫°i QR detection.`);
        }
      }
    } catch (error) {
      setInternalError(`L·ªói khi ch·∫°y l·∫°i: ${error.message}`);
    }
  };

  const handleImageLoad = (e) => {
    const { width, height } = e.target;
    setImageAspectRatio(width / height);
  };

  return (
    <div className="flex w-full h-full">
      <div className="w-1/4 pr-4 flex flex-col border-r-2 border-gray-500">
        <div className="mb-4">
          <h3 className="text-2xl font-bold mb-2 text-white">K·∫øt qu·∫£</h3>
          {currentStep === "mvd" ? (
            <>
              {analysisResult?.table_type === "standard" ? (
                <>
                  <div className={`p-2 rounded text-white flex items-center ${analysisResult?.trigger_detected ? 'bg-green-600' : 'bg-red-600'}`}>
                    <span className="mr-2">{analysisResult?.trigger_detected ? '‚úî' : '‚úò'}</span>
                    <p>ROI Trigger: {analysisResult?.trigger_detected ? 'C√≥' : 'Kh√¥ng'}</p>
                  </div>
                  <div className={`p-2 rounded text-white flex items-center mt-2 ${analysisResult?.qr_detected_roi1 ? 'bg-green-600' : 'bg-red-600'}`}>
                    <span className="mr-2">{analysisResult?.qr_detected_roi1 ? '‚úî' : '‚úò'}</span>
                    <p>ROI MVD: {analysisResult?.qr_detected_roi1 ? 'C√≥' : 'Kh√¥ng'}</p>
                  </div>
                </>
              ) : (
                <>
                  {typeof analysisResult?.qr_detected_roi1 !== 'undefined' && (
                    <div className={`p-2 rounded text-white flex items-center ${analysisResult?.qr_detected_roi1 ? 'bg-green-600' : 'bg-red-600'}`}>
                      <span className="mr-2">{analysisResult?.qr_detected_roi1 ? '‚úî' : '‚úò'}</span>
                      <p>ROI 1: {analysisResult?.qr_detected_roi1 ? 'C√≥' : 'Kh√¥ng'}</p>
                    </div>
                  )}
                </>
              )}
            </>
          ) : (
            <div className={`p-2 rounded text-white flex items-center ${handDetected ? 'bg-green-600' : 'bg-red-600'}`}>
              <span className="mr-2">{handDetected ? '‚úî' : '‚úò'}</span>
              <p>{handDetected ? `X√°c nh·∫≠n v√πng ${currentStep}` : 'Kh√¥ng ph√°t hi·ªán chuy·ªÉn ƒë·ªông'}</p>
            </div>
          )}
          {errorMessage && (
            <div className="mt-2 p-2 bg-red-600 rounded text-white">
              <p>{errorMessage}</p>
            </div>
          )}
          {internalError && (
            <div className="mt-2 p-2 bg-red-600 rounded text-white">
              <p>{internalError}</p>
            </div>
          )}
        </div>
        <div className="mb-4 flex-1">
          <h3 className="text-xl font-bold mb-2 text-white">H∆∞·ªõng d·∫´n</h3>
          <p className="text-gray-300 text-lg">
            {currentStep === "done"
              ? "ƒê√£ ho√†n t·∫•t v·∫Ω v√πng v√† ph√°t hi·ªán m√£ QR. Nh·∫•n Tho√°t ƒë·ªÉ ti·∫øp t·ª•c."
              : currentStep === "mvd"
                ? analysisResult?.qr_detected
                  ? "ƒê√£ t√¨m th·∫•y m√£ QR. Nh·∫•n Ho√†n t·∫•t ƒë·ªÉ l∆∞u v√† ti·∫øp t·ª•c."
                  : "V·∫Ω l·∫°i v√πng m√£ v·∫≠n ƒë∆°n ho·∫∑c tho√°t."
                : handDetected
                  ? "Ti·∫øp t·ª•c x√°c ƒë·ªãnh v√πng m√£ v·∫≠n ƒë∆°n."
                  : "V·∫Ω l·∫°i v√πng packing ho·∫∑c tho√°t."}
          </p>
        </div>
        <div className="mt-auto space-y-2">
          {currentStep !== "done" && (
            <button
              onClick={handleRetryStep}
              className="w-full py-2 bg-yellow-600 hover:bg-yellow-700 text-white font-bold rounded"
            >
              V·∫Ω l·∫°i
            </button>
          )}
          {currentStep === "mvd" && analysisResult?.qr_detected && (
            <button
              onClick={handleConfirmRoi}
              className="w-full py-2 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded"
            >
              Ho√†n t·∫•t
            </button>
          )}
          {currentStep === "packing" && handDetected && (
            <button
              onClick={handleConfirmRoi}
              className="w-full py-2 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded"
            >
              Ti·∫øp t·ª•c
            </button>
          )}
          <button
            onClick={onClose}
            className="w-full py-2 bg-red-600 hover:bg-red-700 text-white font-bold rounded"
          >
            Tho√°t
          </button>
        </div>
      </div>
      <div className="w-3/4 pl-4 flex flex-col">
        <div className="mb-4 flex justify-center items-center" style={{ maxHeight: 'calc(75vh - 2rem)', overflow: 'hidden' }}>
          {console.log("Rendering ROI frame with roiFrameSrc:", roiFrameSrc, "roiImageState:", roiImageState)}
          {roiFrameSrc && (
            <img 
              src={roiFrameSrc} 
              alt="ROI Frame" 
              className={`max-w-full max-h-full rounded ${imageAspectRatio && imageAspectRatio < 1 ? 'portrait' : 'landscape'}`}
              onLoad={handleImageLoad}
            />
          )}
        </div>
        {finalRoiFrameSrc && currentStep === "done" && (
          <div className="mb-4 flex justify-center items-center" style={{ maxHeight: 'calc(75vh - 2rem)', overflow: 'hidden' }}>
            <h4 className="text-lg font-bold text-white">·∫¢nh t·ªïng h·ª£p:</h4>
            <img 
              src={finalRoiFrameSrc} 
              alt="Final ROI Frame" 
              className={`max-w-full max-h-full rounded ${imageAspectRatio && imageAspectRatio < 1 ? 'portrait' : 'landscape'}`}
              onLoad={handleImageLoad}
            />
          </div>
        )}
      </div>
      <style jsx>{`
        .max-w-full {
          max-width: 100%;
        }
        .max-h-full {
          max-height: 100%;
        }
        .landscape {
          object-fit: contain;
          width: 100%;
        }
        .portrait {
          object-fit: contain;
          height: 100%;
        }
      `}</style>
    </div>
  );
};

export default InstructionsPanel;
```
## üìÑ File: `SourceCard.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/SourceCard.js`

```javascript
// components/config/SourceCard.js
import React from 'react';

const SourceCard = ({ source, onEdit, onDelete, onToggle }) => {
  const getSourceTypeIcon = (type) => {
    const icons = {
      'local': 'üíª',
      'network': 'üåê', 
      'camera': 'üìπ',
      'cloud': '‚òÅÔ∏è'
    };
    return icons[type] || 'üìÅ';
  };

  return (
    <div className="bg-gray-800 border border-gray-600 rounded-lg p-4 mb-3">
      <div className="flex justify-between items-start">
        <div className="flex-1">
          <div className="flex items-center gap-2 mb-2">
            <span className="text-xl">{getSourceTypeIcon(source.source_type)}</span>
            <h4 className="text-lg font-medium text-white">{source.name}</h4>
            <span className={`px-2 py-1 rounded text-xs font-medium ${
              source.active ? 'bg-green-600 text-white' : 'bg-red-600 text-white'
            }`}>
              {source.active ? 'Active' : 'Inactive'}
            </span>
          </div>
          <p className="text-gray-300 text-sm mb-1">
            <strong>Type:</strong> {source.source_type.toUpperCase()}
          </p>
          <p className="text-gray-300 text-sm break-all">
            <strong>Path:</strong> {source.path}
          </p>
        </div>
        
        <div className="flex gap-2 ml-4">
          <button
            onClick={() => onToggle(source.id, !source.active)}
            className={`px-3 py-1 rounded text-sm font-medium ${
              source.active 
                ? 'bg-yellow-600 hover:bg-yellow-700 text-white' 
                : 'bg-green-600 hover:bg-green-700 text-white'
            }`}
          >
            {source.active ? 'Disable' : 'Enable'}
          </button>
          <button
            onClick={() => onEdit(source)}
            className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm font-medium"
          >
            Edit
          </button>
          <button
            onClick={() => onDelete(source.id)}
            className="px-3 py-1 bg-red-600 hover:bg-red-700 text-white rounded text-sm font-medium"
          >
            Delete
          </button>
        </div>
      </div>
    </div>
  );
};

export default SourceCard;
```
## üìÑ File: `CameraDialog.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/CameraDialog.js`

```javascript
const CameraDialog = ({
  showCameraDialog,
  setShowCameraDialog,
  cameras,
  selectedCameras,
  handleCameraSelection,
  handleSaveConfig,
}) => {
  if (!showCameraDialog) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-gray-800 p-6 rounded-lg w-1/2">
        <h2 className="text-2xl font-bold mb-4 text-white">X√°c nh·∫≠n camera</h2>
        <div className="max-h-64 overflow-y-auto">
          {cameras.map((camera) => (
            <label key={camera.name} className="flex items-center mb-2 text-white">
              <input
                type="checkbox"
                className="mr-2"
                checked={selectedCameras.includes(camera.name)}
                onChange={() => handleCameraSelection(camera.name)}
              />
              {camera.name} ({camera.path})
            </label>
          ))}
        </div>
        <div className="mt-4 flex justify-end gap-4">
          <button
            onClick={() => setShowCameraDialog(false)}
            className="py-2 px-4 bg-gray-600 text-white font-bold rounded"
          >
            H·ªßy
          </button>
          <button
            onClick={handleSaveConfig}
            className="py-2 px-4 bg-blue-600 text-white font-bold rounded"
          >
            X√°c nh·∫≠n
          </button>
        </div>
      </div>
    </div>
  );
};
export default CameraDialog;
```
## üìÑ File: `FileList.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/program/FileList.js`

```javascript
const FileList = ({ fileList }) => {
  if (!fileList || fileList.length === 0) {
    return (
      <div className="mt-4">
        <h3 className="text-lg font-bold">K·∫øt qu·∫£:</h3>
        <p>Kh√¥ng c√≥ file n√†o ƒë·ªÉ hi·ªÉn th·ªã.</p>
      </div>
    );
  }

  return (
    <div className="mt-4">
      <h3 className="text-lg font-bold">K·∫øt qu·∫£:</h3>
      <ul className="list-disc pl-5">
        {fileList.map((item, index) => (
          <li key={index}>{`${item.file}: ${item.status}`}</li>
        ))}
      </ul>
    </div>
  );
};

export default FileList;
```
## üìÑ File: `ProgramTab.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/program/ProgramTab.js`

```javascript
import { useState, useEffect } from "react";
import Card from "../ui/Card";
import FileList from "./FileList";

const ProgramTab = ({
  runningCard,
  fileList,
  customPath,
  firstRunCompleted,
  handleRunStop,
  isRunning,
  setCustomPath,
}) => {
  const [updatedFileList, setUpdatedFileList] = useState(fileList);

  useEffect(() => {
    const fetchProgress = async () => {
      try {
        const response = await fetch("http://localhost:8080/program-progress", {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        });
        const data = await response.json();
        if (response.ok) {
          setUpdatedFileList(data.files);
        } else {
          console.error("Failed to fetch program progress:", data.error);
        }
      } catch (error) {
        console.error("Error fetching program progress:", error);
      }
    };

    fetchProgress();
    const intervalId = setInterval(fetchProgress, 10000);
    const timeoutId = setTimeout(() => {
      clearInterval(intervalId);
      console.log("Stopped polling /program-progress after 2 minutes");
    }, 120000);

    return () => {
      clearInterval(intervalId);
      clearTimeout(timeoutId);
    };
  }, [runningCard]);

  return (
    <div className="flex flex-col gap-6">
      <div className="grid grid-cols-3 gap-6">
        {!firstRunCompleted && (
          <Card
            title="L·∫ßn ƒë·∫ßu"
            description="Ch·∫°y l·∫ßn ƒë·∫ßu ƒë·ªÉ x·ª≠ l√Ω d·ªØ li·ªáu c∆° s·ªü."
            isRunning={isRunning("L·∫ßn ƒë·∫ßu")}
            onRunStop={firstRunCompleted ? null : () => handleRunStop("L·∫ßn ƒë·∫ßu")}
            isLocked={firstRunCompleted}
          />
        )}
        <Card
          title="M·∫∑c ƒë·ªãnh"
          description="Ch·∫°y khi kh·ªüi ƒë·ªông, ch·∫°y n·ªÅn."
          isRunning={isRunning("M·∫∑c ƒë·ªãnh")}
          onRunStop={() => handleRunStop("M·∫∑c ƒë·ªãnh")}
        />
        <Card
          title="Ch·ªâ ƒë·ªãnh"
          description="Ch·ªâ ƒë·ªãnh file c·ª• th·ªÉ."
          isRunning={isRunning("Ch·ªâ ƒë·ªãnh")}
          onRunStop={() => handleRunStop("Ch·ªâ ƒë·ªãnh", customPath)}
          onPathChange={(path) => setCustomPath(path)}
        />
      </div>
      <FileList fileList={updatedFileList} />
    </div>
  );
};

export default ProgramTab;
```
## üìÑ File: `TextInputSection.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/query/TextInputSection.js`

```javascript
const TextInputSection = ({ searchString, setSearchString, searchType }) => {
  const handleTextInputChange = (e) => {
    const value = e.target.value;
    const lines = value.split("\n");
    const codes = [];
    
    lines.forEach(line => {
      const trimmedLine = line.trim();
      if (!trimmedLine) return;
      const match = trimmedLine.match(/^\d+\.\s*(.+)$/);
      const lineContent = match ? match[1].trim() : trimmedLine;
      const lineCodes = lineContent.split(";").map(code => code.trim()).filter(code => code);
      codes.push(...lineCodes);
    });

    let formattedCodes = codes
      .map((code, index) => `${index + 1}. ${code}`)
      .join("\n");

    if (value.endsWith("\n")) {
      formattedCodes += `\n${codes.length + 1}. `;
    }

    setSearchString(formattedCodes);
  };

  return (
    <textarea
      value={searchString}
      onChange={handleTextInputChange}
      placeholder="Nh·∫≠p chu·ªói t√¨m ki·∫øm (m·ªói m√£ tr√™n m·ªôt d√≤ng)"
      className="w-full p-2 mb-4 rounded bg-gray-700 text-white h-1/2 overflow-y-auto whitespace-pre-wrap resize-none"
      disabled={searchType === "File"}
    />
  );
};

export default TextInputSection;
```
## üìÑ File: `TimeAndQuerySection.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/query/TimeAndQuerySection.js`

```javascript
import DatePicker from "react-datepicker";
import "react-datepicker/dist/react-datepicker.css";

const TimeAndQuerySection = ({
  startDate,
  setStartDate,
  endDate,
  setEndDate,
  defaultDays,
  setDefaultDays,
  searchString,
  searchType,
  fileContent,
  results,
  setResults,
  setSelectedVideos,
  setQueryCount,
  setFoundCount,
  foundCount,
  onQuery, // Prop ƒë·ªÉ nh·∫≠n h√†m debounce t·ª´ QueryComponent
  isQuerying, // Prop ƒë·ªÉ v√¥ hi·ªáu h√≥a n√∫t
}) => {
  const handleStartDateChange = (date) => {
    setStartDate(date);
    if (endDate) {
      const diffDays = (endDate - date) / (1000 * 60 * 60 * 24);
      if (diffDays > 30) {
        setEndDate(new Date(date.getTime() + 30 * 24 * 60 * 60 * 1000));
      } else if (date > endDate) {
        setEndDate(date);
      }
    }
  };

  const handleEndDateChange = (date) => {
    const today = new Date();
    if (date > today) {
      date = today;
    }
    if (startDate) {
      const diffDays = (date - startDate) / (1000 * 60 * 60 * 24);
      if (diffDays > 30) {
        setStartDate(new Date(date.getTime() - 30 * 24 * 60 * 60 * 1000));
      } else if (date < startDate) {
        setStartDate(date);
      }
    }
    setEndDate(date);
  };

  return (
    <>
      <div className="mb-4">
        <label className="block mb-1">Th·ªùi gian m·∫∑c ƒë·ªãnh (ng√†y):</label>
        <input
          type="number"
          value={defaultDays}
          onChange={(e) => setDefaultDays(Number(e.target.value))}
          className="w-full p-2 rounded bg-gray-700 text-white"
        />
      </div>
      <div className="flex gap-4 mb-4">
        <div className="flex-1">
          <label className="block mb-1">T·ª´:</label>
          <DatePicker
            selected={startDate}
            onChange={handleStartDateChange}
            showTimeSelect
            timeIntervals={60}
            dateFormat="Pp"
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
        <div className="flex-1">
          <label className="block mb-1">ƒê·∫øn:</label>
          <DatePicker
            selected={endDate}
            onChange={handleEndDateChange}
            showTimeSelect
            timeIntervals={60}
            dateFormat="Pp"
            maxDate={new Date()}
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
      </div>
      <button
        onClick={onQuery} // D√πng onQuery t·ª´ props
        disabled={isQuerying} // V√¥ hi·ªáu h√≥a n√∫t khi ƒëang x·ª≠ l√Ω
        className={`w-full py-2 bg-green-600 text-white font-bold rounded ${isQuerying ? "opacity-50 cursor-not-allowed" : ""}`}
      >
        Truy v·∫•n
      </button>
    </>
  );
};

export default TimeAndQuerySection;
```
## üìÑ File: `FileInputSection.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/query/FileInputSection.js`

```javascript
const FileInputSection = ({ path, setPath, fileContent, setFileContent, setShowModal, setHeaders }) => {
  const handleOpenExplorer = () => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".csv,.xlsx";
    input.onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const fileName = file.name.toLowerCase();
      const fileType = file.type;

      // Ki·ªÉm tra ƒëu√¥i file
      if (!fileName.endsWith(".csv") && !fileName.endsWith(".xlsx")) {
        alert("Vui l√≤ng ch·ªçn file CSV ho·∫∑c Excel (.csv, .xlsx)");
        return;
      }

      // Ki·ªÉm tra MIME type
      const validCsvMimeTypes = ["text/csv", "application/csv"];
      const validXlsxMimeTypes = [
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/vnd.ms-excel",
      ];
      if (fileName.endsWith(".csv") && !validCsvMimeTypes.includes(fileType)) {
        alert("File kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng CSV. Vui l√≤ng ch·ªçn file CSV h·ª£p l·ªá.");
        return;
      }
      if (fileName.endsWith(".xlsx") && !validXlsxMimeTypes.includes(fileType)) {
        alert("File kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng Excel. Vui l√≤ng ch·ªçn file XLSX h·ª£p l·ªá.");
        return;
      }

      setPath(file.name);

      const reader = new FileReader();
      reader.onload = (event) => {
        const arrayBuffer = event.target.result;
        const bytes = new Uint8Array(arrayBuffer);
        const binary = Array.from(bytes).map((b) => String.fromCharCode(b)).join("");
        const base64 = btoa(binary); // Base64 encode t·ª´ nh·ªã ph√¢n
        setFileContent(base64);
      };
      reader.onerror = () => {
        alert("L·ªói khi ƒë·ªçc file");
      };
      reader.readAsArrayBuffer(file); // ƒê·ªçc raw binary
    };
    input.click();
  };

  const handleConfirmFile = async () => {
    if (!path) {
      alert("Vui l√≤ng ch·ªçn file CSV ho·∫∑c nh·∫≠p ƒë∆∞·ªùng d·∫´n");
      return;
    }
    try {
      const response = await fetch("http://localhost:8080/get-csv-headers", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          file_path: path,
          file_content: fileContent || "",
          is_excel: path.toLowerCase().endsWith(".xlsx"),
        }),
      });
      const result = await response.json();
      if (response.ok) {
        setHeaders(result.headers || []);
        setShowModal(true);
      } else {
        throw new Error(result.error || "Failed to get CSV headers");
      }
    } catch (error) {
      console.error("Error getting CSV headers:", error);
      alert(error.message || "Failed to get CSV headers");
    }
  };

  return (
    <div className="mb-4">
      <div className="relative w-full mb-2">
        <input
          type="text"
          value={path}
          onChange={(e) => setPath(e.target.value)}
          placeholder="Ch·ªçn file ƒë·ªãnh d·∫°ng *.csv ho·∫∑c *.xlsx"
          className="w-full p-2 rounded bg-gray-700 text-white"
        />
        <button
          type="button"
          onClick={handleOpenExplorer}
          className="absolute right-2 top-1/2 transform -translate-y-1/2 text-white"
        >
          ...
        </button>
      </div>
      <button
        onClick={handleConfirmFile}
        className="w-full py-2 bg-yellow-500 text-white font-bold rounded"
      >
        X√°c nh·∫≠n
      </button>
    </div>
  );
};

export default FileInputSection;
```
## üìÑ File: `ColumnSelectorModal.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/query/ColumnSelectorModal.js`

```javascript
const ColumnSelectorModal = ({
  showModal,
  setShowModal,
  headers,
  selectedColumn,
  setSelectedColumn,
  history,
  setHistory,
  selectedPlatform,
  setSelectedPlatform,
  shopeeLabel,
  setShopeeLabel,
  lazadaLabel,
  setLazadaLabel,
  tiktokLabel,
  setTiktokLabel,
  customLabel1,
  setCustomLabel1,
  customLabel2,
  setCustomLabel2,
  path,
  fileContent,
  setSearchString,
  setSearchType,
}) => {
  const handleModalConfirm = async () => {
    const columnName = history[selectedPlatform] || "tracking_codes";
    const data = {
      file_path: path,
      file_content: fileContent || "",
      column_name: columnName,
      is_excel: path.toLowerCase().endsWith(".xlsx"), // Th√™m logic x√°c ƒë·ªãnh is_excel d·ª±a tr√™n path
    };
    try {
      console.log("Sending file data:", data);
      const response = await fetch("http://localhost:8080/parse-csv", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      const result = await response.json();
      console.log("Response from parse-csv:", result);
      if (response.ok) {
        const trackingCodes = result.tracking_codes || [];
        const formattedCodes = trackingCodes
          .map((code, index) => `${index + 1}. ${code}`)
          .join("\n");
        setSearchString(formattedCodes);
        setSearchType("Text");
        setShowModal(false);
      } else {
        throw new Error(result.error || "Failed to parse CSV");
      }
    } catch (error) {
      console.error("Error parsing CSV:", error);
      alert(error.message || "Failed to parse CSV");
    }
  };

  const handleUpdateColumn = () => {
    const newColumn = selectedColumn;
    const updatedHistory = { ...history };
    updatedHistory[selectedPlatform] = newColumn;
    setHistory(updatedHistory);
    localStorage.setItem("trackingColumnHistory", JSON.stringify(updatedHistory));

    const updatedLabels = {
      Shopee: shopeeLabel,
      Lazada: lazadaLabel,
      Tiktok: tiktokLabel,
      Custom1: customLabel1,
      Custom2: customLabel2,
    };
    localStorage.setItem("platformLabels", JSON.stringify(updatedLabels));
  };

  const handlePlatformChange = (platform) => {
    setSelectedPlatform(platform);
    setSelectedColumn(history[platform] || "tracking_codes");
  };

  if (!showModal) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-gray-800 p-6 rounded-lg w-1/2">
        <h2 className="text-xl font-bold mb-4">Ch·ªçn c·ªôt m√£ v·∫≠n ƒë∆°n</h2>
        <div className="mb-4">
          <label className="block mb-1">Ch·ªçn t·ª´ danh s√°ch:</label>
          <select
            value={selectedColumn}
            onChange={(e) => setSelectedColumn(e.target.value)}
            className="w-full p-2 rounded bg-gray-700 text-white"
          >
            {headers.map((header, index) => (
              <option key={index} value={header}>{header}</option>
            ))}
          </select>
        </div>
        <div className="mb-4">
          <button
            onClick={handleUpdateColumn}
            className="w-full py-2 bg-blue-600 text-white font-bold rounded"
          >
            C·∫≠p nh·∫≠t
          </button>
        </div>
        <div className="mb-4">
          <h3 className="text-lg font-bold mb-2">L·ªãch s·ª≠ l·ª±a ch·ªçn:</h3>
          <label className="flex items-center mb-2">
            <input
              type="radio"
              name="platform"
              value="Shopee"
              checked={selectedPlatform === "Shopee"}
              onChange={() => handlePlatformChange("Shopee")}
              className="mr-2"
            />
            <input
              type="text"
              value={shopeeLabel}
              onChange={(e) => setShopeeLabel(e.target.value)}
              placeholder="T√™n Shopee"
              className="mr-2 p-1 rounded bg-gray-700 text-white"
            />
            <input
              type="text"
              value={history.Shopee}
              onChange={(e) => setHistory({ ...history, Shopee: e.target.value })}
              className="p-1 rounded bg-gray-700 text-white"
            />
          </label>
          <label className="flex items-center mb-2">
            <input
              type="radio"
              name="platform"
              value="Lazada"
              checked={selectedPlatform === "Lazada"}
              onChange={() => handlePlatformChange("Lazada")}
              className="mr-2"
            />
            <input
              type="text"
              value={lazadaLabel}
              onChange={(e) => setLazadaLabel(e.target.value)}
              placeholder="T√™n Lazada"
              className="mr-2 p-1 rounded bg-gray-700 text-white"
            />
            <input
              type="text"
              value={history.Lazada}
              onChange={(e) => setHistory({ ...history, Lazada: e.target.value })}
              className="p-1 rounded bg-gray-700 text-white"
            />
          </label>
          <label className="flex items-center mb-2">
            <input
              type="radio"
              name="platform"
              value="Tiktok"
              checked={selectedPlatform === "Tiktok"}
              onChange={() => handlePlatformChange("Tiktok")}
              className="mr-2"
            />
            <input
              type="text"
              value={tiktokLabel}
              onChange={(e) => setTiktokLabel(e.target.value)}
              placeholder="T√™n Tiktok"
              className="mr-2 p-1 rounded bg-gray-700 text-white"
            />
            <input
              type="text"
              value={history.Tiktok}
              onChange={(e) => setHistory({ ...history, Tiktok: e.target.value })}
              className="p-1 rounded bg-gray-700 text-white"
            />
          </label>
          <label className="flex items-center mb-2">
            <input
              type="radio"
              name="platform"
              value="Custom1"
              checked={selectedPlatform === "Custom1"}
              onChange={() => handlePlatformChange("Custom1")}
              className="mr-2"
            />
            <input
              type="text"
              value={customLabel1}
              onChange={(e) => setCustomLabel1(e.target.value)}
              placeholder="T√™n t√πy ch·ªânh 1"
              className="mr-2 p-1 rounded bg-gray-700 text-white"
            />
            <input
              type="text"
              value={history.Custom1}
              onChange={(e) => setHistory({ ...history, Custom1: e.target.value })}
              className="p-1 rounded bg-gray-700 text-white"
            />
          </label>
          <label className="flex items-center mb-2">
            <input
              type="radio"
              name="platform"
              value="Custom2"
              checked={selectedPlatform === "Custom2"}
              onChange={() => handlePlatformChange("Custom2")}
              className="mr-2"
            />
            <input
              type="text"
              value={customLabel2}
              onChange={(e) => setCustomLabel2(e.target.value)}
              placeholder="T√™n t√πy ch·ªânh 2"
              className="mr-2 p-1 rounded bg-gray-700 text-white"
            />
            <input
              type="text"
              value={history.Custom2}
              onChange={(e) => setHistory({ ...history, Custom2: e.target.value })}
              className="p-1 rounded bg-gray-700 text-white"
            />
          </label>
        </div>
        <div className="flex justify-end gap-4">
          <button
            onClick={() => setShowModal(false)}
            className="py-2 px-4 bg-gray-600 text-white rounded"
          >
            H·ªßy
          </button>
          <button
            onClick={handleModalConfirm}
            className="py-2 px-4 bg-green-600 text-white rounded"
          >
            X√°c nh·∫≠n
          </button>
        </div>
      </div>
    </div>
  );
};

export default ColumnSelectorModal;
```
## üìÑ File: `useVtrackConfig.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/hooks/useVtrackConfig.js`

```javascript
import { useState, useEffect } from "react";

const useVtrackConfig = () => {
  const [fromTime, setFromTime] = useState(null);
  const [toTime, setToTime] = useState(null);
  const [country, setCountry] = useState("Vi·ªát Nam");
  const [timezone, setTimezone] = useState("UTC+7");
  const [brandName, setBrandName] = useState("");
  const [inputPath, setInputPath] = useState("");
  const [outputPath, setOutputPath] = useState("");
  const [workingDays, setWorkingDays] = useState([]);
  const [defaultDays, setDefaultDays] = useState(30);
  const [minPackingTime, setMinPackingTime] = useState(10);
  const [maxPackingTime, setMaxPackingTime] = useState(120);
  const [frameRate, setFrameRate] = useState(30);
  const [frameInterval, setFrameInterval] = useState(5);
  const [videoBuffer, setVideoBuffer] = useState(2);
  const [cameras, setCameras] = useState([]);
  const [selectedCameras, setSelectedCameras] = useState([]);
  const [showCameraDialog, setShowCameraDialog] = useState(false);
  const [error, setError] = useState(null);
  const [runDefaultOnStart, setRunDefaultOnStart] = useState(false);

  const countries = [
    "Vi·ªát Nam", "Nh·∫≠t B·∫£n", "H√†n Qu·ªëc", "Th√°i Lan", "Singapore",
    "M·ªπ", "Anh", "Ph√°p", "ƒê·ª©c", "√öc"
  ];

  const countryTimezones = {
    "Vi·ªát Nam": "UTC+7", "Nh·∫≠t B·∫£n": "UTC+9", "H√†n Qu·ªëc": "UTC+9",
    "Th√°i Lan": "UTC+7", "Singapore": "UTC+8", "M·ªπ": "UTC-5",
    "Anh": "UTC+0", "Ph√°p": "UTC+1", "ƒê·ª©c": "UTC+1", "√öc": "UTC+10"
  };

  const BASE_DIR = "/Users/annhu/vtrack_app/V_Track";

  useEffect(() => {
    const fetchCameraFolders = async () => {
      try {
        // ‚úÖ SIMPLIFIED - single source of truth
        const response = await fetch("http://localhost:8080/get-camera-folders");
        if (response.ok) {
          const data = await response.json();
          if (Array.isArray(data.folders)) {
            setCameras(data.folders);
            setError(null);
          } else {
            setCameras([]);
            setError(data.error || "Failed to load camera folders");
          }
        } else {
          setCameras([]);
          setError("Camera folders not available");
        }
      } catch (error) {
        console.error("Error fetching camera folders:", error);
        setError("Error fetching camera folders: " + error.message);
        setCameras([]);
      }
    };
    fetchCameraFolders();
  }, []);

  const handleCountryChange = (e) => {
    const selectedCountry = e.target.value;
    setCountry(selectedCountry);
    setTimezone(countryTimezones[selectedCountry] || "UTC+0");
  };

  const handleFromTimeChange = (time) => {
    setFromTime(time);
    if (toTime && time > toTime) setToTime(time);
  };

  const handleToTimeChange = (time) => {
    if (fromTime && time < fromTime) setFromTime(time);
    setToTime(time);
  };

  const handleWorkingDayChange = (day) => {
    setWorkingDays((prev) =>
      prev.includes(day) ? prev.filter((d) => d !== day) : [...prev, day]
    );
  };

  useEffect(() => {
    console.log("workingDays updated:", workingDays);
  }, [workingDays]);

  const handleOpenExplorer = (type) => {
    const input = document.createElement("input");
    input.type = "file";
    input.webkitdirectory = true;
    input.onchange = (e) => {
      const files = e.target.files;
      if (files.length > 0) {
        const file = files[0];
        let selectedPath = file.path || file.webkitRelativePath || file.name || "";
        if (!selectedPath.startsWith('/')) {
          selectedPath = `${BASE_DIR}/${selectedPath}`;
        }
        selectedPath = selectedPath.split('/').slice(0, -1).join('/');
        if (selectedPath.includes('.DS_Store')) {
          selectedPath = selectedPath.replace('/.DS_Store', '');
        }
        console.log(`Selected ${type} path:`, selectedPath);
        if (type === "input") setInputPath(selectedPath);
        else setOutputPath(selectedPath);
      }
    };
    input.click();
  };

  const handleSaveGeneralInfo = async () => {
    const data = {
      country,
      timezone,
      brand_name: brandName,
      working_days: workingDays.length > 0 ? workingDays : ["Th·ª© Hai", "Th·ª© Ba", "Th·ª© T∆∞", "Th·ª© NƒÉm", "Th·ª© S√°u", "Th·ª© B·∫£y", "Ch·ªß Nh·∫≠t"],
      from_time: fromTime ? fromTime.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false }) : "07:00",
      to_time: toTime ? toTime.toLocaleTimeString('en-GB', { hour: "2-digit", minute: "2-digit", hour12: false }) : "23:00",
    };
    console.log("Data sent to /save-general-info:", data);
    try {
      const response = await fetch("http://localhost:8080/save-general-info", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (response.ok) alert("General info saved successfully");
      else throw new Error("Failed to save general info");
    } catch (error) {
      console.error("Error saving general info:", error);
      alert("Failed to save general info");
    }
  };

  const handleSaveConfig = async () => {
    let normalizedInputPath = inputPath.trim();
    if (!normalizedInputPath) {
      alert("Input path cannot be empty");
      return;
    }
    if (!normalizedInputPath.startsWith('/')) {
      normalizedInputPath = `${BASE_DIR}/${normalizedInputPath}`;
    }
    if (normalizedInputPath.includes('.DS_Store')) {
      normalizedInputPath = normalizedInputPath.replace('/.DS_Store', '');
    }

    let normalizedOutputPath = outputPath.trim();
    if (!normalizedOutputPath) {
      normalizedOutputPath = `${BASE_DIR}/output_clips`;
    }
    if (!normalizedOutputPath.startsWith('/')) {
      normalizedOutputPath = `${BASE_DIR}/${normalizedOutputPath}`;
    }
    if (normalizedOutputPath.includes('.DS_Store')) {
      normalizedOutputPath = normalizedOutputPath.replace('/.DS_Store', '');
    }

    const data = {
      video_root: normalizedInputPath,
      output_path: normalizedOutputPath,
      db_path: "/Users/annhu/Downloads/V_Track project/events.db",
      default_days: defaultDays,
      min_packing_time: minPackingTime,
      max_packing_time: maxPackingTime,
      frame_rate: frameRate,
      frame_interval: frameInterval,
      video_buffer: videoBuffer,
      selected_cameras: selectedCameras,
    };
    console.log("Data sent to /save-config:", data);
    try {
      const response = await fetch("http://localhost:8080/save-config", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      const result = await response.json();
      if (response.ok) {
        localStorage.setItem("configSet", "true");
        alert("Configuration saved successfully");
        setShowCameraDialog(false);
        const cameraResponse = await fetch("http://localhost:8080/get-cameras");
        const cameraData = await cameraResponse.json();
        if (cameraData && Array.isArray(cameraData.cameras)) {
          setCameras(cameraData.cameras.map(name => ({ name, path: "" })));
          setError(null);
        } else {
          setCameras([]);
          setError(cameraData?.error || "Failed to load cameras");
        }
      } else {
        throw new Error(result.error || "Failed to save config");
      }
    } catch (error) {
      console.error("Error saving config:", error);
      alert("Failed to save config: " + error.message);
    }
  };

  const handleShowCameraDialog = () => {
    setShowCameraDialog(true);
  };

  const handleCameraSelection = (cameraName) => {
    setSelectedCameras((prev) =>
      prev.includes(cameraName) ? prev.filter((c) => c !== cameraName) : [...prev, cameraName]
    );
  };

  return {
    fromTime,
    setFromTime,
    toTime,
    setToTime,
    country,
    setCountry,
    timezone,
    setTimezone,
    brandName,
    setBrandName,
    inputPath,
    setInputPath,
    outputPath,
    setOutputPath,
    workingDays,
    setWorkingDays,
    defaultDays,
    setDefaultDays,
    minPackingTime,
    setMinPackingTime,
    maxPackingTime,
    setMaxPackingTime,
    frameRate,
    setFrameRate,
    frameInterval,
    setFrameInterval,
    videoBuffer,
    setVideoBuffer,
    cameras,
    setCameras,
    selectedCameras,
    setSelectedCameras,
    showCameraDialog,
    setShowCameraDialog,
    error,
    setError,
    handleCountryChange,
    handleFromTimeChange,
    handleToTimeChange,
    handleWorkingDayChange,
    handleOpenExplorer,
    handleSaveGeneralInfo,
    handleSaveConfig,
    handleShowCameraDialog,
    handleCameraSelection,
    runDefaultOnStart,
    setRunDefaultOnStart,
  };
};

export default useVtrackConfig;
```
## üìÑ File: `useProgramLogic.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/hooks/useProgramLogic.js`

```javascript
import { useState, useEffect } from "react";
import { runProgram, confirmRun } from "../api";

const useProgramLogic = () => {
  const [runningCard, setRunningCard] = useState("M·∫∑c ƒë·ªãnh");
  const [fileList, setFileList] = useState([]);
  const [customPath, setCustomPath] = useState("");
  const [showConfirmButton, setShowConfirmButton] = useState(false);
  const [firstRunCompleted, setFirstRunCompleted] = useState(false);
  const [isLocked, setIsLocked] = useState(false);

  const checkFirstRun = async () => {
    try {
      const response = await fetch("http://localhost:8080/check-first-run");
      const data = await response.json();
      setFirstRunCompleted(data.first_run_completed);
    } catch (error) {
      console.error("Error checking first run:", error);
    }
  };

  const checkDefaultRunning = async () => {
    try {
      const response = await fetch("http://localhost:8080/program", {
        method: "GET",
      });
      const data = await response.json();
      setRunningCard("M·∫∑c ƒë·ªãnh"); // √âp M·∫∑c ƒë·ªãnh khi refresh
      setIsLocked(false);
    } catch (error) {
      console.error("Error checking default running state:", error);
      setRunningCard("M·∫∑c ƒë·ªãnh"); // √âp M·∫∑c ƒë·ªãnh n·∫øu l·ªói
      setIsLocked(false);
    }
  };

  useEffect(() => {
    const initializeState = async () => {
      await checkFirstRun();
      await checkDefaultRunning();
    };
    initializeState();
  }, []);

  const handleRunStop = async (cardTitle, path = "") => {
    if (cardTitle === "L·∫ßn ƒë·∫ßu" && firstRunCompleted) {
      return;
    }

    if (isLocked) {
      alert("H·ªá th·ªëng ƒëang x·ª≠ l√Ω, vui l√≤ng ƒë·ª£i!");
      return;
    }

    try {
      let days = null;
      if (cardTitle === "L·∫ßn ƒë·∫ßu" && !isRunning(cardTitle)) {
        days = prompt("B·∫°n mu·ªën x·ª≠ l√Ω bao nhi√™u ng√†y? (T·ªëi ƒëa 30 ng√†y)", "30");
        days = parseInt(days);
        if (isNaN(days) || days <= 0 || days > 30) {
          alert("S·ªë ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p t·ª´ 1 ƒë·∫øn 30.");
          return;
        }
      } else if (cardTitle === "Ch·ªâ ƒë·ªãnh" && !isRunning(cardTitle)) {
        if (!path) {
          alert("Vui l√≤ng ch·ªçn ƒë∆∞·ªùng d·∫´n cho ch∆∞∆°ng tr√¨nh Ch·ªâ ƒë·ªãnh.");
          return;
        }
        setIsLocked(true);
      }

      const response = await runProgram({
        card: cardTitle,
        action: isRunning(cardTitle) ? "stop" : "run",
        days: days,
        custom_path: cardTitle === "Ch·ªâ ƒë·ªãnh" ? path : ""
      });

      if (response.status === 200) {
        if (isRunning(cardTitle)) {
          if (cardTitle === "M·∫∑c ƒë·ªãnh") {
            setRunningCard(null);
            setFileList([]);
            alert(`ƒê√£ d·ª´ng ch∆∞∆°ng tr√¨nh ${cardTitle}`);
          }
        } else {
          if (cardTitle !== "L·∫ßn ƒë·∫ßu" || !firstRunCompleted) {
            setRunningCard(cardTitle);
            setShowConfirmButton(true);
            if (cardTitle !== "Ch·ªâ ƒë·ªãnh") {
              setIsLocked(false);
            }
          }
        }
      }
    } catch (error) {
      console.error("Error calling API:", error);
      setIsLocked(false);
      if (error.response?.status === 400) {
        alert(error.response.data.error);
      } else {
        alert("C√≥ l·ªói x·∫£y ra khi g·ªçi API. Vui l√≤ng ki·ªÉm tra server.");
      }
    }
  };

  const handleConfirmRun = async () => {
    try {
      const response = await confirmRun({ card: runningCard });
      if (response.status === 200) {
        setShowConfirmButton(false);
        setFileList(response.data.files || []);
        if (runningCard === "L·∫ßn ƒë·∫ßu") {
          setFirstRunCompleted(true);
          await checkFirstRun();
        }
        if (runningCard === "Ch·ªâ ƒë·ªãnh") {
          setIsLocked(false);
          await checkDefaultRunning();
        }
      }
    } catch (error) {
      console.error("Error confirming run:", error);
      setIsLocked(false);
      alert("C√≥ l·ªói x·∫£y ra khi x√°c nh·∫≠n ch·∫°y ch∆∞∆°ng tr√¨nh.");
    }
  };

  const isRunning = (cardTitle) => runningCard === cardTitle;

  return {
    runningCard,
    setRunningCard,
    fileList,
    setFileList,
    customPath,
    setCustomPath,
    showConfirmButton,
    setShowConfirmButton,
    firstRunCompleted,
    setFirstRunCompleted,
    handleRunStop,
    handleConfirmRun,
    isRunning,
    isLocked
  };
};

export default useProgramLogic;
```