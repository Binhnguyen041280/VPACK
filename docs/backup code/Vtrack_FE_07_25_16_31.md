# üì¶ T·ªïng h·ª£p m√£ ngu·ªìn Vtrack Frontend

**T·ªïng c·ªông:** 0 file `.py`, 40 file `.js`

---

## üìÑ File: `tailwind.config.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/tailwind.config.js`

```javascript
module.exports = {
  content: ["./src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      colors: {
        'blue-custom': '#0066CC',
        'red-custom': '#E32222',
        'gray-custom': '#3F3F3F',
        'yellow-custom': '#FFD700',
      },
    },
  },
  plugins: [],
};
```
## üìÑ File: `postcss.config.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/postcss.config.js`

```javascript
module.exports = {
   plugins: {
     tailwindcss: {},
     autoprefixer: {},
   },
 };
```
## üìÑ File: `reportWebVitals.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/reportWebVitals.js`

```javascript
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

```
## üìÑ File: `Sidebar.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/Sidebar.js`

```javascript
import { Play, Search, Settings, User } from "lucide-react";
import Title from "./Title";

const Sidebar = ({ setActiveMenu, activeMenu }) => (
  <div className="w-64 bg-black text-white min-h-screen p-4 flex flex-col font-montserrat">
    <Title text="V_TRACK UI" />
    <ul>
      {[
        { name: "Ch∆∞∆°ng tr√¨nh", icon: <Play className="mr-2 text-blue-custom" /> },
        { name: "Truy v·∫•n", icon: <Search className="mr-2 text-red-custom" /> },
        { name: "C·∫•u h√¨nh", icon: <Settings className="mr-2 text-gray-custom" /> },
        { name: "T√†i kho·∫£n", icon: <User className="mr-2 text-yellow-custom" /> },
      ].map((item) => (
        <li
          key={item.name}
          className={`flex items-center p-3 hover:bg-gray-800 cursor-pointer transition duration-300 ${
            activeMenu === item.name ? "bg-gray-800" : ""
          }`}
          onClick={() => setActiveMenu(item.name)}
        >
          {item.icon} {item.name}
        </li>
      ))}
    </ul>
  </div>
);

export default Sidebar;
```
## üìÑ File: `index.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/index.js`

```javascript
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import "@fontsource/montserrat";
import "react-datepicker/dist/react-datepicker.css";

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

```
## üìÑ File: `QueryComponent.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/QueryComponent.js`

```javascript
import { useState, useEffect } from "react";
import SearchModeSelector from "./components/ui/SearchModeSelector";
import FileInputSection from "./components/query/FileInputSection";
import TextInputSection from "./components/query/TextInputSection";
import TimeAndQuerySection from "./components/query/TimeAndQuerySection";
import ResultList from "./components/result/ResultList";
import VideoCutter from "./components/result/VideoCutter"; // Thay CutVideoSection b·∫±ng VideoCutter
import ColumnSelectorModal from "./components/query/ColumnSelectorModal";
import api from "./api";

const QueryComponent = () => {
  const [searchType, setSearchType] = useState("Text");
  const [path, setPath] = useState("");
  const [startDate, setStartDate] = useState(null);
  const [endDate, setEndDate] = useState(null);
  const [results, setResults] = useState([]);
  const [selectedVideos, setSelectedVideos] = useState([]);
  const [cutVideos, setCutVideos] = useState([]);
  const [searchString, setSearchString] = useState("");
  const [defaultDays, setDefaultDays] = useState(30);
  const [fileContent, setFileContent] = useState("");
  const [trackingCodes, setTrackingCodes] = useState([]);
  const [showModal, setShowModal] = useState(false);
  const [headers, setHeaders] = useState([]);
  const [selectedColumn, setSelectedColumn] = useState("tracking_codes");
  const [history, setHistory] = useState({
    Shopee: "M√£ v·∫≠n ƒë∆°n",
    Lazada: "V·∫≠n ƒë∆°n",
    Tiktok: "QR m√£ v·∫≠n ƒë∆°n",
    Custom1: "Custom 1",
    Custom2: "Custom 2",
  });
  const [selectedPlatform, setSelectedPlatform] = useState("Shopee");
  const [shopeeLabel, setShopeeLabel] = useState("Shopee");
  const [lazadaLabel, setLazadaLabel] = useState("Lazada");
  const [tiktokLabel, setTiktokLabel] = useState("Tiktok");
  const [customLabel1, setCustomLabel1] = useState("Custom 1");
  const [customLabel2, setCustomLabel2] = useState("Custom 2");
  const [queryCount, setQueryCount] = useState(0);
  const [trackingCodeCount, setTrackingCodeCount] = useState(0);
  const [foundCount, setFoundCount] = useState(0);
  const [isQuerying, setIsQuerying] = useState(false);
  const [selectedCameras, setSelectedCameras] = useState([]);
  const [availableCameras, setAvailableCameras] = useState([]);
  const [hasQueried, setHasQueried] = useState(false);

  useEffect(() => {
    const savedHistory = localStorage.getItem("trackingColumnHistory");
    if (savedHistory) {
      setHistory(JSON.parse(savedHistory));
    }
    const savedLabels = localStorage.getItem("platformLabels");
    if (savedLabels) {
      const labels = JSON.parse(savedLabels);
      setShopeeLabel(labels.Shopee || "Shopee");
      setLazadaLabel(labels.Lazada || "Lazada");
      setTiktokLabel(labels.Tiktok || "Tiktok");
      setCustomLabel1(labels.Custom1 || "Custom 1");
      setCustomLabel2(labels.Custom2 || "Custom 2");
    }

    const isConfigSet = localStorage.getItem("configSet");
    if (isConfigSet) {
      const fetchCameras = async () => {
        try {
          const response = await api.get("/get-cameras");
          setAvailableCameras(response.data.cameras || []);
          const savedCameras = localStorage.getItem("selectedCameras");
          if (savedCameras) {
            setSelectedCameras(JSON.parse(savedCameras));
          }
        } catch (error) {
          console.error("Error fetching cameras:", error);
        }
      };
      fetchCameras();
    }
  }, []);

  useEffect(() => {
    let count = 0;
    if (searchString) {
      const lines = searchString.split("\n");
      count = lines.filter(line => line.trim() !== "" && line.split('. ')[1]?.trim()).length;
    }
    setTrackingCodeCount(count);
  }, [searchString]);

  const debounce = (func, delay) => {
    let timeoutId;
    return (...args) => {
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => func(...args), delay);
    };
  };

  const handleQuery = async () => {
    setIsQuerying(true);
    setHasQueried(true);
    try {
      const queryData = {
        search_string: searchString,
        default_days: defaultDays,
        from_time: startDate ? startDate.toISOString() : null,
        to_time: endDate ? endDate.toISOString() : null,
        selected_cameras: selectedCameras,
      };

      const response = await api.post("/query", queryData);
      const events = response.data.events || [];

      setResults(events);
      setSelectedVideos(events.map(event => event.event_id));
      setQueryCount(prev => prev + 1);
      setFoundCount(events.length);
    } catch (error) {
      console.error("Error in query:", error);
    } finally {
      setIsQuerying(false);
    }
  };

  const debouncedHandleQuery = debounce(handleQuery, 1000);

  const handleCameraSelection = (camera) => {
    const updatedCameras = selectedCameras.includes(camera)
      ? selectedCameras.filter((c) => c !== camera)
      : [...selectedCameras, camera];
    setSelectedCameras(updatedCameras);
    localStorage.setItem("selectedCameras", JSON.stringify(updatedCameras));
  };

  return (
    <div className="p-6 flex gap-6 w-screen h-screen">
      <div className="w-[26.67%] bg-gray-800 p-6 rounded-lg flex flex-col">
        <h1 className="text-3xl font-bold mb-4">Truy v·∫•n</h1>
        <SearchModeSelector searchType={searchType} setSearchType={setSearchType} />
        {searchType === "File" && (
          <FileInputSection
            path={path}
            setPath={setPath}
            fileContent={fileContent}
            setFileContent={setFileContent}
            setShowModal={setShowModal}
            setHeaders={setHeaders}
          />
        )}
        <TextInputSection
          searchString={searchString}
          setSearchString={setSearchString}
          searchType={searchType}
        />
        <div className="mb-4">
          <label className="block mb-1">Truy v·∫•n t·∫°i camera:</label>
          <div className="max-h-24 overflow-y-auto">
            {availableCameras.map((camera) => (
              <label key={camera} className="flex items-center mb-2">
                <input
                  type="checkbox"
                  checked={selectedCameras.includes(camera)}
                  onChange={() => handleCameraSelection(camera)}
                  className="mr-2"
                />
                {camera}
              </label>
            ))}
          </div>
        </div>
        <TimeAndQuerySection
          startDate={startDate}
          setStartDate={setStartDate}
          endDate={endDate}
          setEndDate={setEndDate}
          defaultDays={defaultDays}
          setDefaultDays={setDefaultDays}
          searchString={searchString}
          searchType={searchType}
          fileContent={fileContent}
          results={results}
          setResults={setResults}
          setSelectedVideos={setSelectedVideos}
          setQueryCount={setQueryCount}
          setFoundCount={setFoundCount}
          foundCount={foundCount}
          onQuery={debouncedHandleQuery}
          isQuerying={isQuerying}
        />
      </div>
      <div className="w-[53.33%] bg-gray-800 p-6 rounded-lg flex flex-col">
        <div className="flex items-center mb-4">
          <h1 className="text-3xl font-bold mr-4">K·∫øt qu·∫£</h1>
          {(trackingCodeCount > 0 || foundCount > 0) && (
            <span className="text-lg text-gray-300">
              (Truy v·∫•n {trackingCodeCount}/ T√¨m ƒë∆∞·ª£c {foundCount})
            </span>
          )}
        </div>
        <ResultList
          results={results}
          selectedVideos={selectedVideos}
          setSelectedVideos={setSelectedVideos}
          hasQueried={hasQueried}
        />
        <VideoCutter
          results={results}
          selectedVideos={selectedVideos}
          setResults={setResults}
          setSelectedVideos={setSelectedVideos}
        /> {/* Thay CutVideoSection b·∫±ng VideoCutter */}
      </div>
      <ColumnSelectorModal
        showModal={showModal}
        setShowModal={setShowModal}
        headers={headers}
        selectedColumn={selectedColumn}
        setSelectedColumn={setSelectedColumn}
        history={history}
        setHistory={setHistory}
        selectedPlatform={selectedPlatform}
        setSelectedPlatform={setSelectedPlatform}
        shopeeLabel={shopeeLabel}
        setShopeeLabel={setShopeeLabel}
        lazadaLabel={lazadaLabel}
        setLazadaLabel={setLazadaLabel}
        tiktokLabel={tiktokLabel}
        setTiktokLabel={setTiktokLabel}
        customLabel1={customLabel1}
        setCustomLabel1={setCustomLabel1}
        customLabel2={customLabel2}
        setCustomLabel2={setCustomLabel2}
        path={path}
        fileContent={fileContent}
        setSearchString={setSearchString}
        setSearchType={setSearchType}
      />
    </div>
  );
};

export default QueryComponent;
```
## üìÑ File: `Title.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/Title.js`

```javascript
const Title = ({ text }) => {
   return <h2 className="text-xl font-bold text-center mb-6 tracking-widest">{text}</h2>;
 };
 
 export default Title;
```
## üìÑ File: `Account.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/Account.js`

```javascript
const Account = () => {
   return (
     <div className="p-6">
       <h1 className="text-3xl font-bold">T√†i kho·∫£n</h1>
       <p>ƒê√¢y l√† trang T√†i kho·∫£n. N·ªôi dung s·∫Ω ƒë∆∞·ª£c th√™m sau.</p>
     </div>
   );
 };
 
 export default Account;
```
## üìÑ File: `App.test.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/App.test.js`

```javascript
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

```
## üìÑ File: `VtrackConfig.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/VtrackConfig.js`

```javascript
import React from "react";
import useVtrackConfig from "./hooks/useVtrackConfig";
import GeneralInfoForm from "./components/config/GeneralInfoForm";
import ConfigForm from "./components/config/ConfigForm";
import CameraDialog from "./components/config/CameraDialog";
import ProcessingRegionForm from "./components/config/ProcessingRegionForm";

const VtrackConfig = () => {
  const {
    fromTime,
    setFromTime,
    toTime,
    setToTime,
    country,
    setCountry,
    timezone,
    setTimezone,
    brandName,
    setBrandName,
    inputPath,
    setInputPath,
    outputPath,
    setOutputPath,
    workingDays,
    setWorkingDays,
    defaultDays,
    setDefaultDays,
    minPackingTime,
    setMinPackingTime,
    maxPackingTime,
    setMaxPackingTime,
    frameRate,
    setFrameRate,
    frameInterval,
    setFrameInterval,
    videoBuffer,
    setVideoBuffer,
    cameras,
    setCameras,
    selectedCameras,
    setSelectedCameras,
    showCameraDialog,
    setShowCameraDialog,
    error,
    setError,
    handleCountryChange,
    handleFromTimeChange,
    handleToTimeChange,
    handleWorkingDayChange,
    handleOpenExplorer,
    handleSaveGeneralInfo,
    handleSaveConfig,
    handleShowCameraDialog,
    handleCameraSelection,
    runDefaultOnStart,
    setRunDefaultOnStart,
  } = useVtrackConfig();

  const [configFormCameras, setConfigFormCameras] = React.useState([]);
  const [configFormSelectedCameras, setConfigFormSelectedCameras] = React.useState([]);
  const [activeVideoSource, setActiveVideoSource] = React.useState(null);
  const [loadingCameras, setLoadingCameras] = React.useState(false);

  const [videoPath, setVideoPath] = React.useState("");
  const [qrSize, setQrSize] = React.useState("");
  
  const handleAnalyzeRegions = () => {
    console.log("Ph√¢n t√≠ch v√πng:", videoPath, qrSize);
  };

  // ‚úÖ ENHANCED: Helper function ƒë·ªÉ get correct input path based on source type (NO NVR)
  const getInputPathForSource = (source) => {
    if (!source) return "";
    
    let resultPath = "";
    
    switch (source.source_type) {
      case 'local':
        // Local: Use actual file system path
        resultPath = source.path;
        console.log(`üìÅ Local Path Mapping: ${source.path} ‚Üí ${resultPath}`);
        break;
      case 'cloud':
        // Cloud: Use sync directory
        resultPath = `/Users/annhu/vtrack_app/V_Track/cloud_sync/${source.name}`;
        console.log(`‚òÅÔ∏è Cloud Path Mapping: ${source.path} ‚Üí ${resultPath}`);
        break;
      default:
        resultPath = source.path;
        console.log(`‚ùì Unknown Path Mapping: ${source.path} ‚Üí ${resultPath}`);
    }
    
    return resultPath;
  };

  // üÜï NEW: Load active source from backend
  const loadActiveSource = React.useCallback(async () => {
    try {
      console.log("üîÑ Loading active video source...");
      
      const response = await fetch('http://localhost:8080/api/config/get-sources', {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (response.ok) {
        const data = await response.json();
        const sources = data.sources || [];
        
        // T√¨m source active (ch·ªâ c√≥ 1 source active)
        const activeSource = sources.find(s => s.active) || sources[0];
        
        if (activeSource) {
          console.log("‚úÖ Found active source:", activeSource.name, activeSource.source_type);
          setActiveVideoSource(activeSource);
          
          // Set correct input path
          const correctPath = getInputPathForSource(activeSource);
          setInputPath(correctPath);
          console.log("üìÅ Set inputPath:", correctPath);
          
          return activeSource;
        } else {
          console.log("‚ö†Ô∏è No active source found");
          return null;
        }
      } else {
        console.error("‚ùå Failed to load sources:", response.status);
        return null;
      }
    } catch (error) {
      console.error("‚ùå Error loading active source:", error);
      return null;
    }
  }, [setInputPath]);

  // ‚úÖ NEW: Enhanced function to load selected cameras from processing_config
  const loadSelectedCameras = React.useCallback(async () => {
    try {
      setLoadingCameras(true);
      console.log("üîÑ Loading selected cameras from processing_config...");
      
      const response = await fetch('http://localhost:8080/api/config/get-processing-cameras', {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (response.ok) {
        const data = await response.json();
        const cameras = data.selected_cameras || [];
        
        console.log("‚úÖ Loaded processing cameras:", cameras);
        console.log("üìä Camera count:", data.count);
        
        // Update both camera lists
        setConfigFormCameras(cameras);
        setConfigFormSelectedCameras(cameras);
        
        // Also sync to hook state
        const cameraObjects = cameras.map(name => ({
          name: name,
          path: name
        }));
        setCameras(cameraObjects);
        setSelectedCameras(cameras);
        
        return cameras;
      } else {
        console.error("‚ùå Failed to load processing cameras:", response.status);
        return [];
      }
    } catch (error) {
      console.error("‚ùå Error loading processing cameras:", error);
      return [];
    } finally {
      setLoadingCameras(false);
    }
  }, [setCameras, setSelectedCameras]);

  // ‚úÖ NEW: Check and handle cloud source specific loading
  const checkCloudSource = React.useCallback(async () => {
    try {
      console.log("üîç Checking for cloud sources...");
      
      const response = await fetch('http://localhost:8080/api/config/get-sources', {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (response.ok) {
        const data = await response.json();
        const sources = data.sources || [];
        const cloudSource = sources.find(s => s.source_type === 'cloud');
        
        if (cloudSource) {
          console.log("‚òÅÔ∏è Found cloud source:", cloudSource.name);
          console.log("üìÅ Cloud config:", cloudSource.config);
          
          // Check if cloud has selected_cameras in config
          const cloudCameras = cloudSource.config?.selected_cameras || [];
          if (cloudCameras.length > 0) {
            console.log("üé• Cloud cameras found in source config:", cloudCameras);
            
            // Update camera states
            setConfigFormCameras(cloudCameras);
            setConfigFormSelectedCameras(cloudCameras);
            
            const cameraObjects = cloudCameras.map(name => ({
              name: name,
              path: name
            }));
            setCameras(cameraObjects);
            setSelectedCameras(cloudCameras);
            
            console.log("‚úÖ Cloud cameras loaded successfully");
            return true;
          } else {
            console.log("‚ö†Ô∏è Cloud source found but no cameras in config");
          }
        } else {
          console.log("üìù No cloud source found");
        }
      }
      
      return false;
    } catch (error) {
      console.error("‚ùå Error checking cloud source:", error);
      return false;
    }
  }, [setCameras, setSelectedCameras]);

  // üîÑ UPDATED: Initialize v·ªõi active source loading
  React.useEffect(() => {
    console.log("üöÄ VtrackConfig mounted, initializing...");
    
    const initializeApp = async () => {
      // 1. Load active source tr∆∞·ªõc
      const activeSource = await loadActiveSource();
      
      // 2. Load cameras
      const cameras = await loadSelectedCameras();
      
      // 3. N·∫øu kh√¥ng c√≥ cameras v√† c√≥ cloud source, th·ª≠ cloud check
      if (cameras.length === 0 && activeSource?.source_type === 'cloud') {
        console.log("‚òÅÔ∏è Cloud source detected, checking cloud cameras...");
        await checkCloudSource();
      }
    };
    
    initializeApp();
  }, [loadActiveSource, loadSelectedCameras, checkCloudSource]);

  // üîÑ UPDATED: Sync input path when activeVideoSource changes
  React.useEffect(() => {
    console.log("=== INPUT PATH SYNC DEBUG ===");
    console.log("activeVideoSource changed:", activeVideoSource);
    
    if (activeVideoSource) {
      const correctPath = getInputPathForSource(activeVideoSource);
      console.log(`${activeVideoSource.source_type.toUpperCase()} source detected - setting path:`, correctPath);
      setInputPath(correctPath);
      
      // For cloud sources, also load cameras
      if (activeVideoSource.source_type === 'cloud') {
        console.log("‚òÅÔ∏è Cloud source detected, loading cameras...");
        checkCloudSource();
      }
    } else {
      console.log("activeVideoSource is null, will load from backend");
    }
  }, [activeVideoSource, setInputPath, checkCloudSource]);

  // ‚úÖ Keep existing useEffect for syncing cameras
  React.useEffect(() => {
    if (configFormCameras && configFormCameras.length > 0) {
      const cameraObjects = configFormCameras.map(name => ({
        name: name,
        path: name
      }));
      setCameras(cameraObjects);
      console.log("üîÑ Synced cameras to hook state:", cameraObjects);
    }
  }, [configFormCameras, setCameras]);

  React.useEffect(() => {
    if (configFormSelectedCameras && configFormSelectedCameras.length > 0) {
      setSelectedCameras(configFormSelectedCameras);
      console.log("üîÑ Synced selectedCameras to hook state:", configFormSelectedCameras);
    }
  }, [configFormSelectedCameras, setSelectedCameras]);


const handleCamerasUpdate = React.useCallback((sourceCameras, selectedCameras, activeSource) => {
  console.log("=== CAMERAS UPDATE FROM CONFIGFORM ===");
  console.log("sourceCameras:", sourceCameras);
  console.log("selectedCameras:", selectedCameras);
  console.log("activeSource:", activeSource);
  
  // ‚úÖ Update all camera states
  setConfigFormCameras(sourceCameras);
  setConfigFormSelectedCameras(selectedCameras);
  
  // ‚úÖ Sync to hook state
  const cameraObjects = sourceCameras.map(name => ({
    name: name,
    path: name
  }));
  setCameras(cameraObjects);
  setSelectedCameras(selectedCameras);
  
  // ‚úÖ CRITICAL: Handle source updates (including null for removal)
  if (activeSource !== undefined) { // Only update if explicitly passed
    console.log("üîÑ Updating activeVideoSource:", activeSource);
    setActiveVideoSource(activeSource);
    
    if (activeSource) {
      // Set path for new source
      const correctPath = getInputPathForSource(activeSource);
      setInputPath(correctPath);
      console.log("üìÅ Updated inputPath:", correctPath);
    } else {
      // Clear path when source is removed
      setInputPath('');
      console.log("üìÅ Cleared inputPath due to source removal");
    }
  }
  
  console.log("‚úÖ Camera state fully synced from ConfigForm");
}, [setCameras, setSelectedCameras, setInputPath, setActiveVideoSource]);

// ‚úÖ TH√äM: Force re-render khi activeVideoSource thay ƒë·ªïi
React.useEffect(() => {
  console.log("=== ACTIVE SOURCE CHANGED ===");
  console.log("New activeVideoSource:", activeVideoSource);
  
  if (!activeVideoSource) {
    console.log("üîÑ Source cleared, resetting all related states");
    // ƒê·∫£m b·∫£o t·∫•t c·∫£ state ƒë∆∞·ª£c clear khi source b·ªã x√≥a
    setConfigFormCameras([]);
    setConfigFormSelectedCameras([]);
    setCameras([]);
    setSelectedCameras([]);
    setInputPath('');
  }
}, [activeVideoSource, setCameras, setSelectedCameras, setInputPath]);

  // ‚úÖ ENHANCED: Smart camera dialog logic - skip if cameras already selected
  const handleShowCameraDialogCustom = async () => {
    console.log("=== SMART CAMERA DIALOG LOGIC ===");
    console.log("configFormSelectedCameras:", configFormSelectedCameras);
    console.log("configFormCameras:", configFormCameras);
    
    // ‚úÖ Try to refresh camera data first
    if (configFormCameras.length === 0) {
      console.log("üîÑ No cameras detected, refreshing from server...");
      
      setLoadingCameras(true);
      const refreshedCameras = await loadSelectedCameras();
      
      if (refreshedCameras.length === 0) {
        // Also try cloud source check
        const cloudFound = await checkCloudSource();
        if (!cloudFound) {
          alert("‚ùå Kh√¥ng t√¨m th·∫•y camera n√†o!\n\n" + 
                "Vui l√≤ng ki·ªÉm tra:\n" +
                "1. Video source ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh ƒë√∫ng\n" +
                "2. Cloud source ƒë√£ sync cameras\n" +
                "3. Processing config ƒë√£ c√≥ selected_cameras\n\n" +
                "Th·ª≠ refresh l·∫°i trang n·∫øu v·∫´n l·ªói.");
          return;
        }
      }
      setLoadingCameras(false);
      
      // Give time for state updates
      await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // ‚úÖ Check if cameras are already selected after refresh
    const currentSelectedCameras = configFormSelectedCameras.length > 0 ? configFormSelectedCameras : selectedCameras;
    const currentCameras = configFormCameras.length > 0 ? configFormCameras : cameras.map(c => c.name);
    
    if (currentSelectedCameras && currentSelectedCameras.length > 0) {
      console.log("‚úÖ Cameras already selected, skipping dialog and saving directly");
      console.log("Selected cameras:", currentSelectedCameras);
      
      // ‚úÖ Sync cameras to dialog state for save process
      const cameraObjects = currentCameras.map(name => ({
        name: name,
        path: name
      }));
      setCameras(cameraObjects);
      setSelectedCameras(currentSelectedCameras);
      
      // ‚úÖ Save directly without showing dialog
      handleSaveConfigCustom();
      return;
    }
    
    // ‚úÖ No cameras selected, show dialog for user to select
    console.log("‚ö†Ô∏è No cameras selected, showing dialog for user selection");
    
    if (!currentCameras || currentCameras.length === 0) {
      alert("‚ùå Kh√¥ng t√¨m th·∫•y camera n√†o ƒë·ªÉ ch·ªçn!\n\n" + 
            "Debug info:\n" +
            `- configFormCameras: ${configFormCameras.length}\n` +
            `- cameras from hook: ${cameras.length}\n\n` +
            "Vui l√≤ng:\n" +
            "1. Ki·ªÉm tra video source ƒë√£ ƒë∆∞·ª£c c·∫•u h√¨nh\n" +
            "2. ƒê·∫£m b·∫£o c√≥ camera folders trong source\n" +
            "3. Refresh trang v√† th·ª≠ l·∫°i");
      return;
    }
    
    const cameraObjects = currentCameras.map(name => ({
      name: name,
      path: name
    }));
    setCameras(cameraObjects);
    setSelectedCameras([]); // Start with empty selection for user to choose
    setShowCameraDialog(true);
  };

  // ‚úÖ SIMPLE: Back to basic validation (like before)
  const handleSaveConfigCustom = () => {
    console.log("=== SIMPLE SAVE CONFIG ===");
    console.log("configFormSelectedCameras:", configFormSelectedCameras);
    console.log("selectedCameras from dialog:", selectedCameras);
    console.log("inputPath:", inputPath);
    
    // ‚úÖ SIMPLE: Get cameras (multiple fallbacks)
    let camerasToUse = [];
    
    if (selectedCameras && selectedCameras.length > 0) {
      camerasToUse = selectedCameras;
      console.log("üìã Using cameras from dialog selection");
    } else if (configFormSelectedCameras && configFormSelectedCameras.length > 0) {
      camerasToUse = configFormSelectedCameras;
      console.log("üìã Using cameras from config form");
    } else if (cameras && cameras.length > 0) {
      camerasToUse = cameras.map(c => c.name || c);
      console.log("üìã Using cameras from hook state");
    }
      
    console.log("Final cameras to use:", camerasToUse);
    
    // ‚úÖ SIMPLE: Only check cameras (like before)
    if (!camerasToUse || camerasToUse.length === 0) {
      alert("‚ùå Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt camera!");
      return;
    }

    // ‚úÖ SIMPLE: Auto-set path if empty and have activeVideoSource
    if (activeVideoSource && (!inputPath || inputPath.trim() === "")) {
      const correctPath = getInputPathForSource(activeVideoSource);
      console.log(`üîÑ Auto-setting path: ${correctPath}`);
      setInputPath(correctPath);
    }

    console.log("üíæ Saving with simple validation...");
    console.log("- Cameras:", camerasToUse.length);
    console.log("- Input Path:", inputPath || "Will be set by handleSaveConfig");

    setShowCameraDialog(false);
    console.log("üíæ Calling original handleSaveConfig...");
    handleSaveConfig();
  };

  // ‚úÖ NEW: Debug function to check camera sync status
  const handleDebugCameras = async () => {
    try {
      console.log("üîß Debug: Checking camera sync status...");
      
      const response = await fetch('http://localhost:8080/api/config/debug-cameras', {
        method: 'GET',
        headers: { 'Content-Type': 'application/json' }
      });
      
      if (response.ok) {
        const data = await response.json();
        console.log("üîß Debug camera data:", data);
        
        alert(`üîß Camera Debug Info:\n\n` +
              `Processing Config:\n` +
              `- Selected cameras: ${data.processing_config?.camera_count || 0}\n` +
              `- Input path: ${data.processing_config?.input_path || 'N/A'}\n\n` +
              `Active Sources: ${data.active_sources?.length || 0}\n\n` +
              `Check console for full details.`);
      }
    } catch (error) {
      console.error("‚ùå Debug error:", error);
    }
  };

  // üÜï NEW: Quick debug and auto-fix function
  const debugAndFix = async () => {
    try {
      console.log("üîß DEBUG: Checking current state...");
      
      // 1. Check sources
      const sourcesResponse = await fetch('http://localhost:8080/api/config/get-sources');
      const sourcesData = await sourcesResponse.json();
      console.log("üìä Sources:", sourcesData);
      
      // 2. Check cameras
      const camerasResponse = await fetch('http://localhost:8080/api/config/get-processing-cameras');
      const camerasData = await camerasResponse.json();
      console.log("üé• Cameras:", camerasData);
      
      // 3. Auto-fix if possible
      if (sourcesData.sources && sourcesData.sources.length > 0) {
        const activeSource = sourcesData.sources[0];
        setActiveVideoSource(activeSource);
        
        const correctPath = getInputPathForSource(activeSource);
        setInputPath(correctPath);
        
        console.log("‚úÖ AUTO-FIXED:");
        console.log("- Source:", activeSource.name);
        console.log("- Path:", correctPath);
        
        alert("üîß Debug complete! Source v√† path ƒë√£ ƒë∆∞·ª£c t·ª± ƒë·ªông s·ª≠a.");
      } else {
        alert("‚ùå Kh√¥ng t√¨m th·∫•y source n√†o. Vui l√≤ng c·∫•u h√¨nh video source tr∆∞·ªõc.");
      }
      
    } catch (error) {
      console.error("‚ùå Debug failed:", error);
      alert("Debug th·∫•t b·∫°i. Check console ƒë·ªÉ xem chi ti·∫øt.");
    }
  };

  const countries = [
    "Vi·ªát Nam", "Nh·∫≠t B·∫£n", "H√†n Qu·ªëc", "Th√°i Lan", "Singapore",
    "M·ªπ", "Anh", "Ph√°p", "ƒê·ª©c", "√öc"
  ];

  return (
    <div className="p-6 flex gap-6 w-[100%]">
      <GeneralInfoForm
        country={country}
        setCountry={setCountry}
        timezone={timezone}
        setTimezone={setTimezone}
        brandName={brandName}
        setBrandName={setBrandName}
        workingDays={workingDays}
        setWorkingDays={setWorkingDays}
        fromTime={fromTime}
        setFromTime={setFromTime}
        toTime={toTime}
        setToTime={setToTime}
        handleCountryChange={handleCountryChange}
        handleFromTimeChange={handleFromTimeChange}
        handleToTimeChange={handleToTimeChange}
        handleWorkingDayChange={handleWorkingDayChange}
        handleSaveGeneralInfo={handleSaveGeneralInfo}
        countries={countries}
      />
      <ConfigForm
        inputPath={inputPath}
        setInputPath={setInputPath}
        outputPath={outputPath}
        setOutputPath={setOutputPath}
        defaultDays={defaultDays}
        setDefaultDays={setDefaultDays}
        minPackingTime={minPackingTime}
        setMinPackingTime={setMinPackingTime}
        maxPackingTime={maxPackingTime}
        setMaxPackingTime={setMaxPackingTime}
        frameRate={frameRate}
        setFrameRate={setFrameRate}
        frameInterval={frameInterval}
        setFrameInterval={setFrameInterval}
        videoBuffer={videoBuffer}
        setVideoBuffer={setVideoBuffer}
        error={error}
        handleOpenExplorer={handleOpenExplorer}
        handleShowCameraDialog={handleShowCameraDialogCustom}
        runDefaultOnStart={runDefaultOnStart}
        setRunDefaultOnStart={setRunDefaultOnStart}
        // üÜï NEW: Pass camera data from VtrackConfig to ConfigForm
        camerasFromParent={configFormCameras}
        selectedCamerasFromParent={configFormSelectedCameras}
        activeSourceFromParent={activeVideoSource}
        isLoadingCameras={loadingCameras}
        // ‚úÖ NEW: Add callback to receive camera updates from ConfigForm
        onCamerasUpdated={handleCamerasUpdate}
      />
      <ProcessingRegionForm
        videoPath={videoPath}
        setVideoPath={setVideoPath}
        qrSize={qrSize}
        setQrSize={setQrSize}
        handleAnalyzeRegions={handleAnalyzeRegions}
      />
      <CameraDialog
        showCameraDialog={showCameraDialog}
        setShowCameraDialog={setShowCameraDialog}
        cameras={cameras}
        selectedCameras={selectedCameras}
        handleCameraSelection={handleCameraSelection}
        handleSaveConfig={handleSaveConfigCustom}
      />
      
      {/* 
      {showCameraDebug && (
        <div className="camera-debug-panel">
          <h4>üîß Camera Debug</h4>
          <div>Form Cameras: {configFormCameras.length}</div>
          <div>Selected: {configFormSelectedCameras.length}</div>
          <div>Hook Cameras: {cameras.length}</div>
          <div>Loading: {loadingCameras ? "Yes" : "No"}</div>
          <div>Active Source: {activeVideoSource?.name}</div>
          <div>Input Path: {inputPath ? "Set" : "Unset"}</div>
          <div>Debug Server</div>
          <div>Auto Fix</div>
        </div>
      )}
      */}
    </div>
  );
};

export default VtrackConfig;
```
## üìÑ File: `Dashboard.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/Dashboard.js`

```javascript
import Sidebar from "./Sidebar";
import VtrackConfig from "./VtrackConfig";
import QueryComponent from "./QueryComponent";
import Account from "./Account";
import ProgramTab from "./components/program/ProgramTab";
import useProgramLogic from "./hooks/useProgramLogic";

const Dashboard = ({ setActiveMenu, activeMenu }) => {
  const {
    runningCard,
    fileList,
    customPath,
    showConfirmButton,
    firstRunCompleted,
    handleRunStop,
    handleConfirmRun,
    isRunning,
    setCustomPath,
  } = useProgramLogic();

  return (
    <div className="flex min-h-screen bg-gray-900 text-white font-montserrat">
      <Sidebar setActiveMenu={setActiveMenu} activeMenu={activeMenu} />
      <div className="flex-1 p-6 w-full">
        {activeMenu === "Ch∆∞∆°ng tr√¨nh" ? (
          <ProgramTab
            runningCard={runningCard}
            fileList={fileList}
            customPath={customPath}
            showConfirmButton={showConfirmButton}
            firstRunCompleted={firstRunCompleted}
            handleRunStop={handleRunStop}
            handleConfirmRun={handleConfirmRun}
            isRunning={isRunning}
            setCustomPath={setCustomPath}
          />
        ) : activeMenu === "C·∫•u h√¨nh" ? (
          <VtrackConfig />
        ) : activeMenu === "Truy v·∫•n" ? (
          <QueryComponent />
        ) : activeMenu === "T√†i kho·∫£n" ? (
          <Account />
        ) : (
          <div>
            <h1 className="text-3xl font-bold">ƒêang ph√°t tri·ªÉn: {activeMenu}</h1>
            <p>N·ªôi dung cho {activeMenu} s·∫Ω ƒë∆∞·ª£c th√™m sau.</p>
          </div>
        )}
      </div>
    </div>
  );
};

export default Dashboard;
```
## üìÑ File: `api.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/api.js`

```javascript
import axios from "axios";

const api = axios.create({
  baseURL: "http://localhost:8080",
});

export const getConfig = () => api.get("/config");
export const updateConfig = (configData) => api.post("/config", configData);
export const runQuery = (queryData) => api.post("/query", queryData);
export const runProgram = (programData) => api.post("/program", programData);
export const confirmRun = (confirmData) => api.post("/confirm-run", confirmData);
export const getCameras = () => api.get("/get-cameras");
export const cutVideos = (cutData) => api.post("/cut-videos", cutData);
export const analyzeRegions = (data) => api.post("/analyze-regions", data);
export const getFrames = (data) => api.post("/get-frames", data);
export const submitRois = (data) => api.post("/submit-rois", data);
export const sendHandDetection = (data) => api.post("/api/hand-detection", data);
export const getRoiFrame = () => api.get("/get-roi-frame");
export const getFinalRoiFrame = (cameraId, timestamp) => api.get(`/get-final-roi-frame?camera_id=${cameraId}&timestamp=${timestamp}`);

// Video Sources APIs
export const getSources = () => api.get("/get-sources");
export const addSources = (sourcesData) => api.post("/save-sources", sourcesData);
export const testSourceConnection = (sourceData) => api.post("/test-source", sourceData);
export const updateSource = (id, sourceData) => api.put(`/update-source/${id}`, sourceData);
export const deleteSource = (id) => api.delete(`/delete-source/${id}`);
export const toggleSource = (id, active) => api.post(`/toggle-source/${id}`, { active });

// NEW: Camera Detection APIs
export const detectCameras = (pathData) => api.post("/detect-cameras", pathData);
export const updateSourceCameras = (cameraData) => api.post("/update-source-cameras", cameraData);

export default api;
```
## üìÑ File: `setupTests.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/setupTests.js`

```javascript
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

```
## üìÑ File: `App.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/App.js`

```javascript
import "@fontsource/montserrat";
import { useState } from "react";
import Dashboard from "./Dashboard";

function App() {
  const [activeMenu, setActiveMenu] = useState("Ch∆∞∆°ng tr√¨nh");
  return (
    <div className="flex min-h-screen bg-gray-900 text-white font-montserrat">
      <Dashboard setActiveMenu={setActiveMenu} activeMenu={activeMenu} />
    </div>
  );
}

export default App;
```
## üìÑ File: `SearchModeSelector.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/ui/SearchModeSelector.js`

```javascript
const SearchModeSelector = ({ searchType, setSearchType }) => {
  return (
    <div className="mb-4">
      <label className="block mb-1">Lo·∫°i t√¨m ki·∫øm:</label>
      <div className="flex gap-4">
        <label className="flex items-center">
          <input
            type="radio"
            name="searchType"
            value="File"
            className="mr-1"
            checked={searchType === "File"}
            onChange={() => setSearchType("File")}
          />
          File
        </label>
        <label className="flex items-center">
          <input
            type="radio"
            name="searchType"
            value="Text"
            className="mr-1"
            checked={searchType === "Text"}
            onChange={() => setSearchType("Text")}
          />
          Text
        </label>
      </div>
    </div>
  );
};

export default SearchModeSelector;
```
## üìÑ File: `Button.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/ui/Button.js`

```javascript
const Button = ({ text }) => {
   return (
     <button className="bg-red-600 text-white font-bold py-2 px-4 rounded mt-4">
       {text}
     </button>
   );
 };
 
 export default Button;
```
## üìÑ File: `Card.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/ui/Card.js`

```javascript
import { useState } from "react";

const Card = ({ title, description, isRunning, onRunStop, onPathChange, isLocked }) => {
  const [path, setPath] = useState("");

  const handleOpenExplorer = () => {
    const input = document.createElement("input");
    input.type = "file";
    input.onchange = (e) => {
      const selectedPath = e.target.files[0]?.name || "";
      setPath(selectedPath);
      if (onPathChange) {
        onPathChange(selectedPath);
      }
    };
    input.click();
  };

  return (
    <div className="bg-gray-800 p-6 rounded-lg flex flex-col items-center h-full">
      <h3 className="text-lg font-bold mb-2">{title}</h3>
      <p className="mb-4 text-center flex-1">{description}</p>
      <div className="mt-auto w-full flex flex-col items-center">
        {title === "Ch·ªâ ƒë·ªãnh" && (
          <div className="mb-4 w-full">
            <div className="relative w-full">
              <input
                type="text"
                value={path}
                onChange={(e) => {
                  setPath(e.target.value);
                  if (onPathChange) {
                    onPathChange(e.target.value);
                  }
                }}
                placeholder="Nh·∫≠p ƒë∆∞·ªùng d·∫´n file..."
                className="w-full p-2 rounded bg-gray-700 text-white"
              />
              <button
                type="button"
                onClick={handleOpenExplorer}
                className="absolute right-2 top-1/2 transform -translate-y-1/2 text-white"
              >
                ...
              </button>
            </div>
          </div>
        )}
        {isLocked || (title === "L·∫ßn ƒë·∫ßu" && isRunning) ? (
          <button
            className="w-1/2 py-2 px-4 rounded font-bold text-white bg-gray-500"
            disabled
          >
            LOCKED
          </button>
        ) : (
          <button
            className={`w-1/2 py-2 px-4 rounded font-bold text-white ${
              isRunning && title !== "L·∫ßn ƒë·∫ßu" ? "bg-[#E82127]" : "bg-[#00D4FF]"
            }`}
            onClick={onRunStop}
            disabled={title === "Ch·ªâ ƒë·ªãnh" && !path && !isRunning}
          >
            {(isRunning && title !== "L·∫ßn ƒë·∫ßu") ? "STOP" : "RUN"}
          </button>
        )}
      </div>
    </div>
  );
};

export default Card;
```
## üìÑ File: `ResultList.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/result/ResultList.js`

```javascript
import React from "react";

const ResultList = ({ results, selectedVideos, setSelectedVideos, hasQueried }) => {
  const handleSelectVideo = (eventId) => {
    if (selectedVideos.includes(eventId)) {
      setSelectedVideos(selectedVideos.filter((id) => id !== eventId));
    } else {
      setSelectedVideos([...selectedVideos, eventId]);
    }
  };

  React.useEffect(() => {
    if (results.length > 0) {
      const newSelectedVideos = results.map(event => event.event_id);
      setSelectedVideos(newSelectedVideos);
    }
  }, [results]);

  return (
    <div className="flex-1 mb-4 bg-gray-700 rounded p-2 overflow-y-auto">
      {hasQueried ? (
        results.length > 0 ? (
          results.map((event, index) => (
            <label key={event.event_id} className="flex items-center mb-2">
              <input
                type="checkbox"
                className="mr-2"
                checked={selectedVideos.includes(event.event_id)}
                onChange={() => handleSelectVideo(event.event_id)}
              />
              {`${index + 1}. ${event.video_file}`}
            </label>
          ))
        ) : (
          <p>Kh√¥ng c√≥ k·∫øt qu·∫£</p>
        )
      ) : (
        <p>Vui l√≤ng th·ª±c hi·ªán truy v·∫•n</p>
      )}
    </div>
  );
};

export default ResultList;

```
## üìÑ File: `CutVideoSection.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/result/CutVideoSection.js`

```javascript
import api from "../../api"; // Th√™m import api ƒë·ªÉ g·ªçi /cut-videos

const CutVideoSection = ({ results, selectedVideos, setResults, setSelectedVideos, cutVideos, setCutVideos }) => {
  const handleCutVideos = async () => {
    if (selectedVideos.length === 0) {
      alert("Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt s·ª± ki·ªán ƒë·ªÉ c·∫Øt video.");
      return;
    }
    const videosToCut = results.filter((event) => selectedVideos.includes(event.event_id));
    try {
      const cutData = {
        selected_events: videosToCut,
      };
      const response = await api.post("/cut-videos", cutData); // G·ªçi API /cut-videos
      const cutFiles = response.data.cut_files || []; // L·∫•y danh s√°ch file t·ª´ ph·∫£n h·ªìi
      setCutVideos(prev => [...prev, ...cutFiles]); // T·ªëi ∆∞u v·ªõi prev
      setResults(results.filter((event) => !selectedVideos.includes(event.event_id)));
      setSelectedVideos([]);
    } catch (error) {
      console.error("Error cutting videos:", error);
      alert("C√≥ l·ªói x·∫£y ra khi c·∫Øt video. Vui l√≤ng th·ª≠ l·∫°i.");
    }
  };

  const handleRefresh = () => {
    setResults([]);
    setSelectedVideos([]);
    setCutVideos([]); // X√≥a danh s√°ch video ƒë√£ c·∫Øt
  };

  return (
    <>
      <div className="flex gap-4 mb-4">
        <button
          className="w-1/2 py-2 bg-red-600 text-white font-bold rounded"
          onClick={handleCutVideos}
        >
          C·∫Øt Video
        </button>
        <button
          className="w-1/2 py-2 px-4 rounded font-bold text-white bg-[#00D4FF]"
          onClick={handleRefresh}
        >
          Refresh
        </button>
      </div>
      <div className="flex-1 bg-gray-700 rounded p-2 overflow-y-auto">
        {cutVideos.map((video, index) => (
          <label key={index} className="flex items-center mb-2">
            <input type="checkbox" className="mr-2" />
            {`${index + 1}. ${video}`}
          </label>
        ))}
      </div>
    </>
  );
};

export default CutVideoSection;
```
## üìÑ File: `VideoCutter.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/result/VideoCutter.js`

```javascript
import { useState } from "react";
import api from "../../api"; // ƒêi·ªÅu ch·ªânh ƒë∆∞·ªùng d·∫´n t∆∞∆°ng ƒë·ªëi t·ª´ th∆∞ m·ª•c result

const VideoCutter = ({ results, selectedVideos, setResults, setSelectedVideos }) => {
  const [cutVideos, setCutVideos] = useState([]);
  const [selectedCutVideo, setSelectedCutVideo] = useState(null); // Th√™m tr·∫°ng th√°i ƒë·ªÉ l∆∞u video ƒë√£ c·∫Øt ƒë∆∞·ª£c ch·ªçn

  // H√†m x·ª≠ l√Ω y√™u c·∫ßu c·∫Øt video
  const handleCutVideos = async () => {
    if (selectedVideos.length === 0) {
      alert("Vui l√≤ng ch·ªçn √≠t nh·∫•t m·ªôt s·ª± ki·ªán ƒë·ªÉ c·∫Øt video.");
      return;
    }
    try {
      const selectedEvents = results.filter(event => selectedVideos.includes(event.event_id));
      const cutData = {
        selected_events: selectedEvents,
        // tracking_codes_filter s·∫Ω ƒë∆∞·ª£c th√™m sau n·∫øu c·∫ßn t·ª´ QueryComponent
      };

      const response = await api.post("/cut-videos", cutData); // G·ªçi API c·∫Øt video
      const cutFiles = response.data.cut_files || [];

      setCutVideos(prev => [...prev, ...cutFiles]); // C·∫≠p nh·∫≠t danh s√°ch video ƒë√£ c·∫Øt
      setResults(prev => prev.filter(event => !selectedVideos.includes(event.event_id))); // X√≥a s·ª± ki·ªán ƒë√£ c·∫Øt
      setSelectedVideos([]); // Reset danh s√°ch ch·ªçn
    } catch (error) {
      console.error("Error cutting videos:", error);
      alert("C√≥ l·ªói x·∫£y ra khi c·∫Øt video. Vui l√≤ng th·ª≠ l·∫°i.");
    }
  };

  const handleRefresh = () => {
    setResults([]);
    setSelectedVideos([]);
    setCutVideos([]);
    setSelectedCutVideo(null); // Reset video ƒë√£ ch·ªçn khi refresh
  };

  // H√†m x·ª≠ l√Ω khi nh·∫•n n√∫t "Play Video"
  const handlePlayVideo = () => {
    if (!selectedCutVideo) {
      alert("Vui l√≤ng ch·ªçn m·ªôt video ƒë·ªÉ ph√°t");
      return;
    }
    alert(`ƒêang ph√°t video "${selectedCutVideo}" ƒë∆∞·ª£c ch·ªçn`);
  };

  return (
    <>
      <div className="flex gap-4 mb-4">
        <button
          className="w-1/3 py-2 bg-red-600 text-white font-bold rounded"
          onClick={handleCutVideos}
        >
          C·∫Øt Video
        </button>
        <button
          className="w-1/3 py-2 px-4 rounded font-bold text-white bg-[#00D4FF]"
          onClick={handleRefresh}
        >
          Refresh
        </button>
        <button
          className="w-1/3 py-2 px-4 rounded font-bold text-white bg-green-600"
          onClick={handlePlayVideo}
        >
          Play Video
        </button>
      </div>
      <div className="flex-1 bg-gray-700 rounded p-2 overflow-y-auto">
        {cutVideos.map((video, index) => (
          <label
            key={index}
            className="flex items-center mb-2 cursor-pointer hover:bg-gray-600 transition duration-300"
            onClick={() => setSelectedCutVideo(video)}
          >
            <input
              type="radio"
              name="cutVideo"
              className="mr-2"
              checked={selectedCutVideo === video}
              onChange={() => setSelectedCutVideo(video)}
            />
            <span className="flex-1 truncate">{`${index + 1}. ${video}`}</span>
          </label>
        ))}
      </div>
    </>
  );
};

export default VideoCutter;
```
## üìÑ File: `CloudConfigurationForm.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/CloudConfigurationForm.js`

```javascript
// components/config/GoogleDriveAuthButton.js - FIXED: Origin & COOP Issues
import React, { useState, useEffect } from 'react';

const GoogleDriveAuthButton = ({ 
  onAuth, 
  isAuthenticated = false, 
  isLoading = false, 
  userEmail = null,
  className = '' 
}) => {
  const [authState, setAuthState] = useState({
    loading: isLoading,
    authenticated: isAuthenticated,
    userEmail: userEmail,
    error: null,
    sessionToken: null
  });

  // üîí SECURITY: Session validation and auto-refresh
  useEffect(() => {
    const validateSession = async () => {
      const token = sessionStorage.getItem('session_token');
      if (token) {
        try {
          const response = await fetch('http://localhost:8080/api/cloud/auth-status', {
            method: 'GET',
            headers: { 
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            credentials: 'include'
          });
          
          if (response.ok) {
            const result = await response.json();
            if (result.authenticated) {
              setAuthState(prev => ({
                ...prev,
                authenticated: true,
                userEmail: result.user_email,
                sessionToken: token
              }));
            } else {
              // Session expired, clean up
              sessionStorage.removeItem('session_token');
              setAuthState(prev => ({
                ...prev,
                authenticated: false,
                userEmail: null,
                sessionToken: null
              }));
            }
          }
        } catch (error) {
          console.error('Session validation failed:', error);
          sessionStorage.removeItem('session_token');
        }
      }
    };

    validateSession();
  }, []);

  // üîí SECURITY: Auto-refresh session token
  useEffect(() => {
    let refreshInterval;
    
    if (authState.authenticated && authState.sessionToken) {
      refreshInterval = setInterval(async () => {
        try {
          const response = await fetch('http://localhost:8080/api/cloud/auth-status', {
            method: 'GET',
            headers: { 
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authState.sessionToken}`
            },
            credentials: 'include'
          });
          
          if (response.ok) {
            const result = await response.json();
            if (result.session_token) {
              sessionStorage.setItem('session_token', result.session_token);
              setAuthState(prev => ({
                ...prev,
                sessionToken: result.session_token
              }));
            }
          }
        } catch (error) {
          console.error('Session refresh failed:', error);
        }
      }, 25 * 60 * 1000); // Refresh every 25 minutes
    }
    
    return () => {
      if (refreshInterval) {
        clearInterval(refreshInterval);
      }
    };
  }, [authState.authenticated, authState.sessionToken]);

  // üîß FIXED: Handle postMessage from OAuth popup with correct origin handling
  useEffect(() => {
    const handleOAuthMessage = (event) => {
      console.log('üì¨ Received OAuth message:', event.data);
      console.log('üìç Message origin:', event.origin);

      // üîß FIX: Accept messages from OAuth callback (port 8080)
      if (event.origin !== 'http://localhost:8080') {
        console.warn('üö´ Ignoring message from unauthorized origin:', event.origin);
        return;
      }

      if (event.data.type === 'OAUTH_SUCCESS') {
        console.log('‚úÖ OAuth success via postMessage:', event.data);
        
        // üîí SECURITY: Handle session token instead of credentials
        const userData = event.data.user_info || event.data.user || {};
        const userEmail = event.data.user_email || userData.email || 'unknown';
        const folders = event.data.folders || [];
        const sessionToken = event.data.session_token;
        
        console.log('üìß User email:', userEmail);
        console.log('üìÅ Folders count:', folders.length);
        console.log('üîë Session token received:', !!sessionToken);
        
        // üîí SECURITY: Store session token securely
        if (sessionToken) {
          sessionStorage.setItem('session_token', sessionToken);
          console.log('üíæ Session token stored in sessionStorage');
        }
        
        setAuthState(prev => ({
          ...prev,
          loading: false,
          authenticated: true,
          userEmail: userEmail,
          error: null,
          sessionToken: sessionToken
        }));

        // üîí SECURITY: Notify parent component WITHOUT credentials
        if (onAuth) {
          onAuth({
            success: true,
            user_email: userEmail,
            user_info: userData,
            folders: folders,
            message: `Authenticated as ${userEmail}`,
            backend_port: event.data.backend_port || 8080,
            session_token: sessionToken,
            lazy_loading_enabled: event.data.lazy_loading_enabled || false
          });
        }

      } else if (event.data.type === 'OAUTH_ERROR') {
        console.error('‚ùå OAuth error via postMessage:', event.data.error);
        
        setAuthState(prev => ({
          ...prev,
          loading: false,
          authenticated: false,
          error: event.data.error
        }));

        if (onAuth) {
          onAuth({
            success: false,
            message: event.data.error || 'Authentication failed',
            error: event.data.details || ''
          });
        }
      }
    };

    // Listen for OAuth messages
    window.addEventListener('message', handleOAuthMessage);

    return () => {
      window.removeEventListener('message', handleOAuthMessage);
    };
  }, [onAuth]);

  const handleAuthenticate = async () => {
    if (authState.loading) return;

    try {
      setAuthState(prev => ({ ...prev, loading: true, error: null }));
      console.log('üîê Starting Google Drive authentication...');

      // Step 1: Initiate OAuth flow
      const response = await fetch('http://localhost:8080/api/cloud/authenticate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        credentials: 'include',
        body: JSON.stringify({
          provider: 'google_drive',
          action: 'initiate_auth',
          redirect_uri: 'http://localhost:8080/api/cloud/oauth/callback'
        })
      });

      if (!response.ok) {
        throw new Error(`Authentication request failed: ${response.status}`);
      }

      const authData = await response.json();

      if (!authData.success || !authData.auth_url) {
        throw new Error(authData.message || 'Failed to get authorization URL');
      }

      console.log('üåê Opening OAuth popup...', authData.auth_url);

      // Step 2: Open OAuth popup - IMPROVED with COOP workaround
      await handleOAuthPopup(authData.auth_url);

    } catch (error) {
      console.error('‚ùå Authentication error:', error);
      setAuthState(prev => ({
        ...prev,
        loading: false,
        error: error.message
      }));

      if (onAuth) {
        onAuth({
          success: false,
          message: error.message || 'Authentication failed'
        });
      }
    }
  };

  // üîß FIXED: Better popup handling with COOP workaround
  const handleOAuthPopup = async (authUrl) => {
    return new Promise((resolve, reject) => {
      const popup = window.open(
        authUrl,
        'google_drive_auth',
        'width=600,height=700,scrollbars=yes,resizable=yes,popup=yes'
      );

      if (!popup) {
        reject(new Error('Popup blocked. Please allow popups for this site.'));
        return;
      }

      let checkCompleted = false;

      // üÜï NEW: Use postMessage instead of polling popup.closed (COOP workaround)
      const handlePopupMessage = (event) => {
        // üîß FIX: Only accept messages from OAuth callback
        if (event.origin !== 'http://localhost:8080') return;
        
        if (event.data.type === 'OAUTH_SUCCESS' || event.data.type === 'OAUTH_ERROR') {
          if (!checkCompleted) {
            checkCompleted = true;
            console.log('‚úÖ OAuth popup completed via postMessage');
            
            try {
              popup.close();
            } catch (e) {
              console.log('üìù Note: Could not close popup (COOP prevents access)');
            }
            
            window.removeEventListener('message', handlePopupMessage);
            resolve();
          }
        }
      };

      window.addEventListener('message', handlePopupMessage);

      // üîß TIMEOUT: Auto-timeout after 5 minutes
      setTimeout(() => {
        if (!checkCompleted) {
          checkCompleted = true;
          window.removeEventListener('message', handlePopupMessage);
          
          try {
            popup.close();
          } catch (e) {
            console.log('üìù Note: Could not close popup (COOP prevents access)');
          }
          
          reject(new Error('Authentication timeout (5 minutes)'));
        }
      }, 300000);
    });
  };

  // üîí SECURITY: Updated disconnect handler with session cleanup
  const handleDisconnect = async () => {
    try {
      setAuthState(prev => ({ ...prev, loading: true }));
      
      const response = await fetch('http://localhost:8080/api/cloud/disconnect', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${authState.sessionToken}`
        },
        credentials: 'include',
        body: JSON.stringify({
          provider: 'google_drive',
          user_email: authState.userEmail
        })
      });

      const result = await response.json();
      
      if (result.success) {
        // üîí SECURITY: Clean up session token
        sessionStorage.removeItem('session_token');
        
        setAuthState({
          loading: false,
          authenticated: false,
          userEmail: null,
          error: null,
          sessionToken: null
        });

        if (onAuth) {
          onAuth({
            success: false,
            message: 'Disconnected from Google Drive',
            disconnected: true
          });
        }
      } else {
        throw new Error(result.message || 'Disconnect failed');
      }
      
    } catch (error) {
      console.error('‚ùå Disconnect error:', error);
      setAuthState(prev => ({ ...prev, loading: false, error: error.message }));
    }
  };

  // Update state when props change
  useEffect(() => {
    setAuthState(prev => ({
      ...prev,
      loading: isLoading,
      authenticated: isAuthenticated,
      userEmail: userEmail
    }));
  }, [isLoading, isAuthenticated, userEmail]);

  // Component render
  return (
    <div className={`google-drive-auth-button ${className}`}>
      {!authState.authenticated ? (
        <div className="auth-section">
          <button
            onClick={handleAuthenticate}
            disabled={authState.loading}
            className={`px-6 py-3 rounded-lg font-medium transition-all duration-200 ${
              authState.loading
                ? 'bg-gray-400 text-gray-600 cursor-not-allowed'
                : 'bg-blue-600 hover:bg-blue-700 text-white shadow-lg hover:shadow-xl transform hover:scale-105'
            }`}
          >
            {authState.loading ? (
              <span className="flex items-center">
                <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Authenticating...
              </span>
            ) : (
              <span className="flex items-center">
                üîê Connect to Google Drive
                <span className="ml-2 text-xs opacity-75">(Required)</span>
              </span>
            )}
          </button>
          
          <div className="mt-2 text-xs text-gray-400">
            Click to authenticate and access your Google Drive folders
          </div>
        </div>
      ) : (
        <div className="authenticated-section">
          <div className="flex items-center justify-between p-4 bg-green-100 border border-green-400 rounded-lg">
            <div className="flex items-center">
              <span className="text-2xl mr-3">‚úÖ</span>
              <div>
                <div className="font-medium text-green-800">
                  Connected to Google Drive
                </div>
                <div className="text-sm text-green-600">
                  {authState.userEmail}
                </div>
              </div>
            </div>
            
            <button
              onClick={handleDisconnect}
              disabled={authState.loading}
              className="px-3 py-1 bg-red-600 hover:bg-red-700 disabled:bg-gray-400 text-white rounded text-sm transition-colors"
            >
              {authState.loading ? 'Disconnecting...' : 'Disconnect'}
            </button>
          </div>
        </div>
      )}

      {/* Error Display */}
      {authState.error && (
        <div className="error-display mt-3 p-3 bg-red-100 border border-red-400 rounded-lg">
          <div className="flex items-center justify-between">
            <div className="text-red-700">
              <div className="font-medium">Authentication Error</div>
              <div className="text-sm mt-1">{authState.error}</div>
            </div>
            <button
              onClick={() => setAuthState(prev => ({ ...prev, error: null }))}
              className="text-red-500 hover:text-red-700 text-lg leading-none"
            >
              √ó
            </button>
          </div>

          {/* Error Actions */}
          <div className="mt-3 flex gap-2">
            <button
              onClick={handleAuthenticate}
              className="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700"
            >
              Try Again
            </button>
            <button
              onClick={() => window.location.reload()}
              className="px-3 py-1 bg-gray-600 text-white rounded text-sm hover:bg-gray-700"
            >
              Refresh Page
            </button>
          </div>
        </div>
      )}

      {/* Help Text */}
      {!authState.authenticated && !authState.error && (
        <div className="help-text mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg">
          <div className="text-sm text-blue-700">
            <div className="font-medium mb-1">üîí Secure Authentication</div>
            <ul className="text-xs space-y-1 ml-4">
              <li>‚Ä¢ Opens Google's official OAuth login</li>
              <li>‚Ä¢ VTrack never sees your Google password</li>
              <li>‚Ä¢ Only folder access permission requested</li>
              <li>‚Ä¢ Can be revoked anytime from Google Account settings</li>
            </ul>
          </div>
        </div>
      )}

      {/* Development Debug Info */}
      {process.env.NODE_ENV === 'development' && (
        <details className="debug-info mt-3 p-2 bg-gray-100 rounded text-xs">
          <summary className="cursor-pointer text-gray-600">üîß Debug Info</summary>
          <pre className="mt-2 text-gray-500 overflow-auto">
            {JSON.stringify({
              authenticated: authState.authenticated,
              loading: authState.loading,
              userEmail: authState.userEmail,
              hasError: !!authState.error,
              errorMessage: authState.error,
              hasSessionToken: !!authState.sessionToken,
              backendPort: 8080
            }, null, 2)}
          </pre>
        </details>
      )}
    </div>
  );
};

export default GoogleDriveAuthButton;
```
## üìÑ File: `ConfigForm.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/ConfigForm.js`

```javascript
import React, { useState, useEffect, useCallback } from 'react';
import AddSourceModal from './AddSourceModal';

const ConfigForm = ({
  inputPath,
  setInputPath,
  outputPath,
  setOutputPath,
  defaultDays,
  setDefaultDays,
  minPackingTime,
  setMinPackingTime,
  maxPackingTime,
  setMaxPackingTime,
  frameRate,
  setFrameRate,
  frameInterval,
  setFrameInterval,
  videoBuffer,
  setVideoBuffer,
  error,
  handleOpenExplorer,
  handleShowCameraDialog,
  runDefaultOnStart,
  setRunDefaultOnStart,
  
  // üÜï NEW: Receive camera data from VtrackConfig
  camerasFromParent = [],
  selectedCamerasFromParent = [],
  activeSourceFromParent = null,
  isLoadingCameras = false,
  
  // ‚úÖ NEW: Callback to notify parent about camera changes
  onCamerasUpdated,
}) => {
  // ‚úÖ USE: Data from parent instead of local state
  const [activeSource, setActiveSource] = useState(activeSourceFromParent);
  const [sourceCameras, setSourceCameras] = useState(camerasFromParent);
  const [selectedCameras, setSelectedCameras] = useState(selectedCamerasFromParent);
  const [isLoadingSource, setIsLoadingSource] = useState(isLoadingCameras);
  
  // ‚úÖ KEEP: Source management state only
  const [showAddSourceModal, setShowAddSourceModal] = useState(false);
  const [showUpdateSourceModal, setShowUpdateSourceModal] = useState(false);

  // ‚úÖ NEW: Sync props to local state
  useEffect(() => {
    setActiveSource(activeSourceFromParent);
    setSourceCameras(camerasFromParent);
    setSelectedCameras(selectedCamerasFromParent);
    setIsLoadingSource(isLoadingCameras);
  }, [activeSourceFromParent, camerasFromParent, selectedCamerasFromParent, isLoadingCameras]);

  // API functions
  const addSources = async (sourcesData) => {
    const response = await fetch('/api/config/save-sources', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(sourcesData)
    });
    return response.json();
  };

  const deleteSource = async (sourceId) => {
    const response = await fetch(`/api/config/delete-source/${sourceId}`, {
      method: 'DELETE'
    });
    return response.json();
  };

  const testSourceConnection = async (sourceData) => {
    const response = await fetch('/api/config/test-source', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(sourceData)
    });
    return response.json();
  };

  const updateSourceCameras = async (sourceId, selectedCameras) => {
    const response = await fetch('/api/config/update-source-cameras', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ source_id: sourceId, selected_cameras: selectedCameras })
    });
    return response.json();
  };

  // ‚úÖ NEW: Load cameras from source after adding
  const loadCamerasFromSource = async (sourceData) => {
    try {
      console.log("üîÑ Loading cameras from new source:", sourceData.name);
      
      if (sourceData.source_type === 'cloud') {
        // For cloud sources, try to get cameras from config
        const cloudCameras = sourceData.config?.selected_cameras || [];
        if (cloudCameras.length > 0) {
          console.log("‚òÅÔ∏è Found cloud cameras:", cloudCameras);
          setSourceCameras(cloudCameras);
          setSelectedCameras(cloudCameras);
          return cloudCameras;
        } else {
          console.log("‚òÅÔ∏è No cameras in cloud config, will sync later");
        }
      } else if (sourceData.source_type === 'local') {
        // For local sources, detect camera folders
        const response = await fetch('/api/config/detect-cameras', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ path: sourceData.path })
        });
        
        if (response.ok) {
          const data = await response.json();
          const cameras = data.cameras || [];
          console.log("üìÅ Detected local cameras:", cameras);
          setSourceCameras(cameras);
          return cameras;
        }
      }
      
      return [];
    } catch (error) {
      console.error("‚ùå Error loading cameras from source:", error);
      return [];
    }
  };

  // ‚úÖ ENHANCED: Simple overwrite with fresh camera reload
  const handleAddSource = async (sourceData) => {
    try {
      console.log('Adding source:', sourceData);
      setIsLoadingSource(true);
      
      // ‚úÖ STEP 1: Try normal add first
      let response = await fetch('/api/config/save-sources', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ sources: [sourceData] })
      });
      
      let result = await response.json();
      
      // ‚úÖ STEP 2: If duplicate, automatically overwrite
      if (!response.ok && result.error && result.error.includes('already exists')) {
        console.log("üîÑ Source exists, overwriting automatically...");
        
        // Add overwrite flag and retry
        const overwriteData = { 
          sources: [{ ...sourceData, overwrite: true }] 
        };
        
        response = await fetch('/api/config/save-sources', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(overwriteData)
        });
        
        result = await response.json();
        
        if (!response.ok || result.error) {
          throw new Error(result.error || 'Failed to overwrite source');
        }
        
        console.log("‚úÖ Source overwritten successfully");
      } else if (!response.ok || result.error) {
        throw new Error(result.error || `Server error: ${response.status}`);
      }
      
      // ‚úÖ STEP 3: Update UI state
      setActiveSource(sourceData);
      
      // ‚úÖ CRITICAL FIX: Reload cameras from server after source change
      console.log("üîÑ Reloading cameras from server after source change...");
      
      let freshCameras = [];
      try {
        const camerasResponse = await fetch('http://localhost:8080/api/config/get-processing-cameras', {
          method: 'GET',
          headers: { 'Content-Type': 'application/json' }
        });
        
        if (camerasResponse.ok) {
          const camerasData = await camerasResponse.json();
          freshCameras = camerasData.selected_cameras || [];
          
          console.log("‚úÖ Reloaded fresh cameras from server:", freshCameras);
          
          // Update local camera state
          setSourceCameras(freshCameras);
          setSelectedCameras(freshCameras);
          
          // ‚úÖ NEW: Notify parent component about camera changes
          if (onCamerasUpdated) {
            onCamerasUpdated(freshCameras, freshCameras, sourceData);
            console.log("‚úÖ Notified parent component about camera changes");
          }
          
          console.log("‚úÖ Updated local camera state with fresh data");
        } else {
          console.error("‚ùå Failed to reload cameras from server");
          // Fallback to local camera detection
          freshCameras = await loadCamerasFromSource(sourceData);
        }
      } catch (cameraError) {
        console.error("‚ùå Error reloading cameras:", cameraError);
        // Fallback to local camera detection
        freshCameras = await loadCamerasFromSource(sourceData);
      }
      
      const workingPath = getWorkingPathForSource(sourceData);
      setInputPath(workingPath);
      
      setShowAddSourceModal(false);
      
      // ‚úÖ STEP 4: Success message with fresh camera count
      alert(`‚úÖ ${sourceData.source_type.toUpperCase()} source configured successfully!\n\nSource: "${sourceData.name}"\nCameras: ${freshCameras.length} detected\n\nCamera data refreshed from server.`);
      
      console.log("‚úÖ Source setup completed with fresh camera data");
      
    } catch (error) {
      console.error('‚ùå Error setting up source:', error);
      alert(`‚ùå Failed to setup source: ${error.message}`);
    } finally {
      setIsLoadingSource(false);
    }
  };

  // Update Source Handler
  const handleUpdateSource = () => {
    if (!activeSource) return;
    setShowUpdateSourceModal(true);
  };

  // ‚úÖ SIMPLIFIED: Clear source without complex delete logic
  const handleChangeSourceType = async () => {
    if (!activeSource) return;
    
    if (!window.confirm(`Remove current source "${activeSource.name}" to add a new one?`)) return;
    
    try {
      // ‚úÖ FIX: Handle undefined ID gracefully
      if (activeSource.id) {
        // Delete current source if ID exists
        await deleteSource(activeSource.id);
        console.log("‚úÖ Source deleted successfully");
      } else {
        console.log("‚ö†Ô∏è No source ID found, clearing local state only");
      }
      
    } catch (error) {
      console.error('‚ùå Error removing source:', error);
      console.log("‚ö†Ô∏è Delete failed, but continuing with local state reset");
    }
    
    // ‚úÖ ALWAYS reset local state regardless of delete success/failure
    setActiveSource(null);
    setSourceCameras([]);
    setSelectedCameras([]);
    setInputPath('');
    
    // ‚úÖ NEW: Notify parent about state reset
    if (onCamerasUpdated) {
      onCamerasUpdated([], [], null);
    }
    
    alert('Source cleared. You can now add a new source.');
  };

  const handleUpdateComplete = () => {
    // ‚úÖ SIMPLIFIED: Just close modal and soft refresh data
    setShowUpdateSourceModal(false);
    
    // ‚úÖ Optional: Reload source data from backend if needed
    setTimeout(async () => {
      try {
        const response = await fetch('/api/config/get-sources');
        const data = await response.json();
        const sources = data.sources || [];
        const currentActiveSource = sources.find(s => s.active) || sources[0];
        
        if (currentActiveSource) {
          setActiveSource(currentActiveSource);
          const cameras = await loadCamerasFromSource(currentActiveSource);
          console.log("üîÑ Refreshed source data after update");
        }
      } catch (error) {
        console.error("‚ùå Error refreshing source data:", error);
      }
    }, 500);
  };

  const formatDate = (dateString) => {
    if (!dateString) return 'Unknown';
    try {
      return new Date(dateString).toLocaleString('vi-VN', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        timeZone: 'Asia/Ho_Chi_Minh'
      });
    } catch {
      return dateString;
    }
  };

  // Get source type display info
  const getSourceTypeInfo = (sourceType) => {
    const sourceTypes = {
      local: {
        icon: 'üìÅ',
        name: 'LOCAL STORAGE',
        color: 'bg-blue-600'
      },
      cloud: {
        icon: '‚òÅÔ∏è',
        name: 'CLOUD STORAGE',
        color: 'bg-cyan-600'
      }
    };
    return sourceTypes[sourceType] || { icon: '‚ùì', name: 'UNKNOWN', color: 'bg-gray-600' };
  };

  // ‚úÖ Helper to get working path for different source types
  const getWorkingPathForSource = (source) => {
    if (!source) return "";
    
    switch (source.source_type) {
      case 'local':
        return source.path;
      case 'cloud':
        return `/Users/annhu/vtrack_app/V_Track/cloud_sync/${source.name}`;
      default:
        return source.path;
    }
  };

  return (
    <div className="w-[25%] bg-gray-800 p-6 rounded-lg flex flex-col">
      <h1 className="text-3xl font-bold mb-4">C·∫•u h√¨nh</h1>
      {error && <div style={{ color: 'red' }}>{error}</div>}
      
      {/* Single Active Video Source Section */}
      <div className="mb-6 p-4 bg-gray-700 rounded-lg">
        <div className="flex justify-between items-center mb-3">
          <h3 className="text-lg font-bold text-white">Current Video Input Source</h3>
        </div>

        {isLoadingSource ? (
          <div className="text-center py-4">
            <div className="text-gray-400 text-sm">Loading source...</div>
          </div>
        ) : activeSource ? (
          <div className="bg-gray-600 p-4 rounded-lg">
            <div className="flex items-center gap-2 mb-3">
              <span className="font-medium text-white text-lg">{activeSource.name}</span>
              <span className="px-2 py-1 rounded text-xs bg-green-600 text-white">
                Active
              </span>
            </div>
            
            {/* Enhanced Source Type Display */}
            <div className="flex items-center gap-2 mb-2">
              <span className="text-sm text-gray-300"><strong>Type:</strong></span>
              <div className="flex items-center gap-1">
                <span className="text-sm">{getSourceTypeInfo(activeSource.source_type).icon}</span>
                <span className={`px-2 py-1 rounded text-xs text-white font-medium ${getSourceTypeInfo(activeSource.source_type).color}`}>
                  {getSourceTypeInfo(activeSource.source_type).name}
                </span>
              </div>
            </div>
            
            <div className="text-gray-300 text-sm mb-2 break-all">
              <strong>Path:</strong> {activeSource.path}
            </div>
            
            <div className="text-gray-300 text-sm mb-2">
              <strong>Added:</strong> {formatDate(activeSource.created_at)}
            </div>
            
            {/* ‚úÖ UPDATED: Camera Information */}
            {(activeSource.source_type === 'local' || 
              activeSource.source_type === 'cloud') && (
              <div className="text-gray-300 text-sm mb-3">
                <strong>Cameras:</strong>{' '}
                {sourceCameras.length > 0 ? (
                  <span>
                    {selectedCameras.length} selected of {sourceCameras.length} detected
                    <div className="mt-1 text-xs">
                      {selectedCameras.length > 0 ? (
                        <span className="text-green-300">
                          Active: {selectedCameras.slice(0, 3).join(', ')}
                          {selectedCameras.length > 3 && ` +${selectedCameras.length - 3} more`}
                        </span>
                      ) : (
                        <span className="text-yellow-300">No cameras selected</span>
                      )}
                    </div>
                    {sourceCameras.length > selectedCameras.length && (
                      <div className="text-xs text-gray-400">
                        Available: {sourceCameras.filter(cam => !selectedCameras.includes(cam)).slice(0, 2).join(', ')}
                        {sourceCameras.filter(cam => !selectedCameras.includes(cam)).length > 2 && '...'}
                      </div>
                    )}
                  </span>
                ) : isLoadingSource ? (
                  <span className="text-blue-300">Loading cameras...</span>
                ) : (
                  <span className="text-gray-400">
                    {activeSource.source_type === 'cloud' ? 'No cameras synced' :
                     'No camera folders detected'}
                  </span>
                )}
              </div>
            )}            
            
            {/* Action Buttons */}
            <div className="flex justify-end gap-2">
              <button
                onClick={handleUpdateSource}
                className="px-4 py-2 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm font-medium"
              >
                Update
              </button>
              <button
                onClick={handleChangeSourceType}
                className="px-4 py-2 bg-orange-600 hover:bg-orange-700 text-white rounded text-sm font-medium"
              >
                Change
              </button>
            </div>
          </div>
        ) : (
          <div className="text-center py-6">
            <div className="text-gray-400 text-sm mb-3">
              No video source configured yet.
            </div>
            <button
              onClick={() => setShowAddSourceModal(true)}
              className="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded font-medium"
            >
              Add Video Source
            </button>
          </div>
        )}
      </div>

      {/* ‚úÖ FIX: Input Path Section - DISTINGUISH CLOUD vs LOCAL */}
      <div className="mb-6 p-4 bg-gray-700 rounded-lg">
        <h3 className="text-lg font-bold text-white mb-3">Input Video Path</h3>
        
        {activeSource ? (
          <div className="bg-gray-600 p-3 rounded">
            <div className="text-sm text-gray-300 mb-1">
              <strong>Source:</strong> {activeSource.name}
            </div>
            
            {activeSource.source_type === 'local' ? (
              <>
                <div className="text-sm text-gray-300 mb-1">
                  <strong>File System Path:</strong> {activeSource.path}
                </div>
                <div className="text-sm text-gray-300 mb-1">
                  <strong>Processing Path:</strong> {getWorkingPathForSource(activeSource)}
                </div>
                <div className="mt-2 text-xs text-green-300">
                  üìÅ Videos will be processed directly from this location
                </div>
              </>
            ) : activeSource.source_type === 'cloud' ? (
              <>
                <div className="text-sm text-gray-300 mb-1">
                  <strong>Cloud Connection:</strong> {activeSource.path}
                </div>
                <div className="text-sm text-gray-300 mb-1">
                  <strong>Sync Directory:</strong> {getWorkingPathForSource(activeSource)}
                </div>
                <div className="mt-2 text-xs text-cyan-300">
                  ‚òÅÔ∏è Cloud files will be synced to local directory for processing
                </div>
              </>
            ) : (
              <>
                <div className="text-sm text-gray-300 mb-1">
                  <strong>Source Path:</strong> {activeSource.path}
                </div>
                <div className="text-sm text-gray-300 mb-1">
                  <strong>Working Path:</strong> {getWorkingPathForSource(activeSource)}
                </div>
                <div className="mt-2 text-xs text-yellow-300">
                  ‚ö†Ô∏è Source type: {activeSource.source_type}
                </div>
              </>
            )}
            
            <div className="text-sm text-gray-300">
              <strong>Type:</strong> {getSourceTypeInfo(activeSource.source_type).name}
            </div>
            <div className="mt-2 text-xs text-green-300">
              ‚úÖ Input path automatically configured from video source
            </div>
          </div>
        ) : (
          <div className="text-center py-4 bg-gray-600 rounded">
            <div className="text-gray-400 text-sm mb-3">
              No video source configured. Input path will be empty.
            </div>
            <button
              onClick={() => setShowAddSourceModal(true)}
              className="bg-green-600 hover:bg-green-700 text-white px-4 py-2 rounded text-sm font-medium"
            >
              Add Video Source First
            </button>
          </div>
        )}
      </div>

      {/* Legacy Input Path Field - Hidden khi c√≥ video source */}
      {!activeSource && (
        <div className="mb-4">
          <label className="block mb-1">Legacy Input Path (Deprecated):</label>
          <div className="relative w-full">
            <input
              type="text"
              value={inputPath}
              onChange={(e) => setInputPath(e.target.value)}
              placeholder="Please add a video source instead"
              className="w-full p-2 rounded bg-gray-700 text-white"
              disabled
            />
            <div className="text-xs text-yellow-400 mt-1">
              ‚ö†Ô∏è Please use "Add Video Source" button above instead
            </div>
          </div>
        </div>
      )}

      <div className="mb-4">
        <label className="block mb-1">V·ªã tr√≠ Output Video:</label>
        <div className="relative w-full">
          <input
            type="text"
            value={outputPath}
            onChange={(e) => setOutputPath(e.target.value)}
            placeholder="V·ªã tr√≠ Output Video (e.g., /Users/annhu/vtrack_app/V_Track/output_clips)"
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
          <button
            type="button"
            onClick={() => handleOpenExplorer("output")}
            className="absolute right-2 top-1/2 transform -translate-y-1/2 text-white"
          >
            ...
          </button>
        </div>
      </div>
      
      <div className="flex flex-col gap-4 mb-4">
        <div>
          <label className="block mb-1">Th·ªùi gian l∆∞u tr·ªØ (ng√†y):</label>
          <input
            type="number"
            value={defaultDays}
            onChange={(e) => setDefaultDays(Number(e.target.value))}
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
        <div>
          <label className="block mb-1">Th·ªùi gian ƒë√≥ng h√†ng nhanh nh·∫•t (gi√¢y):</label>
          <input
            type="number"
            value={minPackingTime}
            onChange={(e) => setMinPackingTime(Number(e.target.value))}
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
        <div>
          <label className="block mb-1">Th·ªùi gian ƒë√≥ng h√†ng ch·∫≠m nh·∫•t (gi√¢y):</label>
          <input
            type="number"
            value={maxPackingTime}
            onChange={(e) => setMaxPackingTime(Number(e.target.value))}
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
        <div>
          <label className="block mb-1">T·ªëc ƒë·ªô frame:</label>
          <input
            type="number"
            value={frameRate}
            onChange={(e) => setFrameRate(Number(e.target.value))}
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
        <div>
          <label className="block mb-1">Kho·∫£ng c√°ch Frame:</label>
          <input
            type="number"
            value={frameInterval}
            onChange={(e) => setFrameInterval(Number(e.target.value))}
            min="2"
            max="30"
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
        <div>
          <label className="block mb-1">Buffer Video (gi√¢y):</label>
          <input
            type="number"
            value={videoBuffer}
            onChange={(e) => setVideoBuffer(Number(e.target.value))}
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
      </div>
      
      <div className="mt-auto flex justify-center">
        <button
          onClick={handleShowCameraDialog}
          className="w-1/2 py-2 bg-blue-600 text-white font-bold rounded"
        >
          G·ª≠i
        </button>
      </div>

      {/* Enhanced AddSourceModal */}
      {showAddSourceModal && (
        <AddSourceModal
          show={showAddSourceModal}
          onClose={() => setShowAddSourceModal(false)}
          onAdd={handleAddSource}
          testSourceConnection={testSourceConnection}
        />
      )}

      {/* Update Source Modal */}
      {showUpdateSourceModal && activeSource && (
        <SimpleUpdateSourceModal
          show={showUpdateSourceModal}
          source={activeSource}
          sourceCameras={sourceCameras}
          selectedCameras={selectedCameras}
          onClose={() => setShowUpdateSourceModal(false)}
          onUpdate={handleUpdateComplete}
          testSourceConnection={testSourceConnection}
          detectCameras={loadCamerasFromSource}
          updateSourceCameras={updateSourceCameras}
        />
      )}
    </div>
  );
};

// Enhanced Update Source Modal Component
const SimpleUpdateSourceModal = ({ 
  show, 
  source, 
  sourceCameras,
  selectedCameras: initialSelectedCameras,
  onClose, 
  onUpdate, 
  testSourceConnection, 
  detectCameras, 
  updateSourceCameras
}) => {
  const [path] = useState(source.path);
  const [detectedCameras, setDetectedCameras] = useState(sourceCameras);
  const [selectedCameras, setSelectedCameras] = useState(initialSelectedCameras);
  
  // Loading states
  const [isDetecting, setIsDetecting] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [testResult, setTestResult] = useState(null);

  useEffect(() => {
    setDetectedCameras(sourceCameras);
    setSelectedCameras(initialSelectedCameras);
  }, [sourceCameras, initialSelectedCameras]);

  const detectCamerasInPath = async () => {
    if (!path) return;
    
    setIsDetecting(true);
    try {
      if (source.source_type === 'local') {
        // ‚úÖ SIMPLIFIED: For local source, use API call
        const response = await fetch('/api/config/get-camera-folders');
        if (response.ok) {
          const result = await response.json();
          const cameras = result.folders?.map(f => f.name) || [];
          
          if (cameras.length > 0) {
            setDetectedCameras(cameras);
            // Keep existing selected cameras that are still available
            const validSelectedCameras = selectedCameras.filter(cam => 
              cameras.includes(cam)
            );
            setSelectedCameras(validSelectedCameras);
          }
        }
      } else if (source.source_type === 'cloud') {
        // ‚úÖ NEW: Cloud source handling
        alert('Cloud camera detection is handled automatically. Please refresh the page to see latest cameras.');
      }
    } catch (error) {
      console.error('Camera detection failed:', error);
      setDetectedCameras([]);
      setSelectedCameras([]);
    } finally {
      setIsDetecting(false);
    }
  };

  const handleTestConnection = async () => {
    if (!path) {
      alert('No path to test');
      return;
    }

    setIsLoading(true);
    try {
      const testData = {
        source_type: source.source_type,
        path: path,
        config: source.config || {}
      };
      
      const response = await testSourceConnection(testData);
      setTestResult({
        success: response.accessible,
        message: response.message
      });
      
    } catch (error) {
      setTestResult({
        success: false,
        message: error.message || 'Connection test failed'
      });
    } finally {
      setIsLoading(false);
    }
  };

  const handleCameraToggle = (cameraName) => {
    setSelectedCameras(prev => 
      prev.includes(cameraName) 
        ? prev.filter(c => c !== cameraName)
        : [...prev, cameraName]
    );
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    
    try {
      // Update camera selection
      await updateSourceCameras(source.id, selectedCameras);
      
      alert('Source updated successfully!');
      onUpdate();
    } catch (error) {
      console.error('Error updating source:', error);
      alert('Failed to update source: ' + (error.response?.data?.error || error.message));
    }
  };

  if (!show) return null;

  const getSourceTypeInfo = (sourceType) => {
    const sourceTypes = {
      local: { icon: 'üìÅ', name: 'LOCAL STORAGE' },
      cloud: { icon: '‚òÅÔ∏è', name: 'CLOUD STORAGE' }
    };
    return sourceTypes[sourceType] || { icon: '‚ùì', name: 'UNKNOWN' };
  };

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div className="bg-gray-800 rounded-lg p-6 w-full max-w-2xl mx-4 max-h-[90vh] overflow-y-auto">
        <div className="flex justify-between items-center mb-4">
          <h3 className="text-xl font-bold text-white">üîß Update Video Source</h3>
          <button
            onClick={onClose}
            className="text-gray-400 hover:text-white text-2xl"
          >
            √ó
          </button>
        </div>

        <form onSubmit={handleSubmit}>
          {/* Source Type Info */}
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-300 mb-2">
              Source Type
            </label>
            <div className="w-full p-3 border border-gray-600 rounded bg-gray-700 text-white flex items-center">
              <span className="mr-2">{getSourceTypeInfo(source.source_type).icon}</span>
              <span className="font-medium">{getSourceTypeInfo(source.source_type).name}</span>
              <span className="ml-2 text-gray-400 text-sm">(ReadOnly)</span>
            </div>
          </div>

          {/* Path Info */}
          <div className="mb-4">
            <label className="block text-sm font-medium text-gray-300 mb-2">
              Path
            </label>
            <div className="w-full p-3 border border-gray-600 rounded bg-gray-700 text-white break-all">
              {path}
            </div>
          </div>

          {/* Camera Selection */}
          <div className="mb-4">
            <div className="flex justify-between items-center mb-3">
              <label className="block text-sm font-medium text-gray-300">
                {source.source_type === 'cloud' ? 'Synced Cameras' : 'Camera Folders'}
              </label>
              <button
                type="button"
                onClick={detectCamerasInPath}
                disabled={isDetecting}
                className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 text-white px-3 py-1 rounded text-xs"
              >
                {isDetecting ? 'Scanning...' : source.source_type === 'cloud' ? 'Refresh' : 'Rescan'}
              </button>
            </div>
            
            {isDetecting ? (
              <div className="text-center py-4">
                <div className="text-gray-400 text-sm">
                  {source.source_type === 'cloud' ? 'Refreshing cameras...' : 'Detecting cameras...'}
                </div>
              </div>
            ) : detectedCameras.length > 0 ? (
              <div className="grid grid-cols-2 gap-2 p-3 bg-gray-700 rounded">
                {detectedCameras.map(camera => (
                  <label key={camera} className="flex items-center space-x-2 cursor-pointer">
                    <input
                      type="checkbox"
                      checked={selectedCameras.includes(camera)}
                      onChange={() => handleCameraToggle(camera)}
                      className="rounded"
                    />
                    <span className="text-white text-sm">{camera}</span>
                  </label>
                ))}
              </div>
            ) : (
              <div className="text-center py-4 bg-gray-700 rounded">
                <div className="text-gray-400 text-sm">
                  {source.source_type === 'cloud' ? 'No cameras synced' : 'No camera folders detected'}
                </div>
              </div>
            )}
            
            {selectedCameras.length > 0 && (
              <div className="mt-2 text-xs text-gray-400">
                Selected: {selectedCameras.length} camera(s)
              </div>
            )}
          </div>

          {/* Test Connection */}
          <div className="mb-4">
            <button
              type="button"
              onClick={handleTestConnection}
              disabled={isLoading}
              className="bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 text-white px-4 py-2 rounded font-medium"
            >
              {isLoading ? 'Testing...' : 'Test Connection'}
            </button>
            
            {testResult && (
              <div className={`mt-2 p-3 rounded text-sm ${
                testResult.success ? 'bg-green-800 text-green-200' : 'bg-red-800 text-red-200'
              }`}>
                {testResult.message}
              </div>
            )}
          </div>

          {/* Action Buttons */}
          <div className="flex gap-3">
            <button
              type="submit"
              className="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded font-medium"
            >
              Save Changes
            </button>
            <button
              type="button"
              onClick={onClose}
              className="bg-gray-600 hover:bg-gray-700 text-white px-4 py-2 rounded font-medium"
            >
              Cancel
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default ConfigForm;
```
## üìÑ File: `GoogleDriveFolderSelector.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/GoogleDriveFolderSelector.js`

```javascript
// ‚ö†Ô∏è DEPRECATED: This component has been replaced by GoogleDrivePickerIntegration
// This file is kept for rollback purposes only and will be removed in future versions
// Use GoogleDrivePickerIntegration.js instead

console.warn('‚ö†Ô∏è GoogleDriveFolderSelector is deprecated. Use GoogleDrivePickerIntegration instead.');

// components/config/GoogleDriveFolderSelector.js - 2-Step Folder Selection
import React, { useState, useEffect } from 'react';

const GoogleDriveFolderSelector = ({
  rootFolders = [],
  subFolders = [],
  selectedRootFolder = null,
  selectedCameraFolders = [],
  isLoadingFolders = false,
  onSelectRoot,
  onSelectCameras
}) => {
  // ‚ö†Ô∏è DEPRECATION WARNING: Show to developers
  useEffect(() => {
    console.warn('‚ö†Ô∏è GoogleDriveFolderSelector is DEPRECATED');
    console.warn('   ‚Üí Replace with GoogleDrivePickerIntegration.js');
    console.warn('   ‚Üí This component will be removed in future versions');
    console.warn('   ‚Üí Phase 3 migration completed - update your imports');
  }, []);

  // Local state
  const [expandedFolders, setExpandedFolders] = useState(new Set());
  const [searchTerm, setSearchTerm] = useState('');
  const [viewMode, setViewMode] = useState('tree'); // 'tree' or 'list'
  const [folderStructure, setFolderStructure] = useState('unknown');

  // Filter folders based on search term
  const filteredRootFolders = rootFolders.filter(folder =>
    folder.name.toLowerCase().includes(searchTerm.toLowerCase())
  );

  const filteredSubFolders = subFolders.filter(folder =>
    folder.name.toLowerCase().includes(searchTerm.toLowerCase())
  );

  // Detect folder structure when subfolders load
  useEffect(() => {
    if (subFolders.length > 0) {
      // Check if subfolders look like camera folders
      const cameraKeywords = ['cam', 'camera', 'channel', 'ch', 'zone', 'area'];
      const cameraFolderCount = subFolders.filter(folder =>
        cameraKeywords.some(keyword => 
          folder.name.toLowerCase().includes(keyword)
        )
      ).length;

      if (cameraFolderCount > 0) {
        setFolderStructure('nested_cameras');
      } else {
        setFolderStructure('nested_general');
      }
    } else {
      setFolderStructure('unknown');
    }
  }, [subFolders]);

  // Handle root folder click/selection
  const handleRootFolderClick = (folder) => {
    if (selectedRootFolder?.id === folder.id) {
      // Already selected - toggle expansion
      const newExpanded = new Set(expandedFolders);
      if (newExpanded.has(folder.id)) {
        newExpanded.delete(folder.id);
      } else {
        newExpanded.add(folder.id);
      }
      setExpandedFolders(newExpanded);
    } else {
      // New selection
      if (onSelectRoot) {
        onSelectRoot(folder);
      }
      
      // Auto-expand the selected folder
      const newExpanded = new Set(expandedFolders);
      newExpanded.add(folder.id);
      setExpandedFolders(newExpanded);
    }
  };

  // Handle camera folder toggle
  const handleCameraFolderToggle = (cameraFolder) => {
    const currentSelected = [...selectedCameraFolders];
    const folderName = cameraFolder.name;
    
    if (currentSelected.includes(folderName)) {
      // Remove from selection
      const newSelected = currentSelected.filter(name => name !== folderName);
      if (onSelectCameras) {
        onSelectCameras(newSelected);
      }
    } else {
      // Add to selection
      const newSelected = [...currentSelected, folderName];
      if (onSelectCameras) {
        onSelectCameras(newSelected);
      }
    }
  };

  // Select all camera folders
  const handleSelectAllCameras = () => {
    const allCameraNames = subFolders.map(folder => folder.name);
    if (onSelectCameras) {
      onSelectCameras(allCameraNames);
    }
  };

  // Deselect all camera folders
  const handleDeselectAllCameras = () => {
    if (onSelectCameras) {
      onSelectCameras([]);
    }
  };

  // Get folder icon based on folder type
  const getFolderIcon = (folder) => {
    const name = folder.name.toLowerCase();
    
    if (name.includes('camera') || name.includes('cam')) return 'üìπ';
    if (name.includes('security') || name.includes('surveillance')) return 'üîí';
    if (name.includes('recording') || name.includes('video')) return 'üé¨';
    if (name.includes('storage') || name.includes('archive')) return 'üíæ';
    if (name.includes('backup')) return 'üîÑ';
    
    return 'üìÅ';
  };

  // Get selection status for bulk operations
  const getSelectionStatus = () => {
    if (subFolders.length === 0) return 'none';
    if (selectedCameraFolders.length === 0) return 'none';
    if (selectedCameraFolders.length === subFolders.length) return 'all';
    return 'partial';
  };

  return (
    <div className="space-y-4">
      
      {/* ‚ö†Ô∏è DEPRECATION WARNING BANNER */}
      <div className="bg-orange-800 border border-orange-600 rounded-lg p-4">
        <div className="flex items-center gap-2">
          <span className="text-orange-200 text-xl">‚ö†Ô∏è</span>
          <div className="text-orange-200">
            <div className="font-medium">DEPRECATED COMPONENT</div>
            <div className="text-sm">This component has been replaced by GoogleDrivePickerIntegration. Please update your code.</div>
          </div>
        </div>
      </div>
      
      {/* Header with Search and View Controls */}
      <div className="flex items-center justify-between">
        <div className="flex items-center gap-3">
          <h4 className="font-medium text-white">üìÅ Folder Selection</h4>
          
          {/* View Mode Toggle */}
          <div className="flex bg-gray-600 rounded overflow-hidden">
            <button
              onClick={() => setViewMode('tree')}
              className={`px-3 py-1 text-xs font-medium ${
                viewMode === 'tree' 
                  ? 'bg-blue-600 text-white' 
                  : 'text-gray-300 hover:text-white'
              }`}
            >
              Tree
            </button>
            <button
              onClick={() => setViewMode('list')}
              className={`px-3 py-1 text-xs font-medium ${
                viewMode === 'list' 
                  ? 'bg-blue-600 text-white' 
                  : 'text-gray-300 hover:text-white'
              }`}
            >
              List
            </button>
          </div>
        </div>

        {/* Search */}
        <div className="relative">
          <input
            type="text"
            placeholder="Search folders..."
            value={searchTerm}
            onChange={(e) => setSearchTerm(e.target.value)}
            className="w-48 px-3 py-1 bg-gray-600 text-white text-sm rounded border border-gray-500 focus:border-blue-500"
          />
          {searchTerm && (
            <button
              onClick={() => setSearchTerm('')}
              className="absolute right-2 top-1/2 transform -translate-y-1/2 text-gray-400 hover:text-white"
            >
              √ó
            </button>
          )}
        </div>
      </div>

      {/* Step 1: Root Folder Selection */}
      <div className="bg-gray-600 rounded-lg p-4">
        <div className="flex items-center justify-between mb-3">
          <h5 className="font-medium text-white">Step 1: Select Root Folder</h5>
          <span className="text-xs text-gray-300">
            {filteredRootFolders.length} folder(s) available
          </span>
        </div>

        {filteredRootFolders.length === 0 ? (
          <div className="text-center py-6 text-gray-400">
            <div className="text-2xl mb-2">üìÇ</div>
            <div className="text-sm">
              {searchTerm ? 'No folders match your search' : 'No folders available'}
            </div>
          </div>
        ) : (
          <div className="space-y-2 max-h-32 overflow-y-auto">
            {filteredRootFolders.map((folder) => (
              <div
                key={folder.id}
                onClick={() => handleRootFolderClick(folder)}
                className={`flex items-center gap-3 p-3 rounded cursor-pointer transition-colors ${
                  selectedRootFolder?.id === folder.id
                    ? 'bg-blue-600 text-white'
                    : 'bg-gray-700 hover:bg-gray-650 text-gray-300'
                }`}
              >
                <span className="text-lg">{getFolderIcon(folder)}</span>
                <div className="flex-1 min-w-0">
                  <div className="font-medium truncate">{folder.name}</div>
                  {folder.description && (
                    <div className="text-xs opacity-75 truncate">{folder.description}</div>
                  )}
                </div>
                {selectedRootFolder?.id === folder.id && (
                  <span className="text-green-300 text-sm">‚úì Selected</span>
                )}
              </div>
            ))}
          </div>
        )}
      </div>

      {/* Step 2: Camera Folder Selection */}
      {selectedRootFolder && (
        <div className="bg-gray-600 rounded-lg p-4">
          <div className="flex items-center justify-between mb-3">
            <h5 className="font-medium text-white">
              Step 2: Select Camera Folders
              <span className="text-sm text-gray-300 ml-2">
                from "{selectedRootFolder.name}"
              </span>
            </h5>
            
            {/* Bulk Selection Controls */}
            {subFolders.length > 0 && (
              <div className="flex gap-2">
                <button
                  onClick={handleSelectAllCameras}
                  disabled={getSelectionStatus() === 'all'}
                  className="px-3 py-1 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-500 text-white rounded text-xs font-medium"
                >
                  Select All
                </button>
                <button
                  onClick={handleDeselectAllCameras}
                  disabled={getSelectionStatus() === 'none'}
                  className="px-3 py-1 bg-gray-500 hover:bg-gray-600 disabled:bg-gray-400 text-white rounded text-xs font-medium"
                >
                  Clear All
                </button>
              </div>
            )}
          </div>

          {/* Loading State */}
          {isLoadingFolders && (
            <div className="text-center py-6">
              <div className="animate-spin w-6 h-6 border-2 border-blue-500 border-t-transparent rounded-full mx-auto mb-2"></div>
              <div className="text-sm text-gray-400">Loading camera folders...</div>
            </div>
          )}

          {/* No Subfolders */}
          {!isLoadingFolders && subFolders.length === 0 && (
            <div className="text-center py-6 text-gray-400">
              <div className="text-2xl mb-2">üìπ</div>
              <div className="text-sm">
                No camera folders found in "{selectedRootFolder.name}"
              </div>
              <div className="text-xs mt-1">
                Try selecting a different root folder
              </div>
            </div>
          )}

          {/* Camera Folders List */}
          {!isLoadingFolders && filteredSubFolders.length > 0 && (
            <div>
              {/* Folder Structure Info */}
              {folderStructure === 'nested_cameras' && (
                <div className="bg-green-800 border border-green-600 rounded p-2 mb-3">
                  <div className="text-xs text-green-200">
                    üéØ Camera folder structure detected! These appear to be camera recording folders.
                  </div>
                </div>
              )}

              {viewMode === 'tree' ? (
                /* Tree View */
                <div className="space-y-1 max-h-48 overflow-y-auto">
                  {filteredSubFolders.map((folder) => (
                    <label
                      key={folder.id}
                      className="flex items-center gap-3 p-2 rounded cursor-pointer hover:bg-gray-700 transition-colors"
                    >
                      <input
                        type="checkbox"
                        checked={selectedCameraFolders.includes(folder.name)}
                        onChange={() => handleCameraFolderToggle(folder)}
                        className="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500"
                      />
                      <span className="text-lg">{getFolderIcon(folder)}</span>
                      <div className="flex-1 min-w-0">
                        <div className="font-medium text-white truncate">{folder.name}</div>
                        {folder.file_count && (
                          <div className="text-xs text-gray-400">
                            {folder.file_count} files
                          </div>
                        )}
                      </div>
                      {folder.size && (
                        <div className="text-xs text-gray-400">
                          {(folder.size / 1024 / 1024).toFixed(1)} MB
                        </div>
                      )}
                    </label>
                  ))}
                </div>
              ) : (
                /* List View */
                <div className="grid grid-cols-2 gap-2 max-h-48 overflow-y-auto">
                  {filteredSubFolders.map((folder) => (
                    <label
                      key={folder.id}
                      className={`flex items-center gap-2 p-2 rounded cursor-pointer transition-colors ${
                        selectedCameraFolders.includes(folder.name)
                          ? 'bg-blue-600 text-white'
                          : 'bg-gray-700 hover:bg-gray-650 text-gray-300'
                      }`}
                    >
                      <input
                        type="checkbox"
                        checked={selectedCameraFolders.includes(folder.name)}
                        onChange={() => handleCameraFolderToggle(folder)}
                        className="w-4 h-4"
                      />
                      <span>{getFolderIcon(folder)}</span>
                      <span className="font-medium text-sm truncate">{folder.name}</span>
                    </label>
                  ))}
                </div>
              )}

              {/* Selection Summary */}
              <div className="mt-3 p-2 bg-gray-700 rounded">
                <div className="text-sm text-gray-300">
                  <strong>Selected:</strong> {selectedCameraFolders.length} of {subFolders.length} camera folders
                </div>
                {selectedCameraFolders.length > 0 && (
                  <div className="text-xs text-gray-400 mt-1">
                    {selectedCameraFolders.slice(0, 3).join(', ')}
                    {selectedCameraFolders.length > 3 && ` +${selectedCameraFolders.length - 3} more`}
                  </div>
                )}
              </div>
            </div>
          )}
        </div>
      )}

      {/* Configuration Summary */}
      {selectedRootFolder && selectedCameraFolders.length > 0 && (
        <div className="bg-green-800 border border-green-600 rounded-lg p-3">
          <h5 className="font-medium text-green-100 mb-2">üìã Selection Summary</h5>
          <div className="text-sm text-green-200 space-y-1">
            <div><strong>Root Folder:</strong> {selectedRootFolder.name}</div>
            <div><strong>Camera Folders:</strong> {selectedCameraFolders.length} selected</div>
            <div><strong>Structure:</strong> {folderStructure === 'nested_cameras' ? 'Nested Camera Folders' : 'Nested General Folders'}</div>
            <div className="text-xs text-green-300 mt-2">
              Videos will be synced from: {selectedRootFolder.name}/{selectedCameraFolders.join(', ')}
            </div>
          </div>
        </div>
      )}

      {/* Debug Info (Development) */}
      {process.env.NODE_ENV === 'development' && (
        <details className="bg-gray-800 rounded p-2">
          <summary className="text-xs text-gray-400 cursor-pointer">üîß Debug - Folder Selection</summary>
          <pre className="text-xs text-gray-400 mt-2 overflow-auto">
            {JSON.stringify({
              rootFolders: rootFolders.length,
              subFolders: subFolders.length,
              selectedRoot: selectedRootFolder?.name,
              selectedCameras: selectedCameraFolders,
              folderStructure,
              searchTerm,
              viewMode,
              DEPRECATED: true,
              replacement: 'GoogleDrivePickerIntegration.js'
            }, null, 2)}
          </pre>
        </details>
      )}
    </div>
  );
};

export default GoogleDriveFolderSelector;
```
## üìÑ File: `GeneralInfoForm.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/GeneralInfoForm.js`

```javascript
import DatePicker from "react-datepicker";

const GeneralInfoForm = ({
  country,
  setCountry,
  timezone,
  setTimezone,
  brandName,
  setBrandName,
  workingDays,
  setWorkingDays,
  fromTime,
  setFromTime,
  toTime,
  setToTime,
  handleCountryChange,
  handleFromTimeChange,
  handleToTimeChange,
  handleWorkingDayChange,
  handleSaveGeneralInfo,
  countries,
}) => {
  return (
    <div className="w-[25%] bg-gray-800 p-6 rounded-lg flex flex-col">
      <h1 className="text-3xl font-bold mb-4">Th√¥ng tin chung</h1>
      <div className="mb-4">
        <label className="block mb-1">Qu·ªëc gia:</label>
        <select
          value={country}
          onChange={handleCountryChange}
          className="w-full p-2 rounded bg-gray-700 text-white"
        >
          {countries.map((country) => (
            <option key={country} value={country}>
              {country}
            </option>
          ))}
        </select>
      </div>
      <div className="mb-4">
        <label className="block mb-1">M√∫i gi·ªù:</label>
        <input
          type="text"
          value={timezone}
          readOnly
          className="w-full p-2 rounded bg-gray-700 text-white"
        />
      </div>
      <div className="mb-4">
        <label className="block mb-1">T√™n th∆∞∆°ng hi·ªáu:</label>
        <input
          type="text"
          value={brandName}
          onChange={(e) => setBrandName(e.target.value)}
          placeholder="Nh·∫≠p t√™n th∆∞∆°ng hi·ªáu"
          className="w-full p-2 rounded bg-gray-700 text-white"
        />
      </div>
      <div className="mb-4">
        <h3 className="text-lg font-bold mb-2">Ng√†y l√†m vi·ªác</h3>
        {["Th·ª© Hai", "Th·ª© Ba", "Th·ª© T∆∞", "Th·ª© NƒÉm", "Th·ª© S√°u", "Th·ª© B·∫£y", "Ch·ªß Nh·∫≠t"].map((day) => (
          <label key={day} className="flex items-center mb-2">
            <input
              type="checkbox"
              className="mr-2"
              onChange={() => handleWorkingDayChange(day)}
              checked={workingDays.includes(day)}
            />
            {day}
          </label>
        ))}
      </div>
      <div className="mb-4">
        <h3 className="text-lg font-bold mb-2">Th·ªùi gian l√†m vi·ªác</h3>
        <div className="flex gap-4">
          <div className="flex-1">
            <label className="block mb-1">T·ª´:</label>
            <DatePicker
              selected={fromTime}
              onChange={handleFromTimeChange}
              showTimeSelect
              showTimeSelectOnly
              timeIntervals={30}
              timeCaption="Gi·ªù"
              dateFormat="HH:mm"
              className="w-full p-2 rounded bg-gray-700 text-white"
            />
          </div>
          <div className="flex-1">
            <label className="block mb-1">ƒê·∫øn:</label>
            <DatePicker
              selected={toTime}
              onChange={handleToTimeChange}
              showTimeSelect
              showTimeSelectOnly
              timeIntervals={30}
              timeCaption="Gi·ªù"
              dateFormat="HH:mm"
              className="w-full p-2 rounded bg-gray-700 text-white"
            />
          </div>
        </div>
      </div>
      <div className="mt-auto flex justify-center">
        <button
          onClick={handleSaveGeneralInfo}
          className="w-1/2 py-2 bg-blue-600 text-white font-bold rounded"
        >
          G·ª≠i
        </button>
      </div>
    </div>
  );
};

export default GeneralInfoForm;
```
## üìÑ File: `GoogleDriveAuthButton.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/GoogleDriveAuthButton.js`

```javascript
// components/config/GoogleDriveAuthButton.js - FIXED: COOP & Origin Issues
import React, { useState, useEffect } from 'react';

const GoogleDriveAuthButton = ({ 
  onAuth, 
  isAuthenticated = false, 
  isLoading = false, 
  userEmail = null,
  className = '' 
}) => {
  const [authState, setAuthState] = useState({
    loading: isLoading,
    authenticated: isAuthenticated,
    userEmail: userEmail,
    error: null,
    sessionToken: null
  });

  // üîí SECURITY: Session validation v√† auto-refresh
  useEffect(() => {
    const validateSession = async () => {
      const token = sessionStorage.getItem('session_token');
      if (token) {
        try {
          const response = await fetch('http://localhost:8080/api/cloud/auth-status', {
            method: 'GET',
            headers: { 
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}`
            },
            credentials: 'include'
          });
          
          if (response.ok) {
            const result = await response.json();
            if (result.authenticated) {
              setAuthState(prev => ({
                ...prev,
                authenticated: true,
                userEmail: result.user_email,
                sessionToken: token
              }));
            } else {
              // Session expired, clean up
              sessionStorage.removeItem('session_token');
              setAuthState(prev => ({
                ...prev,
                authenticated: false,
                userEmail: null,
                sessionToken: null
              }));
            }
          }
        } catch (error) {
          console.error('Session validation failed:', error);
          sessionStorage.removeItem('session_token');
        }
      }
    };

    validateSession();
  }, []);

  // üîí SECURITY: Auto-refresh session token
  useEffect(() => {
    let refreshInterval;
    
    if (authState.authenticated && authState.sessionToken) {
      refreshInterval = setInterval(async () => {
        try {
          const response = await fetch('http://localhost:8080/api/cloud/auth-status', {
            method: 'GET',
            headers: { 
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${authState.sessionToken}`
            },
            credentials: 'include'
          });
          
          if (response.ok) {
            const result = await response.json();
            if (result.session_token) {
              sessionStorage.setItem('session_token', result.session_token);
              setAuthState(prev => ({
                ...prev,
                sessionToken: result.session_token
              }));
            }
          }
        } catch (error) {
          console.error('Session refresh failed:', error);
        }
      }, 25 * 60 * 1000); // Refresh every 25 minutes
    }
    
    return () => {
      if (refreshInterval) {
        clearInterval(refreshInterval);
      }
    };
  }, [authState.authenticated, authState.sessionToken]);

  // üîß FIXED: Enhanced postMessage handler v·ªõi improved origin handling
  useEffect(() => {
    const handleOAuthMessage = (event) => {
      console.log('üì¨ Received OAuth message:', event.data);
      console.log('üìç Message origin:', event.origin);

      // üîß FIX: Accept messages from both localhost and 127.0.0.1 on port 8080
      const allowedOrigins = [
        'http://localhost:8080',
        'http://127.0.0.1:8080'
      ];
      
      if (!allowedOrigins.includes(event.origin)) {
        console.warn('üö´ Ignoring message from unauthorized origin:', event.origin);
        return;
      }

      if (event.data.type === 'OAUTH_SUCCESS') {
        console.log('‚úÖ OAuth success via postMessage:', event.data);
        
        // üîí SECURITY: Handle session token instead of credentials
        const userData = event.data.user_info || event.data.user || {};
        const userEmail = event.data.user_email || userData.email || 'unknown';
        const folders = event.data.folders || [];
        const sessionToken = event.data.session_token;
        
        console.log('üìß User email:', userEmail);
        console.log('üìÅ Folders count:', folders.length);
        console.log('üîë Session token received:', !!sessionToken);
        
        // üîí SECURITY: Store session token securely
        if (sessionToken) {
          sessionStorage.setItem('session_token', sessionToken);
          console.log('üíæ Session token stored in sessionStorage');
        }
        
        setAuthState(prev => ({
          ...prev,
          loading: false,
          authenticated: true,
          userEmail: userEmail,
          error: null,
          sessionToken: sessionToken
        }));

        // üîí SECURITY: Notify parent component WITHOUT credentials
        if (onAuth) {
          onAuth({
            success: true,
            user_email: userEmail,
            user_info: userData,
            folders: folders,
            message: `Authenticated as ${userEmail}`,
            backend_port: event.data.backend_port || 8080,
            session_token: sessionToken,
            lazy_loading_enabled: event.data.lazy_loading_enabled || false
          });
        }

      } else if (event.data.type === 'OAUTH_ERROR') {
        console.error('‚ùå OAuth error via postMessage:', event.data.error);
        
        setAuthState(prev => ({
          ...prev,
          loading: false,
          authenticated: false,
          error: event.data.error
        }));

        if (onAuth) {
          onAuth({
            success: false,
            message: event.data.error || 'Authentication failed',
            error: event.data.details || ''
          });
        }
      }
    };

    // Listen for OAuth messages
    window.addEventListener('message', handleOAuthMessage);

    return () => {
      window.removeEventListener('message', handleOAuthMessage);
    };
  }, [onAuth]);

  const handleAuthenticate = async () => {
    if (authState.loading) return;

    try {
      setAuthState(prev => ({ ...prev, loading: true, error: null }));
      console.log('üîê Starting Google Drive authentication...');

      // üîß FIX: Enhanced request v·ªõi better error handling
      const response = await fetch('http://localhost:8080/api/cloud/authenticate', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Accept': 'application/json'
        },
        credentials: 'include',
        body: JSON.stringify({
          provider: 'google_drive',
          action: 'initiate_auth',
          redirect_uri: 'http://localhost:8080/api/cloud/oauth/callback'
        })
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Authentication request failed: ${response.status} - ${errorText}`);
      }

      const authData = await response.json();

      if (!authData.success || !authData.auth_url) {
        throw new Error(authData.message || 'Failed to get authorization URL');
      }

      console.log('üåê Opening OAuth popup...', authData.auth_url);

      // Step 2: Open OAuth popup - IMPROVED with COOP workaround
      await handleOAuthPopup(authData.auth_url);

    } catch (error) {
      console.error('‚ùå Authentication error:', error);
      setAuthState(prev => ({
        ...prev,
        loading: false,
        error: error.message
      }));

      if (onAuth) {
        onAuth({
          success: false,
          message: error.message || 'Authentication failed'
        });
      }
    }
  };

  // üîß ENHANCED: Better popup handling v·ªõi comprehensive COOP workaround
  const handleOAuthPopup = async (authUrl) => {
    return new Promise((resolve, reject) => {
      const popup = window.open(
        authUrl,
        'google_drive_auth',
        'width=600,height=700,scrollbars=yes,resizable=yes,popup=yes,left=' + 
        (window.screen.width / 2 - 300) + ',top=' + (window.screen.height / 2 - 350)
      );

      if (!popup) {
        reject(new Error('Popup blocked. Please allow popups for this site.'));
        return;
      }

      let checkCompleted = false;
      let messageReceived = false;

      // üÜï ENHANCED: Multi-origin postMessage listener
      const handlePopupMessage = (event) => {
        // üîß FIX: Accept messages from OAuth callback endpoints
        const allowedOrigins = [
          'http://localhost:8080',
          'http://127.0.0.1:8080'
        ];
        
        if (!allowedOrigins.includes(event.origin)) {
          console.log(`üìç Ignoring message from: ${event.origin}`);
          return;
        }
        
        if (event.data.type === 'OAUTH_SUCCESS' || event.data.type === 'OAUTH_ERROR') {
          if (!checkCompleted) {
            checkCompleted = true;
            messageReceived = true;
            console.log('‚úÖ OAuth popup completed via postMessage');
            
            try {
              popup.close();
            } catch (e) {
              console.log('üìù Note: Could not close popup (COOP prevents access)');
            }
            
            window.removeEventListener('message', handlePopupMessage);
            resolve();
          }
        }
      };

      // üîß FALLBACK: Popup close detection v·ªõi better error handling
      const checkPopupStatus = () => {
        try {
          // Try to access popup properties
          if (popup.closed) {
            if (!checkCompleted && !messageReceived) {
              checkCompleted = true;
              console.log('üîÑ Popup closed, checking for auth result...');
              
              // Wait briefly for any pending messages
              setTimeout(async () => {
                try {
                  await checkAuthResult();
                  resolve();
                } catch (error) {
                  reject(error);
                }
              }, 1500);
            }
            return;
          }
        } catch (error) {
          // COOP prevents access to popup.closed - this is expected
          console.log('üîí COOP prevents popup.closed check (normal behavior)');
        }

        // Continue checking if not completed
        if (!checkCompleted) {
          setTimeout(checkPopupStatus, 2000);
        }
      };

      // Start listeners
      window.addEventListener('message', handlePopupMessage);
      
      // Start popup status checking after delay
      setTimeout(checkPopupStatus, 3000);

      // üîß TIMEOUT: Enhanced timeout v·ªõi better cleanup
      setTimeout(() => {
        if (!checkCompleted) {
          checkCompleted = true;
          window.removeEventListener('message', handlePopupMessage);
          
          try {
            popup.close();
          } catch (e) {
            console.log('üìù Note: Could not close popup during timeout');
          }
          
          reject(new Error('Authentication timeout (5 minutes). Please try again.'));
        }
      }, 300000);
    });
  };

  // üîí SECURITY: Enhanced auth result checking
  const checkAuthResult = async (maxRetries = 3) => {
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`üîç Checking auth result (attempt ${attempt}/${maxRetries})...`);
        
        const response = await fetch('http://localhost:8080/api/cloud/auth-status', {
          method: 'GET',
          headers: { 
            'Content-Type': 'application/json',
            'Cache-Control': 'no-cache'
          },
          credentials: 'include',
          cache: 'no-cache'
        });

        if (!response.ok) {
          throw new Error(`Auth status check failed: ${response.status}`);
        }

        const result = await response.json();
        
        if (result.success && result.authenticated) {
          console.log('‚úÖ Authentication confirmed:', result.user_email);
          
          // üîí SECURITY: Store session token
          if (result.session_token) {
            sessionStorage.setItem('session_token', result.session_token);
          }
          
          setAuthState(prev => ({
            ...prev,
            loading: false,
            authenticated: true,
            userEmail: result.user_email,
            error: null,
            sessionToken: result.session_token
          }));

          // üîí SECURITY: Pass session token instead of credentials
          if (onAuth) {
            onAuth({
              success: true,
              user_email: result.user_email,
              user_info: result.user_info,
              folders: result.folders || [],
              message: `Authenticated as ${result.user_email}`,
              existing_auth: result.existing_auth || false,
              session_token: result.session_token,
              lazy_loading_enabled: result.lazy_loading_enabled || false
            });
          }
          
          return;
        } else if (attempt === maxRetries) {
          throw new Error(result.message || 'No authentication found');
        } else {
          // Wait before retrying
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        }
        
      } catch (error) {
        console.error(`‚ùå Auth status check failed (attempt ${attempt}):`, error);
        
        if (attempt === maxRetries) {
          throw error;
        } else {
          // Wait before retrying
          await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
        }
      }
    }
  };

  // üîí SECURITY: Updated disconnect handler with session cleanup
  const handleDisconnect = async () => {
    try {
      setAuthState(prev => ({ ...prev, loading: true }));
      
      const response = await fetch('http://localhost:8080/api/cloud/disconnect', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${authState.sessionToken}`
        },
        credentials: 'include',
        body: JSON.stringify({
          provider: 'google_drive',
          user_email: authState.userEmail
        })
      });

      const result = await response.json();
      
      if (result.success) {
        // üîí SECURITY: Clean up session token
        sessionStorage.removeItem('session_token');
        
        setAuthState({
          loading: false,
          authenticated: false,
          userEmail: null,
          error: null,
          sessionToken: null
        });

        if (onAuth) {
          onAuth({
            success: false,
            message: 'Disconnected from Google Drive',
            disconnected: true
          });
        }
      } else {
        throw new Error(result.message || 'Disconnect failed');
      }
      
    } catch (error) {
      console.error('‚ùå Disconnect error:', error);
      setAuthState(prev => ({ ...prev, loading: false, error: error.message }));
    }
  };

  // Update state when props change
  useEffect(() => {
    setAuthState(prev => ({
      ...prev,
      loading: isLoading,
      authenticated: isAuthenticated,
      userEmail: userEmail
    }));
  }, [isLoading, isAuthenticated, userEmail]);

  // Component render
  return (
    <div className={`google-drive-auth-button ${className}`}>
      {!authState.authenticated ? (
        <div className="auth-section">
          <button
            onClick={handleAuthenticate}
            disabled={authState.loading}
            className={`px-6 py-3 rounded-lg font-medium transition-all duration-200 ${
              authState.loading
                ? 'bg-gray-400 text-gray-600 cursor-not-allowed'
                : 'bg-blue-600 hover:bg-blue-700 text-white shadow-lg hover:shadow-xl transform hover:scale-105'
            }`}
          >
            {authState.loading ? (
              <span className="flex items-center">
                <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" fill="none" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                Authenticating...
              </span>
            ) : (
              <span className="flex items-center">
                üîê Connect to Google Drive
                <span className="ml-2 text-xs opacity-75">(Required)</span>
              </span>
            )}
          </button>
          
          <div className="mt-2 text-xs text-gray-400">
            Click to authenticate and access your Google Drive folders
          </div>
        </div>
      ) : (
        <div className="authenticated-section">
          <div className="flex items-center justify-between p-4 bg-green-100 border border-green-400 rounded-lg">
            <div className="flex items-center">
              <span className="text-2xl mr-3">‚úÖ</span>
              <div>
                <div className="font-medium text-green-800">
                  Connected to Google Drive
                </div>
                <div className="text-sm text-green-600">
                  {authState.userEmail}
                </div>
              </div>
            </div>
            
            <button
              onClick={handleDisconnect}
              disabled={authState.loading}
              className="px-3 py-1 bg-red-600 hover:bg-red-700 disabled:bg-gray-400 text-white rounded text-sm transition-colors"
            >
              {authState.loading ? 'Disconnecting...' : 'Disconnect'}
            </button>
          </div>
        </div>
      )}

      {/* Error Display */}
      {authState.error && (
        <div className="error-display mt-3 p-3 bg-red-100 border border-red-400 rounded-lg">
          <div className="flex items-center justify-between">
            <div className="text-red-700">
              <div className="font-medium">Authentication Error</div>
              <div className="text-sm mt-1">{authState.error}</div>
            </div>
            <button
              onClick={() => setAuthState(prev => ({ ...prev, error: null }))}
              className="text-red-500 hover:text-red-700 text-lg leading-none"
            >
              √ó
            </button>
          </div>

          {/* Error Actions */}
          <div className="mt-3 flex gap-2">
            <button
              onClick={handleAuthenticate}
              className="px-3 py-1 bg-blue-600 text-white rounded text-sm hover:bg-blue-700"
            >
              Try Again
            </button>
            <button
              onClick={() => window.location.reload()}
              className="px-3 py-1 bg-gray-600 text-white rounded text-sm hover:bg-gray-700"
            >
              Refresh Page
            </button>
          </div>
        </div>
      )}

      {/* Help Text */}
      {!authState.authenticated && !authState.error && (
        <div className="help-text mt-3 p-3 bg-blue-50 border border-blue-200 rounded-lg">
          <div className="text-sm text-blue-700">
            <div className="font-medium mb-1">üîí Secure Authentication</div>
            <ul className="text-xs space-y-1 ml-4">
              <li>‚Ä¢ Opens Google's official OAuth login</li>
              <li>‚Ä¢ VTrack never sees your Google password</li>
              <li>‚Ä¢ Only folder access permission requested</li>
              <li>‚Ä¢ Can be revoked anytime from Google Account settings</li>
            </ul>
          </div>
        </div>
      )}

      {/* Development Debug Info */}
      {process.env.NODE_ENV === 'development' && (
        <details className="debug-info mt-3 p-2 bg-gray-100 rounded text-xs">
          <summary className="cursor-pointer text-gray-600">üîß Debug Info</summary>
          <pre className="mt-2 text-gray-500 overflow-auto">
            {JSON.stringify({
              authenticated: authState.authenticated,
              loading: authState.loading,
              userEmail: authState.userEmail,
              hasError: !!authState.error,
              errorMessage: authState.error,
              hasSessionToken: !!authState.sessionToken,
              backendPort: 8080
            }, null, 2)}
          </pre>
        </details>
      )}
    </div>
  );
};

export default GoogleDriveAuthButton;
```
## üìÑ File: `CloudSyncSettings.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/CloudSyncSettings.js`

```javascript
// components/config/CloudSyncSettings.js - Focused Sync Configuration
import React, { useState, useEffect } from 'react';

const CloudSyncSettings = ({ config, onChange }) => {
  // Default settings
  const defaultSettings = {
    interval_minutes: 15,
    auto_sync_enabled: true,
    // Hidden/Fixed settings (not shown in UI) - BEST defaults for amature users
    organize_by_date: true,       // Always organize by date - optimal structure
    backup_metadata: true,        // Always preserve metadata - safe approach
    sync_only_new: true,          // Always incremental sync - efficient
    skip_duplicates: true,        // Always skip duplicates - smart behavior
    duplicate_handling: 'compare_size', // Compare by size - best balance
    max_file_size_mb: 1000,       // 30-min video ~1GB at standard quality
    bandwidth_limit_mbps: 10,     // 10 Mbps reasonable for background sync
    file_types: ['.mp4', '.avi', '.mov', '.mkv', '.m4v']
  };

  // Local state
  const [settings, setSettings] = useState({ ...defaultSettings, ...config });
  const [localStorageWarning, setLocalStorageWarning] = useState(false);

  // Sync interval options - focused on practical camera recording frequencies
  const syncIntervals = [
    { value: 5, label: "5 minutes", description: "High-frequency cameras (security)" },
    { value: 15, label: "15 minutes", description: "Standard recording (recommended)" },
    { value: 30, label: "30 minutes", description: "Low-frequency cameras" },
    { value: 60, label: "1 hour", description: "Periodic recording" },
    { value: 180, label: "3 hours", description: "Daily batch cameras" },
    { value: 360, label: "6 hours", description: "Archive/backup mode" }
  ];

  // Check local storage periodically
  useEffect(() => {
    const checkLocalStorage = () => {
      try {
        // Check available disk space (simplified estimation)
        if (navigator.storage && navigator.storage.estimate) {
          navigator.storage.estimate().then(estimate => {
            const usedGB = (estimate.usage || 0) / (1024 ** 3);
            const quotaGB = (estimate.quota || 0) / (1024 ** 3);
            const freeSpaceGB = quotaGB - usedGB;
            
            // Warn if less than 5GB free space
            if (freeSpaceGB < 5) {
              setLocalStorageWarning(true);
            } else {
              setLocalStorageWarning(false);
            }
          });
        }
      } catch (error) {
        console.warn('Could not check storage:', error);
      }
    };

    checkLocalStorage();
    // Check every 5 minutes
    const interval = setInterval(checkLocalStorage, 5 * 60 * 1000);
    
    return () => clearInterval(interval);
  }, []);

  // Update settings and notify parent
  const updateSetting = (key, value) => {
    const newSettings = { ...settings, [key]: value };
    setSettings(newSettings);
    
    if (onChange) {
      onChange(newSettings);
    }
  };

  // Get interval description
  const getIntervalDescription = (minutes) => {
    const interval = syncIntervals.find(i => i.value === minutes);
    return interval ? interval.description : '';
  };

  return (
    <div className="space-y-4">
      
      {/* Local Storage Warning */}
      {localStorageWarning && (
        <div className="bg-yellow-800 border border-yellow-600 rounded-lg p-3">
          <div className="flex items-center gap-2">
            <span className="text-yellow-200">‚ö†Ô∏è</span>
            <div className="text-yellow-200 text-sm">
              <div className="font-medium">Low disk space detected</div>
              <div className="text-xs">Consider freeing up space to continue video sync</div>
            </div>
          </div>
        </div>
      )}

      {/* Sync Frequency */}
      <div className="bg-gray-700 rounded-lg p-4">
        <h4 className="font-medium text-white mb-3">‚è±Ô∏è Sync Frequency</h4>
        
        <div className="space-y-3">
          <div>
            <label className="block text-sm font-medium text-gray-300 mb-2">
              How often should VTrack check for new videos?
            </label>
            <select
              value={settings.interval_minutes}
              onChange={(e) => updateSetting('interval_minutes', parseInt(e.target.value))}
              className="w-full p-3 bg-gray-800 text-white rounded-lg border border-gray-600 focus:border-blue-500"
            >
              {syncIntervals.map(interval => (
                <option key={interval.value} value={interval.value}>
                  {interval.label} - {interval.description}
                </option>
              ))}
            </select>
          </div>
          
          <div className="text-xs text-gray-400 bg-gray-600 p-3 rounded">
            <div className="font-medium mb-1">üí° Sync Frequency Guide:</div>
            <div>‚Ä¢ <strong>5-15 minutes:</strong> Security cameras with frequent recording</div>
            <div>‚Ä¢ <strong>30-60 minutes:</strong> Dashcams, action cameras with periodic recording</div>
            <div>‚Ä¢ <strong>3-6 hours:</strong> Archive cameras or manual uploads</div>
          </div>
        </div>
      </div>

      {/* File Size Limits (Info Only) */}
      <div className="bg-gray-700 rounded-lg p-4">
        <h4 className="font-medium text-white mb-3">üìè File Size Limits</h4>
        
        <div className="space-y-2">
          <div className="flex justify-between text-sm">
            <span className="text-gray-300">Maximum file size:</span>
            <span className="text-white font-medium">{settings.max_file_size_mb} MB</span>
          </div>
          <div className="flex justify-between text-sm">
            <span className="text-gray-300">Supported formats:</span>
            <span className="text-white font-medium">MP4, AVI, MOV, MKV, M4V</span>
          </div>
          <div className="flex justify-between text-sm">
            <span className="text-gray-300">Background bandwidth:</span>
            <span className="text-white font-medium">{settings.bandwidth_limit_mbps} Mbps max</span>
          </div>
        </div>
        
        <div className="text-xs text-gray-400 bg-gray-600 p-3 rounded mt-3">
          <div className="font-medium mb-1">‚ÑπÔ∏è Automatic optimizations:</div>
          <div>‚Ä¢ Videos organized by date folders for easy browsing</div>
          <div>‚Ä¢ Original timestamps and camera info preserved</div>
          <div>‚Ä¢ Duplicate files automatically skipped (smart detection)</div>
          <div>‚Ä¢ Only new files downloaded (incremental sync)</div>
          <div>‚Ä¢ Bandwidth limited to {settings.bandwidth_limit_mbps} Mbps (background mode)</div>
        </div>
      </div>



      {/* Advanced Settings Summary */}
      <div className="bg-gray-800 border border-gray-600 rounded-lg p-4">
        <h4 className="font-medium text-gray-200 mb-3">‚öôÔ∏è Advanced Settings (Auto-Configured)</h4>
        
        <div className="grid grid-cols-2 gap-4 text-xs text-gray-400">
          <div>
            <div className="font-medium text-gray-300 mb-1">File Handling:</div>
            <div>‚Ä¢ Organize by date: {settings.organize_by_date ? 'Yes' : 'No'}</div>
            <div>‚Ä¢ Backup metadata: {settings.backup_metadata ? 'Yes' : 'No'}</div>
            <div>‚Ä¢ Sync only new: {settings.sync_only_new ? 'Yes' : 'No'}</div>
          </div>
          <div>
            <div className="font-medium text-gray-300 mb-1">Performance:</div>
            <div>‚Ä¢ Skip duplicates: {settings.skip_duplicates ? 'Yes' : 'No'}</div>
            <div>‚Ä¢ Duplicate method: {settings.duplicate_handling}</div>
            <div>‚Ä¢ Max file size: {settings.max_file_size_mb}MB</div>
          </div>
        </div>
        
        <div className="mt-3 text-xs text-gray-500">
          üí° These advanced settings are automatically optimized for Google Drive Picker workflow
        </div>
      </div>

      {/* Debug Info (Development) */}
      {process.env.NODE_ENV === 'development' && (
        <details className="bg-gray-800 rounded p-3">
          <summary className="text-xs text-gray-400 cursor-pointer">üîß Debug - Sync Settings</summary>
          <pre className="text-xs text-gray-400 mt-2 overflow-auto">
            {JSON.stringify(settings, null, 2)}
          </pre>
        </details>
      )}
    </div>
  );
};

export default CloudSyncSettings;
```
## üìÑ File: `ProcessingRegionForm.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/ProcessingRegionForm.js`

```javascript
import { useState, useEffect } from "react";
import api from "../../api";
import InstructionsPanel from "./InstructionsPanel";

const ProcessingRegionForm = ({ handleAnalyzeRegions }) => {
  const [videoPath, setVideoPath] = useState("");
  const [selectedVideoPath, setSelectedVideoPath] = useState("");
  const [error, setError] = useState("");
  const [analysisResult, setAnalysisResult] = useState(null);
  const [roiFramePath, setRoiFramePath] = useState("");
  const [showResultModal, setShowResultModal] = useState(false);
  const [cameraList, setCameraList] = useState([]);
  const [selectedCamera, setSelectedCamera] = useState("");
  const [processedCameras, setProcessedCameras] = useState([]);

  useEffect(() => {
    handleGetCameras();
  }, []);

  const handleFileSelect = (e) => {
    const file = e.target.files[0];
    if (file) {
      const path = file.path || file.name;
      setVideoPath(path);
      setSelectedVideoPath(path);
      setError("");
    } else {
      setVideoPath("");
      setSelectedVideoPath("");
    }
  };

  const handleGetCameras = async () => {
    try {
      const response = await api.get("/get-cameras");
      setCameraList(response.data.cameras || []);
      setError("");
    } catch (err) {
      setError("Kh√¥ng th·ªÉ l·∫•y danh s√°ch camera.");
    }
  };

  const handleSelectCamera = (camera) => {
    setSelectedCamera(camera);
    setVideoPath("");
    setSelectedVideoPath("");
    setError("");
  };

  const handleContinue = async () => {
    if (!videoPath && !selectedVideoPath) {
      setError("Vui l√≤ng ch·ªçn video baseline.");
      return;
    }
    if (!selectedCamera) {
      setError("Vui l√≤ng ch·ªçn m·ªôt camera.");
      return;
    }
    
    setError(""); // Clear previous errors
    
    try {
      console.log("Calling /run-select-roi (subprocess) with:", {
        videoPath: selectedVideoPath || videoPath,
        cameraId: selectedCamera,
        step: "packing"
      });
      
      // ‚úÖ FIXED: Use subprocess endpoint to avoid C++ OpenCV exception
      const response = await fetch('http://127.0.0.1:8080/run-select-roi', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          videoPath: selectedVideoPath || videoPath, 
          cameraId: selectedCamera,
          step: "packing"  // Explicitly specify step
        })
      });
      
      const result = await response.json();
      console.log("Result from /run-select-roi (subprocess):", result);
      
      if (result.success) {
        const newAnalysisResult = {
          success: true,
          message: result.message || "Hand detection completed successfully",
          roi: result.roi,
          hand_detected: result.hand_detected,
          roi_frame: result.roi_frame
        };
        console.log("Setting analysisResult in handleContinue:", newAnalysisResult);
        setAnalysisResult(newAnalysisResult);
        setRoiFramePath(result.roi_frame); // L∆∞u roiFramePath
        setShowResultModal(true);
      } else {
        setError(result.error || "Kh√¥ng th·ªÉ ch·∫°y hand detection.");
        console.error("Hand detection failed:", result.error);
      }
    } catch (err) {
      console.error("Error calling /run-select-roi:", err);
      setError("L·ªói khi ch·∫°y hand detection: " + err.message);
    }
  };

  const handleRetry = async () => {
    if (!selectedVideoPath && !videoPath) {
      setError("Vui l√≤ng ch·ªçn video baseline.");
      return;
    }
    
    setError(""); // Clear previous errors
    
    try {
      console.log("Retrying /run-select-roi with:", {
        videoPath: selectedVideoPath || videoPath,
        cameraId: selectedCamera,
        step: "packing"
      });
      
      // ‚úÖ FIXED: Use subprocess endpoint for retry
      const response = await fetch('http://127.0.0.1:8080/run-select-roi', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ 
          videoPath: selectedVideoPath || videoPath, 
          cameraId: selectedCamera,
          step: "packing"
        })
      });
      
      const result = await response.json();
      console.log("Result from /run-select-roi (retry):", result);
      
      if (result.success) {
        const newAnalysisResult = {
          success: true,
          message: result.message || "Hand detection completed successfully",
          roi: result.roi,
          hand_detected: result.hand_detected,
          roi_frame: result.roi_frame
        };
        console.log("Setting analysisResult in handleRetry:", newAnalysisResult);
        setAnalysisResult(newAnalysisResult);
        setRoiFramePath(result.roi_frame); // C·∫≠p nh·∫≠t roiFramePath v·ªõi file m·ªõi nh·∫•t
        setShowResultModal(true);
      } else {
        setError(result.error || "Kh√¥ng th·ªÉ ch·∫°y hand detection.");
        console.error("Hand detection retry failed:", result.error);
      }
    } catch (err) {
      console.error("Error retrying /run-select-roi:", err);
      setError("L·ªói khi ch·∫°y hand detection: " + err.message);
    }
  };

  const handleRoisSubmit = (rois) => {
    setProcessedCameras((prev) => [...new Set([...prev, selectedCamera])]);
    setSelectedCamera("");
  };

  const handleContinueWithAnotherCamera = () => {
    setAnalysisResult(null);
    setRoiFramePath("");
    setShowResultModal(false);
    setSelectedCamera("");
    setVideoPath("");
    setSelectedVideoPath("");
    setError("");
  };

  const handleExit = () => {
    setShowResultModal(false);
    handleAnalyzeRegions({
      success: true,
      message: "ƒê√£ ho√†n t·∫•t x·ª≠ l√Ω c√°c camera.",
      processedCameras,
    });
  };

  return (
    <div className="w-[25%] bg-gray-800 p-6 rounded-lg flex flex-col">
      <h1 className="text-3xl font-bold mb-4">V√πng x·ª≠ l√Ω</h1>
      <p className="text-gray-300 mb-4">
        T·∫£i l√™n video baseline (5s-5 ph√∫t) ƒë·ªÉ x√°c ƒë·ªãnh c√°c v√πng x·ª≠ l√Ω QR v√† ƒë√≥ng g√≥i.
      </p>
      
      <div className="mb-4">
        <button
          onClick={handleGetCameras}
          className="w-full py-2 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded"
        >
          L·∫•y danh s√°ch camera
        </button>
      </div>
      
      {cameraList && cameraList.length > 0 && (
        <div className="mb-4">
          <h3 className="text-lg font-bold mb-2">Ch·ªçn camera:</h3>
          <div className="max-h-24 overflow-y-auto">
            {cameraList.map((camera) => (
              <label key={camera} className="flex items-center mb-2">
                <input
                  type="radio"
                  name="camera"
                  className="mr-2"
                  checked={selectedCamera === camera}
                  onChange={() => handleSelectCamera(camera)}
                  disabled={processedCameras.includes(camera)}
                />
                {camera}
                {processedCameras.includes(camera) && (
                  <span className="ml-2 text-green-500">‚úî ƒê√£ x·ª≠ l√Ω</span>
                )}
              </label>
            ))}
          </div>
        </div>
      )}
      
      <div className="mb-4">
        <label className="block mb-1">Video baseline:</label>
        <div className="relative w-full">
          <input
            type="text"
            value={videoPath}
            onChange={(e) => {
              setVideoPath(e.target.value);
              setSelectedVideoPath(e.target.value);
            }}
            placeholder="Ch·ªçn video (e.g., /Users/annhu/vtrack_app/V_Track/baseline.mp4)"
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
          <button
            type="button"
            onClick={() => {
              const input = document.createElement("input");
              input.type = "file";
              input.accept = "video/*";
              input.onchange = handleFileSelect;
              input.click();
            }}
            className="absolute right-2 top-1/2 transform -translate-y-1/2 text-white"
          >
            ...
          </button>
        </div>
      </div>
      
      {videoPath && selectedCamera && (
        <div className="mb-4 flex justify-center">
          <button
            onClick={handleContinue}
            className="py-2 px-4 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded"
          >
            Ti·∫øp t·ª•c
          </button>
        </div>
      )}
      
      {showResultModal && analysisResult && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
          <div className="bg-gray-800 p-6 rounded-lg w-3/4 h-3/4 flex">
            <InstructionsPanel
              customInstruction={
                analysisResult.qr_detected
                  ? "Ti·∫øp t·ª•c x√°c ƒë·ªãnh v√πng trigger."
                  : "V·∫Ω l·∫°i v√πng m√£ v·∫≠n ƒë∆°n ho·∫∑c nh·∫•n Ti·∫øp t·ª•c ƒë·ªÉ ƒë·ªìng √Ω v·ªõi v√πng hi·ªán t·∫°i."
              }
              analysisResult={analysisResult}
              handDetected={analysisResult.hand_detected}
              qrDetected={analysisResult.qr_detected}
              onClose={handleExit}
              onSave={handleContinueWithAnotherCamera}
              onRetry={handleRetry}
              errorMessage={error}
              videoPath={selectedVideoPath || videoPath}
              cameraId={selectedCamera}
              onSubmit={handleRoisSubmit}
              setAnalysisResult={setAnalysisResult}
              roiFramePath={roiFramePath}
            />
          </div>
        </div>
      )}
      
      {error && (
        <div className="mb-4 p-3 bg-red-600 rounded text-white text-sm">
          <strong>L·ªói:</strong> {error}
        </div>
      )}
    </div>
  );
};

export default ProcessingRegionForm;
```
## üìÑ File: `AddSourceModal.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/AddSourceModal.js`

```javascript
// components/config/AddSourceModal.js - NO NVR VERSION
import React, { useState } from 'react';
import CloudConfigurationForm from './CloudConfigurationForm';
import GoogleDriveAuthButton from './GoogleDriveAuthButton';
import CloudSyncSettings from './CloudSyncSettings';
import GoogleDriveFolderTree from './GoogleDriveFolderTree';

const AddSourceModal = ({ show, onClose, onAdd, testSourceConnection }) => {
 const [sourceType, setSourceType] = useState('local');
 const [path, setPath] = useState('');
 const [config, setConfig] = useState({});
 const [isLoading, setIsLoading] = useState(false);
 const [testResult, setTestResult] = useState(null);

 // üÜï Cloud-specific states
 const [cloudAuthenticated, setCloudAuthenticated] = useState(false);
 const [authLoading, setAuthLoading] = useState(false);
 const [availableFolders, setAvailableFolders] = useState([]); // Keep for compatibility
 const [selectedFolders, setSelectedFolders] = useState([]); // Now handled by tree component
 const [treeFoldersSelected, setTreeFoldersSelected] = useState([]); // New: Tree selection

 const generateSourceName = (path, sourceType) => {
   if (!path) return '';
   
   if (sourceType === 'cloud') {
     // Cloud source name based on selected folders
     const provider = config.provider || 'google_drive';
     const folderName = selectedFolders.length > 0 ? 'multiple_folders' : 'cloud_storage';
     return `${provider}_${folderName.replace(/[^\w\d]/g, '_')}`;
   } else {
     const folderName = path.split('/').pop() || path.split('\\').pop() || 'source';
     return `${sourceType}_${folderName}`;
   }
 };

 const resetForm = () => {
   setSourceType('local');
   setPath('');
   setConfig({});
   setTestResult(null);
   // Reset cloud states
   setCloudAuthenticated(false);
   setAvailableFolders([]);
   setSelectedFolders([]);
   setTreeFoldersSelected([]);
 };

 // üîí SECURITY: Updated Google Drive Authentication Handler with session tokens
 const handleGoogleDriveAuth = async (authResult) => {
   if (authResult.success) {
     setCloudAuthenticated(true);
     
     setConfig(prev => ({
       ...prev,
       provider: 'google_drive',
       session_token: authResult.session_token, // üîí SECURITY: Session token instead of credentials
       user_email: authResult.user_email
     }));

     // Store root folders for tree initialization (lazy loading enabled)
      if (authResult.lazy_loading_enabled) {
        console.log('‚úÖ Lazy loading tree enabled');
        // Root folders will be handled by GoogleDriveFolderTree component
      } else if (authResult.folders && authResult.folders.length > 0) {
        setAvailableFolders(authResult.folders);
      }
     
   }
 };

 // üÜï Folder Selection Handler
 const handleFolderToggle = (folder) => {
   setSelectedFolders(prev => {
     const isSelected = prev.some(f => f.id === folder.id);
     if (isSelected) {
       return prev.filter(f => f.id !== folder.id);
     } else {
       return [...prev, folder];
     }
   });
 };

 // üÜï Select All/None Handlers
 const handleSelectAllFolders = () => {
   setSelectedFolders([...availableFolders]);
 };

 const handleDeselectAllFolders = () => {
   setSelectedFolders([]);
 };

 const handleTreeFolderSelection = (selectedTreeFolders) => {
  setTreeFoldersSelected(selectedTreeFolders);
  console.log(`üìÅ Tree selection updated: ${selectedTreeFolders.length} folders`);
 };

 // üÜï Cloud Sync Settings Handler
 const handleCloudSyncSettings = (syncConfig) => {
   setConfig(prev => ({
     ...prev,
     sync_settings: syncConfig
   }));
 };

 const handleTestConnection = async () => {
   if (sourceType === 'local' && !path) {
     alert('Please enter a path first');
     return;
   }

   setIsLoading(true);
   setTestResult(null);
   
   try {
     const testData = {
       source_type: sourceType,
       path: sourceType === 'local' ? path : config.url,
       config: config
     };

     const response = await testSourceConnection(testData);
     
     setTestResult({
       success: response.accessible,
       message: response.message
     });
     
   } catch (error) {
     setTestResult({
       success: false,
       message: error.message || 'Connection test failed'
     });
   } finally {
     setIsLoading(false);
   }
 };

 const handleSubmit = (e) => {
   e.preventDefault();
   
   if (sourceType === 'local' && !path) {
     alert('Please enter a path');
     return;
   }
   
   // üÜï Cloud submission validation - SIMPLIFIED
   if (sourceType === 'cloud') {
     if (!cloudAuthenticated) {
       alert('Please authenticate with Google Drive first');
       return;
     }
     if (treeFoldersSelected.length === 0) {
       alert('Please select at least one folder to monitor');
       return;
     }
   }

   const autoName = generateSourceName(
     sourceType === 'local' ? path : 
     sourceType === 'cloud' ? `google_drive://selected_folders` :
     config.url || 'source', 
     sourceType
   );

   const newSource = {
     source_type: sourceType,
     name: autoName,
     path: sourceType === 'local' ? path : 
           sourceType === 'cloud' ? `google_drive://selected_folders` :
           config.url,
     config: sourceType === 'cloud' ? {
       ...config,
       provider: 'google_drive',
       selected_folders: [...selectedFolders, ...treeFoldersSelected], // Combine both selections
       selected_tree_folders: treeFoldersSelected, // Store tree selections separately
       legacy_folders: selectedFolders, // Keep legacy for compatibility
       sync_settings: config.sync_settings || {
         interval_minutes: 15,
         auto_sync_enabled: true,
         sync_only_new: true,
         skip_duplicates: true
       }
     } : {}
   };

   onAdd(newSource);
   resetForm();
   onClose();
 };

 if (!show) return null;

 return (
   <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
     <div className="bg-gray-800 rounded-lg p-6 w-full max-w-4xl mx-4 max-h-[90vh] overflow-y-auto">
       <div className="flex justify-between items-center mb-6">
         <h3 className="text-xl font-bold text-white">Add New Video Source</h3>
         <button
           onClick={onClose}
           className="text-gray-400 hover:text-white text-2xl"
         >
           √ó
         </button>
       </div>

       <form onSubmit={handleSubmit}>
         {/* Source Type Cards */}
         <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-6">
           
           {/* Local Storage Card */}
           <div 
             className={`border-2 rounded-lg p-4 cursor-pointer transition-all ${
               sourceType === 'local' 
                 ? 'border-blue-500 bg-blue-900' 
                 : 'border-gray-600 bg-gray-700 hover:border-gray-500'
             }`}
             onClick={() => setSourceType('local')}
           >
             <div className="flex items-center mb-3">
               <span className="text-3xl mr-3">üìÅ</span>
               <div>
                 <h4 className="font-semibold text-white text-lg">Browse Files Directly</h4>
                 <p className="text-sm text-gray-300">Access folders containing videos</p>
               </div>
             </div>
             <div className="text-xs text-gray-400 leading-relaxed">
               ‚Ä¢ Local server folders<br/>
               ‚Ä¢ Mounted network drives (NAS, SMB, NFS)<br/>
               ‚Ä¢ Mounted NVR file shares<br/>
               ‚Ä¢ Any accessible folder path<br/>
               <span className="text-yellow-300 font-medium">üìç Mount network sources first</span>
             </div>
           </div>

           {/* üÜï Cloud Storage Card - SIMPLIFIED */}
           <div 
             className={`border-2 rounded-lg p-4 cursor-pointer transition-all ${
               sourceType === 'cloud' 
                 ? 'border-blue-500 bg-blue-900' 
                 : 'border-gray-600 bg-gray-700 hover:border-gray-500'
             }`}
             onClick={() => setSourceType('cloud')}
           >
             <div className="flex items-center mb-3">
               <span className="text-3xl mr-3">‚òÅÔ∏è</span>
               <div>
                 <h4 className="font-semibold text-white text-lg">Google Drive Integration</h4>
                 <p className="text-sm text-gray-300">Sync videos from cloud storage</p>
               </div>
             </div>
             <div className="text-xs text-gray-400 leading-relaxed">
               ‚Ä¢ Google Drive camera folders<br/>
               ‚Ä¢ Auto-sync new recordings<br/>
               ‚Ä¢ Simple folder selection<br/>
               ‚Ä¢ Background download to server<br/>
               <span className="text-green-300 font-medium">‚úÖ Simplified & Reliable!</span>
             </div>
           </div>
         </div>

         {/* Local Files Form */}
         {sourceType === 'local' && (
           <div className="bg-gray-700 rounded-lg p-6 mb-6">
             <h4 className="font-semibold text-white mb-4 text-lg">üìÅ Browse Files Directly Configuration</h4>
             
             <div className="bg-yellow-800 border border-yellow-600 rounded-lg p-4 mb-6">
               <div className="text-yellow-200">
                 <div className="font-semibold mb-2">üìç Network Storage Setup Guide:</div>
                 <div className="text-sm mb-2">For network sources (NAS, NVR file shares), mount them first:</div>
                 <div className="font-mono text-xs bg-black bg-opacity-30 p-2 rounded">
                   # SMB Example (NAS/NVR):<br/>
                   mount -t smbfs //server/share /mnt/folder<br/><br/>
                   # NFS Example:<br/>
                   mount -t nfs server:/export /mnt/folder
                 </div>
               </div>
             </div>

             <div className="mb-4">
               <label className="block text-sm font-medium text-gray-300 mb-2">
                 Folder Path *
               </label>
               <input
                 type="text"
                 value={path}
                 onChange={(e) => setPath(e.target.value)}
                 placeholder="/Users/videos or /mnt/nas-storage or /mnt/nvr-files"
                 className="w-full p-3 border border-gray-600 rounded-lg bg-gray-800 text-white text-sm"
                 required
               />
               <div className="text-xs text-gray-400 mt-2">
                 Local path or mounted network folder containing camera subfolders
               </div>
             </div>

             {path && (
               <div className="bg-gray-600 p-4 rounded-lg">
                 <div className="text-xs text-gray-400 mb-1">Auto-generated source name:</div>
                 <div className="text-lg text-white font-medium">{generateSourceName(path, sourceType)}</div>
               </div>
             )}
           </div>
         )}

         {/* üÜï Cloud Storage Form - SIMPLIFIED */}
         {sourceType === 'cloud' && (
           <div className="bg-gray-700 rounded-lg p-6 mb-6">
             <h4 className="font-semibold text-white mb-4 text-lg">‚òÅÔ∏è Google Drive Integration Configuration</h4>
             
             {/* Step 1: Authentication */}
             <div className="mb-6">
               <h5 className="font-medium text-white mb-3">Step 1: Authenticate with Google Drive</h5>
               <GoogleDriveAuthButton 
                 onAuth={handleGoogleDriveAuth}
                 isAuthenticated={cloudAuthenticated}
                 isLoading={authLoading}
                 userEmail={config?.user_email}
               />
             </div>

              {/* Step 2: Folder Selection */}
              {cloudAuthenticated && (
                <div className="mb-6">
                  <h5 className="font-medium text-white mb-3">Step 2: Navigate & Select Camera Folders</h5>
                  
                  <GoogleDriveFolderTree
                    session_token={config?.session_token}
                    onFoldersSelected={handleTreeFolderSelection}
                    maxDepth={4}
                    selectableDepth={4}
                    className="border border-gray-600 rounded-lg"
                  />
                </div>
              )}

             {/* Step 3: Sync Settings */}
             {cloudAuthenticated && treeFoldersSelected.length > 0 && (
               <div className="mb-6">
                 <h5 className="font-medium text-white mb-3">Step 3: Configure Sync Settings</h5>
                 <CloudSyncSettings
                   config={config.sync_settings || {
                     interval_minutes: 15,
                     auto_sync_enabled: true,
                     sync_only_new: true,
                     skip_duplicates: true
                   }}
                   onChange={handleCloudSyncSettings}
                 />
               </div>
             )}

             {/* Source Name Preview */}
             {treeFoldersSelected.length > 0 && (
               <div className="bg-gray-600 p-4 rounded-lg">
                 <div className="text-xs text-gray-400 mb-1">Auto-generated source name:</div>
                 <div className="text-lg text-white font-medium">{generateSourceName(`google_drive://selected_folders`, sourceType)}</div>
                 <div className="text-xs text-gray-400 mt-2">
                    {treeFoldersSelected.length} folders selected for monitoring
                  </div>
               </div>
             )}
           </div>
         )}

         {/* Test Connection - CH·ªà CHO LOCAL */}
         {sourceType === 'local' && (
           <div className="mb-6">
             <button
               type="button"
               onClick={handleTestConnection}
               disabled={isLoading || !path}
               className="bg-yellow-600 hover:bg-yellow-700 disabled:bg-gray-600 text-white px-6 py-3 rounded-lg font-medium mr-4"
             >
               {isLoading ? (
                 <span className="flex items-center">
                   <svg className="animate-spin -ml-1 mr-2 h-4 w-4 text-white" fill="none" viewBox="0 0 24 24">
                     <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                     <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                   </svg>
                   Testing...
                 </span>
               ) : (
                 'Test Connection'
               )}
             </button>
             
             {testResult && (
               <div className={`inline-block p-4 rounded-lg text-sm ${
                 testResult.success 
                   ? 'bg-green-800 text-green-200 border border-green-600' 
                   : 'bg-red-800 text-red-200 border border-red-600'
               }`}>
                 <div className="font-medium mb-1">
                   {testResult.success ? '‚úÖ Connection Successful' : '‚ùå Connection Failed'}
                 </div>
                 <div>{testResult.message}</div>
               </div>
             )}
           </div>
         )}

         {/* Action Buttons - UPDATED CONDITIONS */}
         <div className="flex gap-4 pt-4 border-t border-gray-600">
           <button
             type="submit"
             disabled={
               (sourceType === 'local' && !path) ||
               (sourceType === 'cloud' && (!cloudAuthenticated || treeFoldersSelected.length === 0))
             }
             className="bg-blue-600 hover:bg-blue-700 disabled:bg-gray-600 disabled:cursor-not-allowed text-white px-8 py-3 rounded-lg font-medium flex-1"
           >
             Add Source
           </button>
           <button
             type="button"
             onClick={() => {
               resetForm();
               onClose();
             }}
             className="bg-gray-600 hover:bg-gray-700 text-white px-8 py-3 rounded-lg font-medium flex-1"
           >
             Cancel
           </button>
         </div>
       </form>
     </div>
   </div>
 );
};

export default AddSourceModal;
```
## üìÑ File: `GoogleDriveFolderTree.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/GoogleDriveFolderTree.js`

```javascript
// components/config/GoogleDriveFolderTree.js - CONSISTENT DEPTH SELECTION
import React, { useState, useEffect, useCallback } from 'react';

const GoogleDriveFolderTree = ({ 
  session_token, 
  onFoldersSelected, 
  maxDepth = 3, // üéØ REQUIREMENT: Max depth 3 only
  className = ''
}) => {
  // Tree state management
  const [treeData, setTreeData] = useState({});
  const [expandedFolders, setExpandedFolders] = useState(new Set(['root']));
  const [selectedFolders, setSelectedFolders] = useState([]);
  const [selectedDepth, setSelectedDepth] = useState(null); // üéØ NEW: Track selected depth
  const [loadingFolders, setLoadingFolders] = useState(new Set());
  const [error, setError] = useState(null);
  const [authStatus, setAuthStatus] = useState({ authenticated: false, loading: true });

  // üîí SECURITY: Validate session token and initialize
  useEffect(() => {
    const validateAndInit = async () => {
      if (!session_token) {
        setAuthStatus({ authenticated: false, loading: false });
        return;
      }

      try {
        setAuthStatus({ authenticated: false, loading: true });
        
        const response = await fetch('http://localhost:8080/api/cloud/auth-status', {
          method: 'GET',
          headers: { 
            'Content-Type': 'application/json',
            'Authorization': `Bearer ${session_token}`
          },
          credentials: 'include'
        });

        if (response.ok) {
          const result = await response.json();
          if (result.authenticated) {
            setAuthStatus({ authenticated: true, loading: false });
            await loadRootFolders();
          } else {
            setAuthStatus({ authenticated: false, loading: false });
            setError('Session expired. Please re-authenticate.');
          }
        } else {
          setAuthStatus({ authenticated: false, loading: false });
          setError('Authentication validation failed.');
        }
      } catch (error) {
        console.error('Session validation error:', error);
        setAuthStatus({ authenticated: false, loading: false });
        setError('Failed to validate session.');
      }
    };

    validateAndInit();
  }, [session_token]);

  // Notify parent when selection changes
  useEffect(() => {
    if (onFoldersSelected) {
      onFoldersSelected(selectedFolders);
    }
  }, [selectedFolders, onFoldersSelected]);

  const loadRootFolders = async () => {
    try {
      setLoadingFolders(prev => new Set([...prev, 'root']));
      setError(null);

      console.log('üîÑ Loading root folders with session token...');

      const response = await fetch('http://localhost:8080/api/cloud/folders/initialize', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${session_token}`
        },
        credentials: 'include',
        body: JSON.stringify({
          max_folders: 30
        })
      });

      if (!response.ok) {
        throw new Error(`Failed to load root folders: ${response.status}`);
      }

      const data = await response.json();

      if (!data.success) {
        throw new Error(data.message || 'Failed to load root folders');
      }

      // Initialize tree with root data
      setTreeData({
        'root': {
          id: 'root',
          name: 'My Drive',
          depth: 0,
          selectable: false,
          has_subfolders: true,
          children: data.folders || [],
          loaded: true
        }
      });

      console.log(`‚úÖ Loaded ${(data.folders || []).length} root folders`);

    } catch (error) {
      console.error('‚ùå Error loading root folders:', error);
      setError(error.message);
    } finally {
      setLoadingFolders(prev => {
        const next = new Set(prev);
        next.delete('root');
        return next;
      });
    }
  };

  const loadSubfolders = async (parentId, parentDepth) => {
    try {
      // üéØ REQUIREMENT: Don't load beyond depth 3
      if (parentDepth >= maxDepth) {
        console.log(`üõë Stopping at max depth ${maxDepth}, not loading subfolders for depth ${parentDepth + 1}`);
        return;
      }

      setLoadingFolders(prev => new Set([...prev, parentId]));
      setError(null);

      console.log(`üîÑ Loading subfolders for: ${parentId} (will be depth ${parentDepth + 1})`);

      const response = await fetch('http://localhost:8080/api/cloud/folders/list_subfolders', {
        method: 'POST',
        headers: { 
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${session_token}`
        },
        credentials: 'include',
        body: JSON.stringify({
          parent_id: parentId,
          max_results: 50
        })
      });

      if (!response.ok) {
        throw new Error(`Failed to load subfolders: ${response.status}`);
      }

      const data = await response.json();

      if (!data.success) {
        throw new Error(data.message || 'Failed to load subfolders');
      }

      // Process folders with depth limit
      const processedFolders = (data.folders || []).map(folder => ({
        ...folder,
        depth: parentDepth + 1,
        // üéØ REQUIREMENT: No subfolders beyond depth 3
        has_subfolders: (parentDepth + 1) < maxDepth ? folder.has_subfolders : false
      }));

      // Update tree data
      setTreeData(prev => ({
        ...prev,
        [parentId]: {
          ...prev[parentId],
          children: processedFolders,
          loaded: true
        }
      }));

      console.log(`‚úÖ Loaded ${processedFolders.length} subfolders for ${parentId} (depth ${parentDepth + 1})`);

    } catch (error) {
      console.error(`‚ùå Error loading subfolders for ${parentId}:`, error);
      setError(error.message);
    } finally {
      setLoadingFolders(prev => {
        const next = new Set(prev);
        next.delete(parentId);
        return next;
      });
    }
  };

  const handleFolderExpand = useCallback(async (event, folder) => {
    event.stopPropagation();
    event.preventDefault();
    
    const folderId = folder.id;
    
    console.log(`üîΩ Expand/collapse action for: ${folder.name} (depth ${folder.depth})`);
    
    if (expandedFolders.has(folderId)) {
      setExpandedFolders(prev => {
        const next = new Set(prev);
        next.delete(folderId);
        return next;
      });
      console.log(`üìÅ Collapsed: ${folder.name}`);
    } else {
      setExpandedFolders(prev => new Set([...prev, folderId]));
      console.log(`üìÇ Expanded: ${folder.name}`);
      
      // üéØ REQUIREMENT: Only load if within depth limit
      if (folder.has_subfolders && folder.depth < maxDepth && (!treeData[folderId] || !treeData[folderId].loaded)) {
        await loadSubfolders(folderId, folder.depth);
      }
    }
  }, [expandedFolders, treeData, session_token, maxDepth]);

  const handleFolderSelect = useCallback((event, folder) => {
    event.stopPropagation();
    
    console.log(`üîç Folder selection attempt:`, folder.name, `Depth: ${folder.depth}`);
    
    const folderId = folder.id;
    const folderDepth = folder.depth;
    
    // üéØ REQUIREMENT: Check depth consistency
    if (selectedDepth !== null && selectedDepth !== folderDepth) {
      // Show warning and don't allow selection
      setError(`Cannot mix different depth levels. Currently selected: Depth ${selectedDepth}. Clear selection to choose Depth ${folderDepth} folders.`);
      return;
    }
    
    setSelectedFolders(prev => {
      const isSelected = prev.some(f => f.id === folderId);
      if (isSelected) {
        console.log(`‚ùå Deselecting folder: ${folder.name}`);
        const newSelection = prev.filter(f => f.id !== folderId);
        
        // üéØ REQUIREMENT: Reset selected depth if no folders left
        if (newSelection.length === 0) {
          setSelectedDepth(null);
          setError(null); // Clear any depth error
          console.log(`üîÑ Reset selected depth - no folders selected`);
        }
        
        return newSelection;
      } else {
        console.log(`‚úÖ Selecting folder: ${folder.name} at depth ${folderDepth}`);
        
        // üéØ REQUIREMENT: Set selected depth on first selection
        if (selectedDepth === null) {
          setSelectedDepth(folderDepth);
          setError(null); // Clear any previous errors
          console.log(`üéØ Set selected depth to: ${folderDepth}`);
        }
        
        return [...prev, {
          id: folder.id,
          name: folder.name,
          path: folder.path,
          depth: folder.depth
        }];
      }
    });
  }, [selectedDepth]);

  const handleSelectAll = useCallback(() => {
    if (selectedDepth === null) {
      setError('Please select a folder first to determine the depth level, then use "Select All" for that depth.');
      return;
    }
    
    console.log(`‚úÖ Selecting all visible folders at depth ${selectedDepth}`);
    const depthFolders = [];
    
    const collectDepthFolders = (nodeId) => {
      const node = treeData[nodeId];
      if (!node) return;
      
      if (node.children) {
        node.children.forEach(child => {
          if (child.depth === selectedDepth) {
            depthFolders.push({
              id: child.id,
              name: child.name,
              path: child.path,
              depth: child.depth
            });
          }
          if (expandedFolders.has(child.id) && child.depth < selectedDepth) {
            collectDepthFolders(child.id);
          }
        });
      }
    };
    
    collectDepthFolders('root');
    setSelectedFolders(depthFolders);
    setError(null);
  }, [treeData, expandedFolders, selectedDepth]);

  const handleDeselectAll = useCallback(() => {
    console.log('üóëÔ∏è Clearing all selections and resetting depth');
    setSelectedFolders([]);
    setSelectedDepth(null);
    setError(null);
  }, []);

  // üéØ NEW: Get folder type label by depth
  const getFolderTypeLabel = useCallback((folder) => {
    switch (folder.depth) {
      case 1: return 'Main Folder';
      case 2: return 'Camera Folder';  
      case 3: return 'Date/Category';
      default: return 'Folder';
    }
  }, []);

  // üéØ NEW: Check if folder is selectable (considering depth constraint)
  const isFolderSelectable = useCallback((folder) => {
    // Always show checkbox for depth 1-3
    if (folder.depth < 1 || folder.depth > maxDepth) return false;
    
    // If no depth selected yet, all depths are available
    if (selectedDepth === null) return true;
    
    // If depth is selected, only same depth is selectable
    return folder.depth === selectedDepth;
  }, [selectedDepth, maxDepth]);

  const renderFolderIcon = (folder, isExpanded, isLoading) => {
    if (isLoading) {
      return (
        <svg className="animate-spin h-4 w-4 text-blue-400" fill="none" viewBox="0 0 24 24">
          <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
          <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
        </svg>
      );
    }

    if (folder.has_subfolders) {
      return isExpanded ? '‚ñº' : '‚ñ∂';
    }
    return 'üìÅ';
  };

  const renderFolderNode = (folder, depth = 0) => {
    const isExpanded = expandedFolders.has(folder.id);
    const isLoading = loadingFolders.has(folder.id);
    const isSelected = selectedFolders.some(f => f.id === folder.id);
    const hasSubfolders = folder.has_subfolders;
    
    // üéØ REQUIREMENT: Show checkbox for all depths 1-3, but consider depth consistency
    const showCheckbox = folder.depth >= 1 && folder.depth <= maxDepth;
    const isSelectable = isFolderSelectable(folder);
    const isDisabled = showCheckbox && !isSelectable;

    return (
      <div key={folder.id} className="folder-node">
        {/* Folder Row */}
        <div 
          className={`flex items-center py-2 px-3 rounded transition-colors ${
            isSelected 
              ? 'bg-blue-600' 
              : isDisabled 
                ? 'bg-gray-600 opacity-50' 
                : 'hover:bg-gray-600'
          }`}
          style={{ paddingLeft: `${depth * 20 + 12}px` }}
        >
          {/* Expand/Collapse Button */}
          <button
            type="button"
            onClick={(e) => handleFolderExpand(e, folder)}
            disabled={isLoading || !hasSubfolders}
            className={`mr-2 w-6 h-6 flex items-center justify-center text-sm ${
              hasSubfolders ? 'text-gray-300 hover:text-white cursor-pointer' : 'text-gray-500 cursor-default'
            }`}
          >
            {renderFolderIcon(folder, isExpanded, isLoading)}
          </button>

          {/* üéØ REQUIREMENT: Checkbox with depth consistency */}
          {showCheckbox && (
            <input
              type="checkbox"
              checked={isSelected}
              disabled={isDisabled}
              onChange={(e) => handleFolderSelect(e, folder)}
              className={`mr-3 h-4 w-4 text-blue-600 rounded border-gray-600 bg-gray-700 ${
                isDisabled ? 'opacity-50 cursor-not-allowed' : 'cursor-pointer'
              }`}
              title={
                isDisabled 
                  ? `Cannot select depth ${folder.depth}. Currently selecting depth ${selectedDepth}.`
                  : `Select ${folder.name} (${getFolderTypeLabel(folder)})`
              }
            />
          )}

          {/* Folder Info */}
          <div className="flex-1 min-w-0">
            <div className={`text-sm truncate ${
              isSelected 
                ? 'text-white font-bold'
                : showCheckbox && isSelectable
                  ? 'text-white font-medium' 
                  : isDisabled
                    ? 'text-gray-400'
                    : 'text-gray-300'
            }`}>
              {folder.name}
            </div>
            {folder.path && (
              <div className="text-xs text-gray-400 truncate">
                {folder.path}
              </div>
            )}
          </div>

          {/* üéØ NEW: Depth & Status Indicator */}
          <div className="flex items-center gap-2">
            {/* Depth Badge */}
            <div className={`text-xs px-2 py-1 rounded ${
              folder.depth === 1 ? 'bg-green-600 text-green-100' :
              folder.depth === 2 ? 'bg-blue-600 text-blue-100' :
              folder.depth === 3 ? 'bg-purple-600 text-purple-100' :
              'bg-gray-600 text-gray-100'
            }`}>
              D{folder.depth}
            </div>
            
            {/* Selection Status */}
            {showCheckbox && (
              <div className={`text-xs px-2 py-1 rounded ${
                isSelected 
                  ? 'bg-green-600 text-green-100' 
                  : isDisabled
                    ? 'bg-gray-500 text-gray-300'
                    : 'bg-gray-600 text-gray-300'
              }`}>
                {isSelected ? '‚úÖ Selected' : 
                 isDisabled ? 'Different Depth' :
                 getFolderTypeLabel(folder)}
              </div>
            )}
          </div>
        </div>

        {/* Child Folders - üéØ REQUIREMENT: Only if within depth limit */}
        {isExpanded && folder.depth < maxDepth && treeData[folder.id] && treeData[folder.id].children && (
          <div className="children">
            {treeData[folder.id].children.map(childFolder => 
              renderFolderNode(childFolder, depth + 1)
            )}
          </div>
        )}
      </div>
    );
  };

  // üîí SECURITY: Check authentication status
  if (!session_token) {
    return (
      <div className="text-center py-8 text-gray-400 border border-gray-600 rounded-lg">
        <div className="text-lg mb-2">üîê</div>
        <div>Please authenticate with Google Drive first</div>
      </div>
    );
  }

  if (authStatus.loading) {
    return (
      <div className="text-center py-8 text-gray-400 border border-gray-600 rounded-lg">
        <div className="text-lg mb-2">üîÑ</div>
        <div>Validating authentication...</div>
      </div>
    );
  }

  if (!authStatus.authenticated) {
    return (
      <div className="text-center py-8 text-red-400 border border-red-600 rounded-lg">
        <div className="text-lg mb-2">‚ùå</div>
        <div>Authentication required</div>
        <div className="text-sm text-red-300 mt-2">
          {error || 'Please re-authenticate with Google Drive'}
        </div>
      </div>
    );
  }

  return (
    <div className={`google-drive-folder-tree ${className}`}>
      {/* Header with Depth Info */}
      <div className="flex items-center justify-between mb-4">
        <div>
          <h4 className="font-medium text-white">üìÅ Navigate & Select Folders (Max Depth {maxDepth})</h4>
          <div className="text-xs text-gray-400 mt-1">
            {selectedDepth !== null ? (
              <span className="text-blue-300">
                Currently selecting: <strong>Depth {selectedDepth}</strong> ({getFolderTypeLabel({depth: selectedDepth})})
              </span>
            ) : (
              <span>Select folders at any depth (1-{maxDepth}), but all must be same depth</span>
            )}
          </div>
        </div>
        <div className="flex gap-2">
          <button
            type="button"
            onClick={(e) => {
              e.stopPropagation();
              e.preventDefault();
              handleSelectAll();
            }}
            disabled={selectedDepth === null}
            className={`px-3 py-1 rounded text-xs ${
              selectedDepth === null
                ? 'bg-gray-700 text-gray-400 cursor-not-allowed'
                : 'bg-blue-600 text-white hover:bg-blue-700'
            }`}
          >
            Select All Depth {selectedDepth || '?'}
          </button>
          <button
            type="button"
            onClick={(e) => {
              e.stopPropagation();
              e.preventDefault();
              handleDeselectAll();
            }}
            className="px-3 py-1 bg-gray-600 text-white rounded text-xs hover:bg-gray-700"
          >
            Clear All
          </button>
        </div>
      </div>



      {/* Selection Summary */}
      {selectedFolders.length > 0 && (
        <div className="mb-4 p-3 bg-green-800 border border-green-600 rounded-lg">
          <div className="text-green-200 text-sm">
            ‚úÖ Selected {selectedFolders.length} folder(s) at <strong>Depth {selectedDepth}</strong>:
          </div>
          <div className="text-green-100 text-xs mt-1 max-h-20 overflow-y-auto">
            {selectedFolders.map((f, idx) => (
              <div key={f.id}>
                {idx + 1}. {f.name} <span className="text-green-300">({getFolderTypeLabel(f)})</span>
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Error Display */}
      {error && (
        <div className="mb-4 p-3 bg-red-800 border border-red-600 rounded-lg">
          <div className="text-red-200 text-sm">
            ‚ö†Ô∏è {error}
          </div>
          <button
            onClick={() => setError(null)}
            type="button"
            className="mt-2 px-3 py-1 bg-red-600 text-white rounded text-xs hover:bg-red-700"
          >
            Dismiss
          </button>
        </div>
      )}

      {/* Tree Container */}
      <div className="tree-container bg-gray-700 rounded-lg p-4 max-h-96 overflow-y-auto border border-gray-600">
        {treeData['root'] ? (
          <div>
            {/* Root Node */}
            <div className="flex items-center py-2 px-3 bg-gray-600 rounded mb-2">
              <span className="mr-2 text-lg">üíæ</span>
              <div className="flex-1">
                <div className="text-white font-medium">My Drive</div>
                <div className="text-xs text-gray-300">Root directory - expand to navigate (max depth {maxDepth})</div>
              </div>
              <div className="text-xs px-2 py-1 bg-gray-500 text-gray-200 rounded">D0 Root</div>
            </div>

            {/* Root Children */}
            {treeData['root'].children && treeData['root'].children.map(folder => 
              renderFolderNode(folder, 0)
            )}
          </div>
        ) : (
          <div className="text-center py-8 text-gray-400">
            <div className="text-lg mb-2">üîÑ</div>
            <div>Loading folders...</div>
          </div>
        )}
      </div>

      {/* üéØ NEW: Updated Instructions */}
      <div className="mt-4 p-3 bg-blue-800 border border-blue-600 rounded-lg">
        <div className="text-blue-200 text-sm">
          <div className="font-medium mb-1">üìç Selection Rules:</div>
          <div className="text-xs space-y-1">
            <div>‚Ä¢ Folders displayed up to depth {maxDepth} only</div>
            <div>‚Ä¢ Checkboxes available on all depth levels (1-{maxDepth})</div>
            <div>‚Ä¢ All selected folders must be at the same depth level</div>
            <div>‚Ä¢ Use "Clear All" to switch to different depth level</div>
          </div>
        </div>
      </div>

      {/* Debug Info (Development) */}
      {process.env.NODE_ENV === 'development' && (
        <details className="mt-4 p-3 bg-gray-800 rounded">
          <summary className="text-xs text-gray-400 cursor-pointer">üîß Debug - Depth Consistency</summary>
          <pre className="text-xs text-gray-400 mt-2 overflow-auto max-h-32">
            {JSON.stringify({
              maxDepth: maxDepth,
              selectedDepth: selectedDepth,
              selectedCount: selectedFolders.length,
              selectedFolders: selectedFolders.map(f => ({ name: f.name, depth: f.depth, type: getFolderTypeLabel(f) })),
              expandedCount: expandedFolders.size,
              authentication: authStatus.authenticated,
              hasError: !!error
            }, null, 2)}
          </pre>
        </details>
      )}
    </div>
  );
};

export default GoogleDriveFolderTree;
```
## üìÑ File: `InstructionsPanel.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/InstructionsPanel.js`

```javascript
import React, { useState, useEffect } from 'react';
import { getFinalRoiFrame } from "../../api";

const InstructionsPanel = ({
  step,
  customInstruction,
  analysisResult,
  errorMessage,
  onSave,
  onClose,
  onRetry,
  handDetected,
  videoPath,
  cameraId,
  onSubmit,
  setAnalysisResult,
  roiFramePath,
}) => {
  const [roiFrameSrc, setRoiFrameSrc] = useState(null);
  const [finalRoiFrameSrc, setFinalRoiFrameSrc] = useState(null);
  const [rois, setRois] = useState([]);
  const [internalError, setInternalError] = useState("");
  const [currentStep, setCurrentStep] = useState("packing");
  const [roiImageState, setRoiImageState] = useState({
    step: "packing",
    file: "roi_packing.jpg",
    ready: false,
  });
  const [imageAspectRatio, setImageAspectRatio] = useState(null);

  const loadRoiImage = async (fileSuffix, retryCount = 0, maxRetries = 3) => {
    try {
      if (!cameraId) {
        console.error("Missing cameraId", { cameraId });
        setInternalError("Thi·∫øu cameraId.");
        return;
      }

      console.log(`Loading ROI image with camera_id: ${cameraId}, file: ${fileSuffix}`);
      const timestamp = new Date().getTime();
      const url = `http://localhost:8080/get-roi-frame?camera_id=${cameraId}&file=${fileSuffix}&t=${timestamp}`;
      const response = await fetch(url, {
        headers: { 'Cache-Control': 'no-cache' },
      });
      if (!response.ok && response.status !== 304) {
        const errorText = await response.text();
        throw new Error(`HTTP error! status: ${response.status}, message: ${errorText}`);
      }
      console.log("Response from /get-roi-frame:", response);
      setRoiFrameSrc(url);
      setRoiImageState({ step: currentStep, file: fileSuffix, ready: true });
      console.log("roiFrameSrc updated to:", url);
    } catch (error) {
      console.error("Error loading ROI image:", error);
      if (retryCount < maxRetries) {
        console.log(`Retrying loadRoiImage (${retryCount + 1}/${maxRetries})...`);
        setTimeout(() => loadRoiImage(fileSuffix, retryCount + 1, maxRetries), 500);
      } else {
        setInternalError(`Kh√¥ng th·ªÉ t·∫£i ·∫£nh t·∫°m: ${error.message}. Vui l√≤ng th·ª≠ l·∫°i.`);
      }
    }
  };

  useEffect(() => {
    console.log("useEffect triggered with analysisResult:", analysisResult, "currentStep:", currentStep, "roiImageState:", roiImageState);
    if (analysisResult && analysisResult.roi_frame && roiImageState.ready) {
      loadRoiImage(roiImageState.file);
    } else if (currentStep === "packing" && analysisResult?.roi_frame) {
      loadRoiImage("roi_packing.jpg");
    }
  }, [analysisResult, currentStep, roiImageState.ready]);

  const fetchFinalRoiFrame = async () => {
    try {
      console.log(`Calling /get-final-roi-frame with camera_id: ${cameraId}`);
      const timestamp = new Date().getTime();
      const url = `http://localhost:8080/get-final-roi-frame?camera_id=${cameraId}&t=${timestamp}`;
      const response = await fetch(url, {
        headers: { 'Cache-Control': 'no-cache' },
      });
      if (!response.ok && response.status !== 304) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      console.log("Response from /get-final-roi-frame:", response);
      setFinalRoiFrameSrc(url);
    } catch (error) {
      console.error("Error fetching final ROI frame:", error);
      setInternalError("Kh√¥ng th·ªÉ t·∫£i ·∫£nh t·ªïng h·ª£p. Vui l√≤ng th·ª≠ l·∫°i.");
    }
  };

  const handleConfirmRoi = async () => {
    if (currentStep === "packing" && analysisResult?.roi) {
      if (!analysisResult || typeof analysisResult.hand_detected === "undefined") {
        setInternalError("Kh√¥ng t√¨m th·∫•y th√¥ng tin ph√°t hi·ªán tay t·ª´ backend. Vui l√≤ng th·ª≠ l·∫°i.");
        return;
      }
      if (!analysisResult.hand_detected) {
        setInternalError("Kh√¥ng ph√°t hi·ªán tay. Vui l√≤ng v·∫Ω l·∫°i v√πng packing ho·∫∑c tho√°t.");
        return;
      }
      if (!analysisResult.roi_frame) {
        setInternalError("Thi·∫øu ƒë∆∞·ªùng d·∫´n ·∫£nh t·∫°m packing. Vui l√≤ng th·ª≠ l·∫°i.");
        return;
      }

      const newRoi = { type: currentStep, ...analysisResult.roi };
      const updatedRois = [...rois, newRoi];
      setRois(updatedRois);
      setCurrentStep("mvd");
      setRoiImageState({ step: "mvd", file: "roi_packing.jpg", ready: true });
      try {
        console.log("Calling /run-qr-detector for mvd step with videoPath:", videoPath, "cameraId:", cameraId, "roiFramePath:", analysisResult.roi_frame);
        const response = await fetch('http://localhost:8080/run-qr-detector', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ videoPath, cameraId, roiFramePath: analysisResult.roi_frame }),
        });
        const result = await response.json();
        console.log("Result from /run-qr-detector (mvd):", result);
        if (result.success) {
          const tempResult = {
            success: true,
            message: result.message || "QR detection completed successfully",
            rois: result.rois,
            qr_detected: result.qr_detected,
            qr_detected_roi1: result.qr_detected_roi1,
            qr_detected_roi2: result.qr_detected_roi2,
            roi_frame: result.roi_frame,
            qr_content: result.qr_content,
            trigger_detected: result.trigger_detected,
            table_type: result.table_type,
          };
        
          if (result.roi_frame) {
            setRoiImageState({ step: "mvd", file: "roi_MVD.jpg", ready: true });
            await loadRoiImage("roi_MVD.jpg");
            setAnalysisResult(tempResult); // Ch·ªâ set sau khi ·∫£nh t·∫£i xong
          } else {
            console.log("No roi_frame in result, keeping roi_packing.jpg");
            setAnalysisResult(tempResult);
          }
        } else {
          setInternalError(result.error || "Kh√¥ng th·ªÉ v·∫Ω v√πng m√£ v·∫≠n ƒë∆°n.");
        }
      } catch (error) {
        setInternalError("L·ªói khi v·∫Ω v√πng m√£ v·∫≠n ƒë∆°n: " + error.message);
      }
    } else if (currentStep === "mvd" && analysisResult?.rois) {
      if (!analysisResult || typeof analysisResult.qr_detected === "undefined") {
        setInternalError("Kh√¥ng t√¨m th·∫•y th√¥ng tin ph√°t hi·ªán QR t·ª´ backend. Vui l√≤ng th·ª≠ l·∫°i.");
        return;
      }
      if (!analysisResult.qr_detected) {
        setInternalError("Kh√¥ng ph√°t hi·ªán m√£ QR. Vui l√≤ng v·∫Ω l·∫°i v√πng MVD ho·∫∑c tho√°t.");
        return;
      }
      if (!analysisResult.roi_frame) {
        setInternalError("Thi·∫øu ƒë∆∞·ªùng d·∫´n ·∫£nh t·∫°m MVD. Vui l√≤ng th·ª≠ l·∫°i.");
        return;
      }

      const newRois = analysisResult.rois.map((roi) => ({ type: currentStep, ...roi }));
      const updatedRois = [...rois, ...newRois];
      setRois(updatedRois);
      setCurrentStep("done");
      try {
        const response = await fetch('http://localhost:8080/finalize-roi', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ videoPath, cameraId, rois: updatedRois }),
        });
        const result = await response.json();
        if (result.success) {
          await fetchFinalRoiFrame();
          onSubmit(updatedRois);
          onSave();
        } else {
          setInternalError(result.error || "Kh√¥ng th·ªÉ t·∫°o ·∫£nh t·ªïng h·ª£p.");
        }
      } catch (error) {
        setInternalError("L·ªói khi t·∫°o ·∫£nh t·ªïng h·ª£p: " + error.message);
      }
    }
    if (currentStep === "done") {
      onSave();
    }
  };

  const handleRetryStep = async () => {
    if (!videoPath || !cameraId) {
      setInternalError("Thi·∫øu videoPath ho·∫∑c cameraId.");
      return;
    }

    try {
      if (currentStep === "packing") {
        console.log("Calling /run-select-roi for retry with videoPath:", videoPath, "cameraId:", cameraId);
        const response = await fetch('http://localhost:8080/run-select-roi', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ videoPath, cameraId }),
        });
        const result = await response.json();
        console.log("Result from /run-select-roi (retry):", result);
        if (result.success) {
          const newAnalysisResult = {
            success: true,
            message: result.message || "Hand detection completed successfully",
            roi: result.roi,
            hand_detected: result.hand_detected,
            roi_frame: result.roi_frame,
          };
          setAnalysisResult(newAnalysisResult);
          if (result.roi_frame) {
            setRoiImageState({ step: "packing", file: "roi_packing.jpg", ready: true });
            await loadRoiImage("roi_packing.jpg");
          }
        } else {
          setInternalError(result.error || `Kh√¥ng th·ªÉ ch·∫°y l·∫°i hand detection.`);
        }
      } else if (currentStep === "mvd") {
        console.log("Calling /run-qr-detector for retry with videoPath:", videoPath, "cameraId:", cameraId, "roiFramePath:", analysisResult.roi_frame);
        const response = await fetch('http://localhost:8080/run-qr-detector', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ videoPath, cameraId, roiFramePath: analysisResult.roi_frame }),
        });
        const result = await response.json();
        console.log("Result from /run-qr-detector (retry):", result);
        if (result.success) {
          const newAnalysisResult = {
            success: true,
            message: result.message || "QR detection completed successfully",
            rois: result.rois,
            qr_detected: result.qr_detected,
            qr_detected_roi1: result.qr_detected_roi1,
            qr_detected_roi2: result.qr_detected_roi2,
            qr_content: result.qr_content,
            roi_frame: result.roi_frame,
            trigger_detected: result.trigger_detected,
            table_type: result.table_type,
          };
          setAnalysisResult(newAnalysisResult);
          if (result.roi_frame && result.qr_detected) {
            setRoiImageState({ step: "mvd", file: "roi_MVD.jpg", ready: true });
            await loadRoiImage("roi_MVD.jpg");
          } else {
            setInternalError("Kh√¥ng th·ªÉ t·∫£i ·∫£nh ho·∫∑c kh√¥ng ph√°t hi·ªán QR.");
          }
        } else {
          setInternalError(result.error || `Kh√¥ng th·ªÉ ch·∫°y l·∫°i QR detection.`);
        }
      }
    } catch (error) {
      setInternalError(`L·ªói khi ch·∫°y l·∫°i: ${error.message}`);
    }
  };

  const handleImageLoad = (e) => {
    const { width, height } = e.target;
    setImageAspectRatio(width / height);
  };

  return (
    <div className="flex w-full h-full">
      <div className="w-1/4 pr-4 flex flex-col border-r-2 border-gray-500">
        <div className="mb-4">
          <h3 className="text-2xl font-bold mb-2 text-white">K·∫øt qu·∫£</h3>
          {currentStep === "mvd" ? (
            <>
              {analysisResult?.table_type === "standard" ? (
                <>
                  <div className={`p-2 rounded text-white flex items-center ${analysisResult?.trigger_detected ? 'bg-green-600' : 'bg-red-600'}`}>
                    <span className="mr-2">{analysisResult?.trigger_detected ? '‚úî' : '‚úò'}</span>
                    <p>ROI Trigger: {analysisResult?.trigger_detected ? 'C√≥' : 'Kh√¥ng'}</p>
                  </div>
                  <div className={`p-2 rounded text-white flex items-center mt-2 ${analysisResult?.qr_detected_roi1 ? 'bg-green-600' : 'bg-red-600'}`}>
                    <span className="mr-2">{analysisResult?.qr_detected_roi1 ? '‚úî' : '‚úò'}</span>
                    <p>ROI MVD: {analysisResult?.qr_detected_roi1 ? 'C√≥' : 'Kh√¥ng'}</p>
                  </div>
                </>
              ) : (
                <>
                  {typeof analysisResult?.qr_detected_roi1 !== 'undefined' && (
                    <div className={`p-2 rounded text-white flex items-center ${analysisResult?.qr_detected_roi1 ? 'bg-green-600' : 'bg-red-600'}`}>
                      <span className="mr-2">{analysisResult?.qr_detected_roi1 ? '‚úî' : '‚úò'}</span>
                      <p>ROI 1: {analysisResult?.qr_detected_roi1 ? 'C√≥' : 'Kh√¥ng'}</p>
                    </div>
                  )}
                </>
              )}
            </>
          ) : (
            <div className={`p-2 rounded text-white flex items-center ${handDetected ? 'bg-green-600' : 'bg-red-600'}`}>
              <span className="mr-2">{handDetected ? '‚úî' : '‚úò'}</span>
              <p>{handDetected ? `X√°c nh·∫≠n v√πng ${currentStep}` : 'Kh√¥ng ph√°t hi·ªán chuy·ªÉn ƒë·ªông'}</p>
            </div>
          )}
          {errorMessage && (
            <div className="mt-2 p-2 bg-red-600 rounded text-white">
              <p>{errorMessage}</p>
            </div>
          )}
          {internalError && (
            <div className="mt-2 p-2 bg-red-600 rounded text-white">
              <p>{internalError}</p>
            </div>
          )}
        </div>
        <div className="mb-4 flex-1">
          <h3 className="text-xl font-bold mb-2 text-white">H∆∞·ªõng d·∫´n</h3>
          <p className="text-gray-300 text-lg">
            {currentStep === "done"
              ? "ƒê√£ ho√†n t·∫•t v·∫Ω v√πng v√† ph√°t hi·ªán m√£ QR. Nh·∫•n Tho√°t ƒë·ªÉ ti·∫øp t·ª•c."
              : currentStep === "mvd"
                ? analysisResult?.qr_detected
                  ? "ƒê√£ t√¨m th·∫•y m√£ QR. Nh·∫•n Ho√†n t·∫•t ƒë·ªÉ l∆∞u v√† ti·∫øp t·ª•c."
                  : "V·∫Ω l·∫°i v√πng m√£ v·∫≠n ƒë∆°n ho·∫∑c tho√°t."
                : handDetected
                  ? "Ti·∫øp t·ª•c x√°c ƒë·ªãnh v√πng m√£ v·∫≠n ƒë∆°n."
                  : "V·∫Ω l·∫°i v√πng packing ho·∫∑c tho√°t."}
          </p>
        </div>
        <div className="mt-auto space-y-2">
          {currentStep !== "done" && (
            <button
              onClick={handleRetryStep}
              className="w-full py-2 bg-yellow-600 hover:bg-yellow-700 text-white font-bold rounded"
            >
              V·∫Ω l·∫°i
            </button>
          )}
          {currentStep === "mvd" && analysisResult?.qr_detected && (
            <button
              onClick={handleConfirmRoi}
              className="w-full py-2 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded"
            >
              Ho√†n t·∫•t
            </button>
          )}
          {currentStep === "packing" && handDetected && (
            <button
              onClick={handleConfirmRoi}
              className="w-full py-2 bg-blue-600 hover:bg-blue-700 text-white font-bold rounded"
            >
              Ti·∫øp t·ª•c
            </button>
          )}
          <button
            onClick={onClose}
            className="w-full py-2 bg-red-600 hover:bg-red-700 text-white font-bold rounded"
          >
            Tho√°t
          </button>
        </div>
      </div>
      <div className="w-3/4 pl-4 flex flex-col">
        <div className="mb-4 flex justify-center items-center" style={{ maxHeight: 'calc(75vh - 2rem)', overflow: 'hidden' }}>
          {console.log("Rendering ROI frame with roiFrameSrc:", roiFrameSrc, "roiImageState:", roiImageState)}
          {roiFrameSrc && (
            <img 
              src={roiFrameSrc} 
              alt="ROI Frame" 
              className={`max-w-full max-h-full rounded ${imageAspectRatio && imageAspectRatio < 1 ? 'portrait' : 'landscape'}`}
              onLoad={handleImageLoad}
            />
          )}
        </div>
        {finalRoiFrameSrc && currentStep === "done" && (
          <div className="mb-4 flex justify-center items-center" style={{ maxHeight: 'calc(75vh - 2rem)', overflow: 'hidden' }}>
            <h4 className="text-lg font-bold text-white">·∫¢nh t·ªïng h·ª£p:</h4>
            <img 
              src={finalRoiFrameSrc} 
              alt="Final ROI Frame" 
              className={`max-w-full max-h-full rounded ${imageAspectRatio && imageAspectRatio < 1 ? 'portrait' : 'landscape'}`}
              onLoad={handleImageLoad}
            />
          </div>
        )}
      </div>
      <style jsx>{`
        .max-w-full {
          max-width: 100%;
        }
        .max-h-full {
          max-height: 100%;
        }
        .landscape {
          object-fit: contain;
          width: 100%;
        }
        .portrait {
          object-fit: contain;
          height: 100%;
        }
      `}</style>
    </div>
  );
};

export default InstructionsPanel;
```
## üìÑ File: `SourceCard.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/SourceCard.js`

```javascript
// components/config/SourceCard.js
import React from 'react';

const SourceCard = ({ source, onEdit, onDelete, onToggle }) => {
  const getSourceTypeIcon = (type) => {
    const icons = {
      'local': 'üíª',
      'network': 'üåê', 
      'camera': 'üìπ',
      'cloud': '‚òÅÔ∏è'
    };
    return icons[type] || 'üìÅ';
  };

  return (
    <div className="bg-gray-800 border border-gray-600 rounded-lg p-4 mb-3">
      <div className="flex justify-between items-start">
        <div className="flex-1">
          <div className="flex items-center gap-2 mb-2">
            <span className="text-xl">{getSourceTypeIcon(source.source_type)}</span>
            <h4 className="text-lg font-medium text-white">{source.name}</h4>
            <span className={`px-2 py-1 rounded text-xs font-medium ${
              source.active ? 'bg-green-600 text-white' : 'bg-red-600 text-white'
            }`}>
              {source.active ? 'Active' : 'Inactive'}
            </span>
          </div>
          <p className="text-gray-300 text-sm mb-1">
            <strong>Type:</strong> {source.source_type.toUpperCase()}
          </p>
          <p className="text-gray-300 text-sm break-all">
            <strong>Path:</strong> {source.path}
          </p>
        </div>
        
        <div className="flex gap-2 ml-4">
          <button
            onClick={() => onToggle(source.id, !source.active)}
            className={`px-3 py-1 rounded text-sm font-medium ${
              source.active 
                ? 'bg-yellow-600 hover:bg-yellow-700 text-white' 
                : 'bg-green-600 hover:bg-green-700 text-white'
            }`}
          >
            {source.active ? 'Disable' : 'Enable'}
          </button>
          <button
            onClick={() => onEdit(source)}
            className="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm font-medium"
          >
            Edit
          </button>
          <button
            onClick={() => onDelete(source.id)}
            className="px-3 py-1 bg-red-600 hover:bg-red-700 text-white rounded text-sm font-medium"
          >
            Delete
          </button>
        </div>
      </div>
    </div>
  );
};

export default SourceCard;
```
## üìÑ File: `CameraDialog.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/config/CameraDialog.js`

```javascript
const CameraDialog = ({
  showCameraDialog,
  setShowCameraDialog,
  cameras,
  selectedCameras,
  handleCameraSelection,
  handleSaveConfig,
}) => {
  if (!showCameraDialog) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-gray-800 p-6 rounded-lg w-1/2">
        <h2 className="text-2xl font-bold mb-4 text-white">X√°c nh·∫≠n camera</h2>
        <div className="max-h-64 overflow-y-auto">
          {cameras.map((camera) => (
            <label key={camera.name} className="flex items-center mb-2 text-white">
              <input
                type="checkbox"
                className="mr-2"
                checked={selectedCameras.includes(camera.name)}
                onChange={() => handleCameraSelection(camera.name)}
              />
              {camera.name} ({camera.path})
            </label>
          ))}
        </div>
        <div className="mt-4 flex justify-end gap-4">
          <button
            onClick={() => setShowCameraDialog(false)}
            className="py-2 px-4 bg-gray-600 text-white font-bold rounded"
          >
            H·ªßy
          </button>
          <button
            onClick={handleSaveConfig}
            className="py-2 px-4 bg-blue-600 text-white font-bold rounded"
          >
            X√°c nh·∫≠n
          </button>
        </div>
      </div>
    </div>
  );
};
export default CameraDialog;
```
## üìÑ File: `FileList.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/program/FileList.js`

```javascript
const FileList = ({ fileList }) => {
  if (!fileList || fileList.length === 0) {
    return (
      <div className="mt-4">
        <h3 className="text-lg font-bold">K·∫øt qu·∫£:</h3>
        <p>Kh√¥ng c√≥ file n√†o ƒë·ªÉ hi·ªÉn th·ªã.</p>
      </div>
    );
  }

  return (
    <div className="mt-4">
      <h3 className="text-lg font-bold">K·∫øt qu·∫£:</h3>
      <ul className="list-disc pl-5">
        {fileList.map((item, index) => (
          <li key={index}>{`${item.file}: ${item.status}`}</li>
        ))}
      </ul>
    </div>
  );
};

export default FileList;
```
## üìÑ File: `ProgramTab.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/program/ProgramTab.js`

```javascript
import { useState, useEffect } from "react";
import Card from "../ui/Card";
import FileList from "./FileList";

const ProgramTab = ({
  runningCard,
  fileList,
  customPath,
  firstRunCompleted,
  handleRunStop,
  isRunning,
  setCustomPath,
}) => {
  const [updatedFileList, setUpdatedFileList] = useState(fileList);

  useEffect(() => {
    const fetchProgress = async () => {
      try {
        const response = await fetch("http://localhost:8080/program-progress", {
          method: "GET",
          headers: { "Content-Type": "application/json" },
        });
        const data = await response.json();
        if (response.ok) {
          setUpdatedFileList(data.files);
        } else {
          console.error("Failed to fetch program progress:", data.error);
        }
      } catch (error) {
        console.error("Error fetching program progress:", error);
      }
    };

    fetchProgress();
    const intervalId = setInterval(fetchProgress, 10000);
    const timeoutId = setTimeout(() => {
      clearInterval(intervalId);
      console.log("Stopped polling /program-progress after 2 minutes");
    }, 120000);

    return () => {
      clearInterval(intervalId);
      clearTimeout(timeoutId);
    };
  }, [runningCard]);

  return (
    <div className="flex flex-col gap-6">
      <div className="grid grid-cols-3 gap-6">
        {!firstRunCompleted && (
          <Card
            title="L·∫ßn ƒë·∫ßu"
            description="Ch·∫°y l·∫ßn ƒë·∫ßu ƒë·ªÉ x·ª≠ l√Ω d·ªØ li·ªáu c∆° s·ªü."
            isRunning={isRunning("L·∫ßn ƒë·∫ßu")}
            onRunStop={firstRunCompleted ? null : () => handleRunStop("L·∫ßn ƒë·∫ßu")}
            isLocked={firstRunCompleted}
          />
        )}
        <Card
          title="M·∫∑c ƒë·ªãnh"
          description="Ch·∫°y khi kh·ªüi ƒë·ªông, ch·∫°y n·ªÅn."
          isRunning={isRunning("M·∫∑c ƒë·ªãnh")}
          onRunStop={() => handleRunStop("M·∫∑c ƒë·ªãnh")}
        />
        <Card
          title="Ch·ªâ ƒë·ªãnh"
          description="Ch·ªâ ƒë·ªãnh file c·ª• th·ªÉ."
          isRunning={isRunning("Ch·ªâ ƒë·ªãnh")}
          onRunStop={() => handleRunStop("Ch·ªâ ƒë·ªãnh", customPath)}
          onPathChange={(path) => setCustomPath(path)}
        />
      </div>
      <FileList fileList={updatedFileList} />
    </div>
  );
};

export default ProgramTab;
```
## üìÑ File: `TextInputSection.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/query/TextInputSection.js`

```javascript
const TextInputSection = ({ searchString, setSearchString, searchType }) => {
  const handleTextInputChange = (e) => {
    const value = e.target.value;
    const lines = value.split("\n");
    const codes = [];
    
    lines.forEach(line => {
      const trimmedLine = line.trim();
      if (!trimmedLine) return;
      const match = trimmedLine.match(/^\d+\.\s*(.+)$/);
      const lineContent = match ? match[1].trim() : trimmedLine;
      const lineCodes = lineContent.split(";").map(code => code.trim()).filter(code => code);
      codes.push(...lineCodes);
    });

    let formattedCodes = codes
      .map((code, index) => `${index + 1}. ${code}`)
      .join("\n");

    if (value.endsWith("\n")) {
      formattedCodes += `\n${codes.length + 1}. `;
    }

    setSearchString(formattedCodes);
  };

  return (
    <textarea
      value={searchString}
      onChange={handleTextInputChange}
      placeholder="Nh·∫≠p chu·ªói t√¨m ki·∫øm (m·ªói m√£ tr√™n m·ªôt d√≤ng)"
      className="w-full p-2 mb-4 rounded bg-gray-700 text-white h-1/2 overflow-y-auto whitespace-pre-wrap resize-none"
      disabled={searchType === "File"}
    />
  );
};

export default TextInputSection;
```
## üìÑ File: `TimeAndQuerySection.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/query/TimeAndQuerySection.js`

```javascript
import DatePicker from "react-datepicker";
import "react-datepicker/dist/react-datepicker.css";

const TimeAndQuerySection = ({
  startDate,
  setStartDate,
  endDate,
  setEndDate,
  defaultDays,
  setDefaultDays,
  searchString,
  searchType,
  fileContent,
  results,
  setResults,
  setSelectedVideos,
  setQueryCount,
  setFoundCount,
  foundCount,
  onQuery, // Prop ƒë·ªÉ nh·∫≠n h√†m debounce t·ª´ QueryComponent
  isQuerying, // Prop ƒë·ªÉ v√¥ hi·ªáu h√≥a n√∫t
}) => {
  const handleStartDateChange = (date) => {
    setStartDate(date);
    if (endDate) {
      const diffDays = (endDate - date) / (1000 * 60 * 60 * 24);
      if (diffDays > 30) {
        setEndDate(new Date(date.getTime() + 30 * 24 * 60 * 60 * 1000));
      } else if (date > endDate) {
        setEndDate(date);
      }
    }
  };

  const handleEndDateChange = (date) => {
    const today = new Date();
    if (date > today) {
      date = today;
    }
    if (startDate) {
      const diffDays = (date - startDate) / (1000 * 60 * 60 * 24);
      if (diffDays > 30) {
        setStartDate(new Date(date.getTime() - 30 * 24 * 60 * 60 * 1000));
      } else if (date < startDate) {
        setStartDate(date);
      }
    }
    setEndDate(date);
  };

  return (
    <>
      <div className="mb-4">
        <label className="block mb-1">Th·ªùi gian m·∫∑c ƒë·ªãnh (ng√†y):</label>
        <input
          type="number"
          value={defaultDays}
          onChange={(e) => setDefaultDays(Number(e.target.value))}
          className="w-full p-2 rounded bg-gray-700 text-white"
        />
      </div>
      <div className="flex gap-4 mb-4">
        <div className="flex-1">
          <label className="block mb-1">T·ª´:</label>
          <DatePicker
            selected={startDate}
            onChange={handleStartDateChange}
            showTimeSelect
            timeIntervals={60}
            dateFormat="Pp"
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
        <div className="flex-1">
          <label className="block mb-1">ƒê·∫øn:</label>
          <DatePicker
            selected={endDate}
            onChange={handleEndDateChange}
            showTimeSelect
            timeIntervals={60}
            dateFormat="Pp"
            maxDate={new Date()}
            className="w-full p-2 rounded bg-gray-700 text-white"
          />
        </div>
      </div>
      <button
        onClick={onQuery} // D√πng onQuery t·ª´ props
        disabled={isQuerying} // V√¥ hi·ªáu h√≥a n√∫t khi ƒëang x·ª≠ l√Ω
        className={`w-full py-2 bg-green-600 text-white font-bold rounded ${isQuerying ? "opacity-50 cursor-not-allowed" : ""}`}
      >
        Truy v·∫•n
      </button>
    </>
  );
};

export default TimeAndQuerySection;
```
## üìÑ File: `FileInputSection.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/query/FileInputSection.js`

```javascript
const FileInputSection = ({ path, setPath, fileContent, setFileContent, setShowModal, setHeaders }) => {
  const handleOpenExplorer = () => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = ".csv,.xlsx";
    input.onchange = (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const fileName = file.name.toLowerCase();
      const fileType = file.type;

      // Ki·ªÉm tra ƒëu√¥i file
      if (!fileName.endsWith(".csv") && !fileName.endsWith(".xlsx")) {
        alert("Vui l√≤ng ch·ªçn file CSV ho·∫∑c Excel (.csv, .xlsx)");
        return;
      }

      // Ki·ªÉm tra MIME type
      const validCsvMimeTypes = ["text/csv", "application/csv"];
      const validXlsxMimeTypes = [
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "application/vnd.ms-excel",
      ];
      if (fileName.endsWith(".csv") && !validCsvMimeTypes.includes(fileType)) {
        alert("File kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng CSV. Vui l√≤ng ch·ªçn file CSV h·ª£p l·ªá.");
        return;
      }
      if (fileName.endsWith(".xlsx") && !validXlsxMimeTypes.includes(fileType)) {
        alert("File kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng Excel. Vui l√≤ng ch·ªçn file XLSX h·ª£p l·ªá.");
        return;
      }

      setPath(file.name);

      const reader = new FileReader();
      reader.onload = (event) => {
        const arrayBuffer = event.target.result;
        const bytes = new Uint8Array(arrayBuffer);
        const binary = Array.from(bytes).map((b) => String.fromCharCode(b)).join("");
        const base64 = btoa(binary); // Base64 encode t·ª´ nh·ªã ph√¢n
        setFileContent(base64);
      };
      reader.onerror = () => {
        alert("L·ªói khi ƒë·ªçc file");
      };
      reader.readAsArrayBuffer(file); // ƒê·ªçc raw binary
    };
    input.click();
  };

  const handleConfirmFile = async () => {
    if (!path) {
      alert("Vui l√≤ng ch·ªçn file CSV ho·∫∑c nh·∫≠p ƒë∆∞·ªùng d·∫´n");
      return;
    }
    try {
      const response = await fetch("http://localhost:8080/get-csv-headers", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          file_path: path,
          file_content: fileContent || "",
          is_excel: path.toLowerCase().endsWith(".xlsx"),
        }),
      });
      const result = await response.json();
      if (response.ok) {
        setHeaders(result.headers || []);
        setShowModal(true);
      } else {
        throw new Error(result.error || "Failed to get CSV headers");
      }
    } catch (error) {
      console.error("Error getting CSV headers:", error);
      alert(error.message || "Failed to get CSV headers");
    }
  };

  return (
    <div className="mb-4">
      <div className="relative w-full mb-2">
        <input
          type="text"
          value={path}
          onChange={(e) => setPath(e.target.value)}
          placeholder="Ch·ªçn file ƒë·ªãnh d·∫°ng *.csv ho·∫∑c *.xlsx"
          className="w-full p-2 rounded bg-gray-700 text-white"
        />
        <button
          type="button"
          onClick={handleOpenExplorer}
          className="absolute right-2 top-1/2 transform -translate-y-1/2 text-white"
        >
          ...
        </button>
      </div>
      <button
        onClick={handleConfirmFile}
        className="w-full py-2 bg-yellow-500 text-white font-bold rounded"
      >
        X√°c nh·∫≠n
      </button>
    </div>
  );
};

export default FileInputSection;
```
## üìÑ File: `ColumnSelectorModal.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/components/query/ColumnSelectorModal.js`

```javascript
const ColumnSelectorModal = ({
  showModal,
  setShowModal,
  headers,
  selectedColumn,
  setSelectedColumn,
  history,
  setHistory,
  selectedPlatform,
  setSelectedPlatform,
  shopeeLabel,
  setShopeeLabel,
  lazadaLabel,
  setLazadaLabel,
  tiktokLabel,
  setTiktokLabel,
  customLabel1,
  setCustomLabel1,
  customLabel2,
  setCustomLabel2,
  path,
  fileContent,
  setSearchString,
  setSearchType,
}) => {
  const handleModalConfirm = async () => {
    const columnName = history[selectedPlatform] || "tracking_codes";
    const data = {
      file_path: path,
      file_content: fileContent || "",
      column_name: columnName,
      is_excel: path.toLowerCase().endsWith(".xlsx"), // Th√™m logic x√°c ƒë·ªãnh is_excel d·ª±a tr√™n path
    };
    try {
      console.log("Sending file data:", data);
      const response = await fetch("http://localhost:8080/parse-csv", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      const result = await response.json();
      console.log("Response from parse-csv:", result);
      if (response.ok) {
        const trackingCodes = result.tracking_codes || [];
        const formattedCodes = trackingCodes
          .map((code, index) => `${index + 1}. ${code}`)
          .join("\n");
        setSearchString(formattedCodes);
        setSearchType("Text");
        setShowModal(false);
      } else {
        throw new Error(result.error || "Failed to parse CSV");
      }
    } catch (error) {
      console.error("Error parsing CSV:", error);
      alert(error.message || "Failed to parse CSV");
    }
  };

  const handleUpdateColumn = () => {
    const newColumn = selectedColumn;
    const updatedHistory = { ...history };
    updatedHistory[selectedPlatform] = newColumn;
    setHistory(updatedHistory);
    localStorage.setItem("trackingColumnHistory", JSON.stringify(updatedHistory));

    const updatedLabels = {
      Shopee: shopeeLabel,
      Lazada: lazadaLabel,
      Tiktok: tiktokLabel,
      Custom1: customLabel1,
      Custom2: customLabel2,
    };
    localStorage.setItem("platformLabels", JSON.stringify(updatedLabels));
  };

  const handlePlatformChange = (platform) => {
    setSelectedPlatform(platform);
    setSelectedColumn(history[platform] || "tracking_codes");
  };

  if (!showModal) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <div className="bg-gray-800 p-6 rounded-lg w-1/2">
        <h2 className="text-xl font-bold mb-4">Ch·ªçn c·ªôt m√£ v·∫≠n ƒë∆°n</h2>
        <div className="mb-4">
          <label className="block mb-1">Ch·ªçn t·ª´ danh s√°ch:</label>
          <select
            value={selectedColumn}
            onChange={(e) => setSelectedColumn(e.target.value)}
            className="w-full p-2 rounded bg-gray-700 text-white"
          >
            {headers.map((header, index) => (
              <option key={index} value={header}>{header}</option>
            ))}
          </select>
        </div>
        <div className="mb-4">
          <button
            onClick={handleUpdateColumn}
            className="w-full py-2 bg-blue-600 text-white font-bold rounded"
          >
            C·∫≠p nh·∫≠t
          </button>
        </div>
        <div className="mb-4">
          <h3 className="text-lg font-bold mb-2">L·ªãch s·ª≠ l·ª±a ch·ªçn:</h3>
          <label className="flex items-center mb-2">
            <input
              type="radio"
              name="platform"
              value="Shopee"
              checked={selectedPlatform === "Shopee"}
              onChange={() => handlePlatformChange("Shopee")}
              className="mr-2"
            />
            <input
              type="text"
              value={shopeeLabel}
              onChange={(e) => setShopeeLabel(e.target.value)}
              placeholder="T√™n Shopee"
              className="mr-2 p-1 rounded bg-gray-700 text-white"
            />
            <input
              type="text"
              value={history.Shopee}
              onChange={(e) => setHistory({ ...history, Shopee: e.target.value })}
              className="p-1 rounded bg-gray-700 text-white"
            />
          </label>
          <label className="flex items-center mb-2">
            <input
              type="radio"
              name="platform"
              value="Lazada"
              checked={selectedPlatform === "Lazada"}
              onChange={() => handlePlatformChange("Lazada")}
              className="mr-2"
            />
            <input
              type="text"
              value={lazadaLabel}
              onChange={(e) => setLazadaLabel(e.target.value)}
              placeholder="T√™n Lazada"
              className="mr-2 p-1 rounded bg-gray-700 text-white"
            />
            <input
              type="text"
              value={history.Lazada}
              onChange={(e) => setHistory({ ...history, Lazada: e.target.value })}
              className="p-1 rounded bg-gray-700 text-white"
            />
          </label>
          <label className="flex items-center mb-2">
            <input
              type="radio"
              name="platform"
              value="Tiktok"
              checked={selectedPlatform === "Tiktok"}
              onChange={() => handlePlatformChange("Tiktok")}
              className="mr-2"
            />
            <input
              type="text"
              value={tiktokLabel}
              onChange={(e) => setTiktokLabel(e.target.value)}
              placeholder="T√™n Tiktok"
              className="mr-2 p-1 rounded bg-gray-700 text-white"
            />
            <input
              type="text"
              value={history.Tiktok}
              onChange={(e) => setHistory({ ...history, Tiktok: e.target.value })}
              className="p-1 rounded bg-gray-700 text-white"
            />
          </label>
          <label className="flex items-center mb-2">
            <input
              type="radio"
              name="platform"
              value="Custom1"
              checked={selectedPlatform === "Custom1"}
              onChange={() => handlePlatformChange("Custom1")}
              className="mr-2"
            />
            <input
              type="text"
              value={customLabel1}
              onChange={(e) => setCustomLabel1(e.target.value)}
              placeholder="T√™n t√πy ch·ªânh 1"
              className="mr-2 p-1 rounded bg-gray-700 text-white"
            />
            <input
              type="text"
              value={history.Custom1}
              onChange={(e) => setHistory({ ...history, Custom1: e.target.value })}
              className="p-1 rounded bg-gray-700 text-white"
            />
          </label>
          <label className="flex items-center mb-2">
            <input
              type="radio"
              name="platform"
              value="Custom2"
              checked={selectedPlatform === "Custom2"}
              onChange={() => handlePlatformChange("Custom2")}
              className="mr-2"
            />
            <input
              type="text"
              value={customLabel2}
              onChange={(e) => setCustomLabel2(e.target.value)}
              placeholder="T√™n t√πy ch·ªânh 2"
              className="mr-2 p-1 rounded bg-gray-700 text-white"
            />
            <input
              type="text"
              value={history.Custom2}
              onChange={(e) => setHistory({ ...history, Custom2: e.target.value })}
              className="p-1 rounded bg-gray-700 text-white"
            />
          </label>
        </div>
        <div className="flex justify-end gap-4">
          <button
            onClick={() => setShowModal(false)}
            className="py-2 px-4 bg-gray-600 text-white rounded"
          >
            H·ªßy
          </button>
          <button
            onClick={handleModalConfirm}
            className="py-2 px-4 bg-green-600 text-white rounded"
          >
            X√°c nh·∫≠n
          </button>
        </div>
      </div>
    </div>
  );
};

export default ColumnSelectorModal;
```
## üìÑ File: `useVtrackConfig.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/hooks/useVtrackConfig.js`

```javascript
import { useState, useEffect } from "react";

const useVtrackConfig = () => {
  const [fromTime, setFromTime] = useState(null);
  const [toTime, setToTime] = useState(null);
  const [country, setCountry] = useState("Vi·ªát Nam");
  const [timezone, setTimezone] = useState("UTC+7");
  const [brandName, setBrandName] = useState("");
  const [inputPath, setInputPath] = useState("");
  const [outputPath, setOutputPath] = useState("");
  const [workingDays, setWorkingDays] = useState([]);
  const [defaultDays, setDefaultDays] = useState(30);
  const [minPackingTime, setMinPackingTime] = useState(10);
  const [maxPackingTime, setMaxPackingTime] = useState(120);
  const [frameRate, setFrameRate] = useState(30);
  const [frameInterval, setFrameInterval] = useState(5);
  const [videoBuffer, setVideoBuffer] = useState(2);
  const [cameras, setCameras] = useState([]);
  const [selectedCameras, setSelectedCameras] = useState([]);
  const [showCameraDialog, setShowCameraDialog] = useState(false);
  const [error, setError] = useState(null);
  const [runDefaultOnStart, setRunDefaultOnStart] = useState(false);

  const countries = [
    "Vi·ªát Nam", "Nh·∫≠t B·∫£n", "H√†n Qu·ªëc", "Th√°i Lan", "Singapore",
    "M·ªπ", "Anh", "Ph√°p", "ƒê·ª©c", "√öc"
  ];

  const countryTimezones = {
    "Vi·ªát Nam": "UTC+7", "Nh·∫≠t B·∫£n": "UTC+9", "H√†n Qu·ªëc": "UTC+9",
    "Th√°i Lan": "UTC+7", "Singapore": "UTC+8", "M·ªπ": "UTC-5",
    "Anh": "UTC+0", "Ph√°p": "UTC+1", "ƒê·ª©c": "UTC+1", "√öc": "UTC+10"
  };

  const BASE_DIR = "/Users/annhu/vtrack_app/V_Track";

  useEffect(() => {
    const fetchCameraFolders = async () => {
      try {
        // ‚úÖ SIMPLIFIED - single source of truth
        const response = await fetch("http://localhost:8080/get-camera-folders");
        if (response.ok) {
          const data = await response.json();
          if (Array.isArray(data.folders)) {
            setCameras(data.folders);
            setError(null);
          } else {
            setCameras([]);
            setError(data.error || "Failed to load camera folders");
          }
        } else {
          setCameras([]);
          setError("Camera folders not available");
        }
      } catch (error) {
        console.error("Error fetching camera folders:", error);
        setError("Error fetching camera folders: " + error.message);
        setCameras([]);
      }
    };
    fetchCameraFolders();
  }, []);

  const handleCountryChange = (e) => {
    const selectedCountry = e.target.value;
    setCountry(selectedCountry);
    setTimezone(countryTimezones[selectedCountry] || "UTC+0");
  };

  const handleFromTimeChange = (time) => {
    setFromTime(time);
    if (toTime && time > toTime) setToTime(time);
  };

  const handleToTimeChange = (time) => {
    if (fromTime && time < fromTime) setFromTime(time);
    setToTime(time);
  };

  const handleWorkingDayChange = (day) => {
    setWorkingDays((prev) =>
      prev.includes(day) ? prev.filter((d) => d !== day) : [...prev, day]
    );
  };

  useEffect(() => {
    console.log("workingDays updated:", workingDays);
  }, [workingDays]);

  const handleOpenExplorer = (type) => {
    const input = document.createElement("input");
    input.type = "file";
    input.webkitdirectory = true;
    input.onchange = (e) => {
      const files = e.target.files;
      if (files.length > 0) {
        const file = files[0];
        let selectedPath = file.path || file.webkitRelativePath || file.name || "";
        if (!selectedPath.startsWith('/')) {
          selectedPath = `${BASE_DIR}/${selectedPath}`;
        }
        selectedPath = selectedPath.split('/').slice(0, -1).join('/');
        if (selectedPath.includes('.DS_Store')) {
          selectedPath = selectedPath.replace('/.DS_Store', '');
        }
        console.log(`Selected ${type} path:`, selectedPath);
        if (type === "input") setInputPath(selectedPath);
        else setOutputPath(selectedPath);
      }
    };
    input.click();
  };

  const handleSaveGeneralInfo = async () => {
    const data = {
      country,
      timezone,
      brand_name: brandName,
      working_days: workingDays.length > 0 ? workingDays : ["Th·ª© Hai", "Th·ª© Ba", "Th·ª© T∆∞", "Th·ª© NƒÉm", "Th·ª© S√°u", "Th·ª© B·∫£y", "Ch·ªß Nh·∫≠t"],
      from_time: fromTime ? fromTime.toLocaleTimeString('en-GB', { hour: '2-digit', minute: '2-digit', hour12: false }) : "07:00",
      to_time: toTime ? toTime.toLocaleTimeString('en-GB', { hour: "2-digit", minute: "2-digit", hour12: false }) : "23:00",
    };
    console.log("Data sent to /api/config/save-general-info:", data);
    try {
      const response = await fetch("http://localhost:8080/save-general-info", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      if (response.ok) alert("General info saved successfully");
      else throw new Error("Failed to save general info");
    } catch (error) {
      console.error("Error saving general info:", error);
      alert("Failed to save general info");
    }
  };

  const handleSaveConfig = async () => {
    let normalizedInputPath = inputPath.trim();
    if (!normalizedInputPath) {
      alert("Input path cannot be empty");
      return;
    }
    if (!normalizedInputPath.startsWith('/')) {
      normalizedInputPath = `${BASE_DIR}/${normalizedInputPath}`;
    }
    if (normalizedInputPath.includes('.DS_Store')) {
      normalizedInputPath = normalizedInputPath.replace('/.DS_Store', '');
    }

    let normalizedOutputPath = outputPath.trim();
    if (!normalizedOutputPath) {
      normalizedOutputPath = `${BASE_DIR}/output_clips`;
    }
    if (!normalizedOutputPath.startsWith('/')) {
      normalizedOutputPath = `${BASE_DIR}/${normalizedOutputPath}`;
    }
    if (normalizedOutputPath.includes('.DS_Store')) {
      normalizedOutputPath = normalizedOutputPath.replace('/.DS_Store', '');
    }

    const data = {
      video_root: normalizedInputPath,
      output_path: normalizedOutputPath,
      db_path: "/Users/annhu/Downloads/V_Track project/events.db",
      default_days: defaultDays,
      min_packing_time: minPackingTime,
      max_packing_time: maxPackingTime,
      frame_rate: frameRate,
      frame_interval: frameInterval,
      video_buffer: videoBuffer,
      selected_cameras: selectedCameras,
    };
    console.log("Data sent to /save-config:", data);
    try {
      const response = await fetch("http://localhost:8080/api/config/save-config", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(data),
      });
      const result = await response.json();
      if (response.ok) {
        localStorage.setItem("configSet", "true");
        alert("Configuration saved successfully");
        setShowCameraDialog(false);
        const cameraResponse = await fetch("http://localhost:8080/get-cameras");
        const cameraData = await cameraResponse.json();
        if (cameraData && Array.isArray(cameraData.cameras)) {
          setCameras(cameraData.cameras.map(name => ({ name, path: "" })));
          setError(null);
        } else {
          setCameras([]);
          setError(cameraData?.error || "Failed to load cameras");
        }
      } else {
        throw new Error(result.error || "Failed to save config");
      }
    } catch (error) {
      console.error("Error saving config:", error);
      alert("Failed to save config: " + error.message);
    }
  };

  const handleShowCameraDialog = () => {
    setShowCameraDialog(true);
  };

  const handleCameraSelection = (cameraName) => {
    setSelectedCameras((prev) =>
      prev.includes(cameraName) ? prev.filter((c) => c !== cameraName) : [...prev, cameraName]
    );
  };

  return {
    fromTime,
    setFromTime,
    toTime,
    setToTime,
    country,
    setCountry,
    timezone,
    setTimezone,
    brandName,
    setBrandName,
    inputPath,
    setInputPath,
    outputPath,
    setOutputPath,
    workingDays,
    setWorkingDays,
    defaultDays,
    setDefaultDays,
    minPackingTime,
    setMinPackingTime,
    maxPackingTime,
    setMaxPackingTime,
    frameRate,
    setFrameRate,
    frameInterval,
    setFrameInterval,
    videoBuffer,
    setVideoBuffer,
    cameras,
    setCameras,
    selectedCameras,
    setSelectedCameras,
    showCameraDialog,
    setShowCameraDialog,
    error,
    setError,
    handleCountryChange,
    handleFromTimeChange,
    handleToTimeChange,
    handleWorkingDayChange,
    handleOpenExplorer,
    handleSaveGeneralInfo,
    handleSaveConfig,
    handleShowCameraDialog,
    handleCameraSelection,
    runDefaultOnStart,
    setRunDefaultOnStart,
  };
};

export default useVtrackConfig;
```
## üìÑ File: `useProgramLogic.js`
**ƒê∆∞·ªùng d·∫´n:** `/Users/annhu/vtrack_app/V_Track/frontend/src/hooks/useProgramLogic.js`

```javascript
import { useState, useEffect } from "react";
import { runProgram, confirmRun } from "../api";

const useProgramLogic = () => {
  const [runningCard, setRunningCard] = useState("M·∫∑c ƒë·ªãnh");
  const [fileList, setFileList] = useState([]);
  const [customPath, setCustomPath] = useState("");
  const [showConfirmButton, setShowConfirmButton] = useState(false);
  const [firstRunCompleted, setFirstRunCompleted] = useState(false);
  const [isLocked, setIsLocked] = useState(false);

  const checkFirstRun = async () => {
    try {
      const response = await fetch("http://localhost:8080/check-first-run");
      const data = await response.json();
      setFirstRunCompleted(data.first_run_completed);
    } catch (error) {
      console.error("Error checking first run:", error);
    }
  };

  const checkDefaultRunning = async () => {
    try {
      const response = await fetch("http://localhost:8080/program", {
        method: "GET",
      });
      const data = await response.json();
      setRunningCard("M·∫∑c ƒë·ªãnh"); // √âp M·∫∑c ƒë·ªãnh khi refresh
      setIsLocked(false);
    } catch (error) {
      console.error("Error checking default running state:", error);
      setRunningCard("M·∫∑c ƒë·ªãnh"); // √âp M·∫∑c ƒë·ªãnh n·∫øu l·ªói
      setIsLocked(false);
    }
  };

  useEffect(() => {
    const initializeState = async () => {
      await checkFirstRun();
      await checkDefaultRunning();
    };
    initializeState();
  }, []);

  const handleRunStop = async (cardTitle, path = "") => {
    if (cardTitle === "L·∫ßn ƒë·∫ßu" && firstRunCompleted) {
      return;
    }

    if (isLocked) {
      alert("H·ªá th·ªëng ƒëang x·ª≠ l√Ω, vui l√≤ng ƒë·ª£i!");
      return;
    }

    try {
      let days = null;
      if (cardTitle === "L·∫ßn ƒë·∫ßu" && !isRunning(cardTitle)) {
        days = prompt("B·∫°n mu·ªën x·ª≠ l√Ω bao nhi√™u ng√†y? (T·ªëi ƒëa 30 ng√†y)", "30");
        days = parseInt(days);
        if (isNaN(days) || days <= 0 || days > 30) {
          alert("S·ªë ng√†y kh√¥ng h·ª£p l·ªá. Vui l√≤ng nh·∫≠p t·ª´ 1 ƒë·∫øn 30.");
          return;
        }
      } else if (cardTitle === "Ch·ªâ ƒë·ªãnh" && !isRunning(cardTitle)) {
        if (!path) {
          alert("Vui l√≤ng ch·ªçn ƒë∆∞·ªùng d·∫´n cho ch∆∞∆°ng tr√¨nh Ch·ªâ ƒë·ªãnh.");
          return;
        }
        setIsLocked(true);
      }

      const response = await runProgram({
        card: cardTitle,
        action: isRunning(cardTitle) ? "stop" : "run",
        days: days,
        custom_path: cardTitle === "Ch·ªâ ƒë·ªãnh" ? path : ""
      });

      if (response.status === 200) {
        if (isRunning(cardTitle)) {
          if (cardTitle === "M·∫∑c ƒë·ªãnh") {
            setRunningCard(null);
            setFileList([]);
            alert(`ƒê√£ d·ª´ng ch∆∞∆°ng tr√¨nh ${cardTitle}`);
          }
        } else {
          if (cardTitle !== "L·∫ßn ƒë·∫ßu" || !firstRunCompleted) {
            setRunningCard(cardTitle);
            setShowConfirmButton(true);
            if (cardTitle !== "Ch·ªâ ƒë·ªãnh") {
              setIsLocked(false);
            }
          }
        }
      }
    } catch (error) {
      console.error("Error calling API:", error);
      setIsLocked(false);
      if (error.response?.status === 400) {
        alert(error.response.data.error);
      } else {
        alert("C√≥ l·ªói x·∫£y ra khi g·ªçi API. Vui l√≤ng ki·ªÉm tra server.");
      }
    }
  };

  const handleConfirmRun = async () => {
    try {
      const response = await confirmRun({ card: runningCard });
      if (response.status === 200) {
        setShowConfirmButton(false);
        setFileList(response.data.files || []);
        if (runningCard === "L·∫ßn ƒë·∫ßu") {
          setFirstRunCompleted(true);
          await checkFirstRun();
        }
        if (runningCard === "Ch·ªâ ƒë·ªãnh") {
          setIsLocked(false);
          await checkDefaultRunning();
        }
      }
    } catch (error) {
      console.error("Error confirming run:", error);
      setIsLocked(false);
      alert("C√≥ l·ªói x·∫£y ra khi x√°c nh·∫≠n ch·∫°y ch∆∞∆°ng tr√¨nh.");
    }
  };

  const isRunning = (cardTitle) => runningCard === cardTitle;

  return {
    runningCard,
    setRunningCard,
    fileList,
    setFileList,
    customPath,
    setCustomPath,
    showConfirmButton,
    setShowConfirmButton,
    firstRunCompleted,
    setFirstRunCompleted,
    handleRunStop,
    handleConfirmRun,
    isRunning,
    isLocked
  };
};

export default useProgramLogic;
```